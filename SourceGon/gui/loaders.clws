
import renderer.clws

import images.clws


< BufferedImage : \java.\awt.\image;
< ImageIO : \javax.\imageio;
< ByteOrder : \java.\nio;
< ByteBuffer : java.nio;
< FloatBuffer : \java.\nio;
< IntBuffer : \java.\nio;
< GL11        : \org.\lwjgl.\opengl;
< GL12        : \org.\lwjgl.\opengl;
< GLU        : \org.\lwjgl.\util.\glu;
< PixelGrabber : \java.\awt.\image;
< DisplayMode : \org.\lwjgl.\opengl;
< Display : \org.\lwjgl.\opengl;
< Keyboard : \org.\lwjgl.\input ;
< Mouse : \org.\lwjgl.\input ;
< Cursor : \org.\lwjgl.\input ;
< Sys : \org.\lwjgl ;
< PixelFormat : \org.\lwjgl.\opengl;


> Integer INT_SIZE = 4;
> String finalImageStatesClassName = "final Gui.Image.States";

enum  'packageName'.gui.images  ImageStates {
  void DEFAULT;
  void ASCEND;
}
class 'packageName'.gui.images  Images {
  class Flipped // {
  }
}
class 'packageName'.gui.images Colours {}
class 'packageName'.gui.images Drawables {}
class 'packageName'.gui.images ImageLoader {
> Map<Class , Parameters > animationCreationParameters = new HashMap< Class , Parameters >();
> Map<Class , Parameters > animationCreationArguments = new HashMap< Class , Parameters >();
  FloatBuffer placeHolder = null;
  void load(){
  }
> void declaration(%T input, Class enclosingClass){
    String animationTypeName = ^input->"animationTypeName";
    if enclosingClass == Gui->Image->AnimationType {
      enclosingClass += ~class animationTypeName // Gui->Renderable{
        void animate(){ }
        void render(){
          \animationRender();
        }
        Integer getTexture(){
          return \getImageTexture();
        }
      }
    }
    else {
      enclosingClass += ~class animationTypeName // Gui->Renderable{
        void animate(){ }
        void render(){
          \animationRender();
        }
        Integer getTexture(){
          return \getImageTexture();
        }
      }
    }
    Parameters parameters = new Parameters ();
    Parameters arguments = new Parameters ();
    input : variable : animation_type_variable_declaration {
      variable : element : animation_variable_value {
        arguments.add(|'variable->"variableName"'|);
        element : value : INTEGER {
          enclosingClass->'animationTypeName' += Integer 'variable->"variableName"' = 'value';
          parameters.add(Integer 'variable->"variableName"' = 'value';);
        }
        element : value : FLOAT {
          enclosingClass->'animationTypeName' += Float 'variable->"variableName"' = 'value'+"f";
          parameters.add(Integer 'variable->"variableName"' = 'value';);
        }
        element : value : quote {
          enclosingClass->'animationTypeName' += String 'variable->"variableName"' = ''value'';
          parameters.add(Integer 'variable->"variableName"' = 'value';);
        }
      }
    }
    animationCreationParameters.put(enclosingClass->'animationTypeName' , parameters);
    animationCreationArguments.put(enclosingClass->'animationTypeName' , arguments);
    ~Class creationClass = enclosingClass->'animationTypeName';
    ~String creationName = "";
    Parameters previousParameters = new Parameters ();
    Parameters previousArguments = new Parameters ();
    ~String previousCreationName = null;
    while creationClass.getEnclosingClass() != Gui->Image->AnimationType {
      creationName = 'creationClass.getName()'\+ creationName;
      String createMethodName = "create"\+'creationName';
      Class upperClass = creationClass.getEnclosingClass();
      Parameters realParameters = new Parameters ();
      realParameters.addAll(animationCreationParameters.get(creationClass));
      realParameters.addAll(previousParameters);
      Statement creation = new Statement ();
      creation.add(|new creationClass(`animationCreationArguments.get(creationClass)`)|);
      if previousCreationName != null {
        creation.set(".");
        String currentPreviousCreationName = previousCreationName;
        Parameters currentPreviousArguements = new Parameters();
        currentPreviousArguements.addAll(previousArguments);
        creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
      }
      previousCreationName = createMethodName;
      upperClass += enclosingClass->'animationTypeName' 'createMethodName' `realParameters` {
        return `creation`;
      }
      previousParameters.addAll(animationCreationParameters.get(creationClass));
      previousArguments.addAll(animationCreationArguments.get(creationClass));
      creationClass = upperClass;
    }
    creationName = 'creationClass.getName()'\+ creationName;
    String createMethodName = "create"\+'creationName';
    Parameters realParameters = new Parameters ();
    realParameters.addAll(animationCreationParameters.get(creationClass));
    realParameters.addAll(previousParameters);
    Statement creation = new Statement ();
    creation.add(|new creationClass(`animationCreationArguments.get(creationClass)`)|);
    if previousCreationName != null {
      creation.set(".");
      String currentPreviousCreationName = previousCreationName;
      Parameters currentPreviousArguements = new Parameters();
      currentPreviousArguements.addAll(previousArguments);
      creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
    }
    Gui->Image->AnimationType += enclosingClass->'animationTypeName' 'createMethodName' `realParameters` {
      return `creation`;
    }
    Parameters imageAnimationParameters = new Parameters ();
    imageAnimationParameters.add( Integer animationX = 0; );
    imageAnimationParameters.add( Integer animationY = 0; );
    Parameters imageAnimationArguments = new Parameters();
    imageAnimationArguments.add( |"animationX"| );
    imageAnimationArguments.add( |"animationY"| );
    String currentPreviousCreationName = "create"\+creationName;
    Parameters currentPreviousArguements = new Parameters ();
    currentPreviousArguements.addAll(animationCreationArguments.get(creationClass));
    if previousCreationName != null {
      imageAnimationParameters.addAll(animationCreationParameters.get(creationClass));
      imageAnimationParameters.addAll(previousParameters);
      currentPreviousArguements.addAll(previousArguments);
      Gui->Image += enclosingClass->'animationTypeName' 'createMethodName' `imageAnimationParameters` {
        Gui->Image->AnimationType base = new Gui->Image->AnimationType(`imageAnimationArguments`);
        return base.'currentPreviousCreationName'(`currentPreviousArguements`);
      }
    }
    else {
      imageAnimationParameters.addAll(animationCreationParameters.get(creationClass));
      Gui->Image += enclosingClass->'animationTypeName' 'createMethodName' `imageAnimationParameters` {
        Gui->Image->AnimationType base = new Gui->Image->AnimationType(`imageAnimationArguments`);
        return base.'currentPreviousCreationName'(`currentPreviousArguements`);
      }
    }
    input : element : animation_type_element {
      element : atom : animation_type_declaration {
        ImageLoader.declaration(atom,enclosingClass->'animationTypeName');
      }
      element : atom : statement {
        Statement statement = new Statement ();
        statement.add(|'atom->"variableName"'|);
        statement.set('atom->"animation_type_operator"');
        atom : quark : animation_type_value {
          statement.add(|'quark'|);
        }
        : animation_type_arithmetic_operator {
          statement.set('quark'.trim());
        }
        
        if atom->"animation_type_condition" != null {
          Statement header = new Statement ();
          atom->"animation_type_condition" : quark : animation_type_boolean {
            Statement headerElement = new Statement();
            headerElement.add(|'quark->"leftName"'|);
            headerElement.set('quark->"animation_type_boolean_operator"');
            quark : energy : animation_type_value {
              energy : quanta : INTEGER {
                headerElement.add(|'quanta'|);
              }
              : FLOAT {
                headerElement.add(|'quanta'+"f"|);
              }
              : NAME {
                headerElement.add(|'quanta'|);
              }
              : frameName {
                String methodName = "get" \+ ^quanta;
                headerElement.add(|"frames".'methodName'()|);
              }
              
            }
            : animation_type_arithmetic_operator {
              headerElement.set('energy'.trim());
            }
            header.add(headerElement);
          }
          : animation_type_continuation_operator {
            if 'quark'.contains("&") {
              header.set("&&");
            }
            else if 'quark'.contains("|") {
              header.set("||");
            }
          }
          enclosingClass->'animationTypeName'->*"animate".appendToBody({if `header` {`statement`;}});
        }
        else {
          enclosingClass->'animationTypeName'->*"animate".appendToBody({`statement`;});
        }
      }
    }
  }
> Set<String> declaredImageLoaders = new HashSet<String>();
> Set<String> declaredLoadingImages = new HashSet<String>();
> void declareImageLoader(String imageName, String imageFileName, Integer imageWidth, Integer imageHeight){
    StringBuilder imageLoaderName = new StringBuilder();
    int lastIndexOfDot = imageFileName.lastIndexOf(".");
    if lastIndexOfDot > -1 {
      imageLoaderName.append(imageFileName.substring(0,lastIndexOfDot).replace("/","_").replace("\\","_").replace(".","_"));
    }
    else {
      imageLoaderName.append(imageFileName.replace("/","_").replace("\\","_").replace(".","_"));
    }
    imageLoaderName.append("DataLoader");
    if declaredLoadingImages.add('imageLoaderName') == false {
      ImageLoader->*"load".appendToBody({
        'imageLoaderName'.attachTextures(Images->'imageName',Images->Flipped->'imageName');
      });
      return void;
    }
    
    String imageLoaderClassName = "ImageData"\+'imageWidth'\+"x"\+'imageHeight'\+"Loader";
    ImageLoader->*"load".prependToBody({
      'imageLoaderName'.start();
    });
    ImageLoader->*"load".prependToBody({'imageLoaderClassName' 'imageLoaderName' = new 'imageLoaderClassName'('' 'imageFileName' '');});
    ImageLoader->*"load".appendToBody({
        'imageLoaderName'.attachTextures(Images->'imageName',Images->Flipped->'imageName');
      });
    if declaredImageLoaders.add(imageLoaderClassName) == false {
      return void;
    }
    Integer totalSize = imageWidth * imageHeight;
    Integer totalByteSize = imageWidth * imageHeight * 4;
    ImageLoader += class imageLoaderClassName / Thread / {
      String fileName = null;
      ~ByteBuffer pixelBuffer = null;
      ~ByteBuffer flippedPixelBuffer = null;
      ~Boolean failed = false;
      void run(){
        BufferedImage bufferedImage = null;
    	try { bufferedImage = ImageIO.read(new File(fileName));	}
    	print catch * { failed = true;  return void;	}
        int[] pixels = new int['totalSize'];
        PixelGrabber pixelGrabber = new PixelGrabber(bufferedImage, 0, 0, 'imageWidth', 'imageHeight', pixels, 0, 'imageWidth');
        try { pixelGrabber.grabPixels(); }
        catch * { \System.err.println(''"Pixel Grabbing interrupted!"''); failed = true; return void; }
        
        byte[] bytes = new byte['totalByteSize'];
        byte[] flippedBytes = new byte['totalByteSize'];
        int p = 0;
        int r = 0;
        int g = 0;
        int b = 0;
        int a = 0;
        int i = 0;
        int j = 0;
        int k = 0;
        for int y < 'imageHeight' {
          for int x < 'imageWidth' {
            i = ('imageWidth' * y) \+ x;
            j = i * 4;
            k = 4*('imageWidth'*(y\+1)-x-1) ;
            p = pixels[i]; 
            a = (p >> 24) & 0xFF; r = (p >> 16) & 0xFF;  g = (p >> 8) & 0xFF; b = (p >> 0) & 0xFF;
            bytes[j\+0] = (byte)r;  bytes[j\+1] = (byte)g;  bytes[j\+2] = (byte)b; bytes[j\+3] = (byte)a;
            flippedBytes[k\+0] = (byte)r;  
            flippedBytes[k\+1] = (byte)g; 
            flippedBytes[k\+2] = (byte)b; 
            flippedBytes[k\+3] = (byte)a;
          }
        }
        pixelBuffer = ByteBuffer.allocateDirect('totalByteSize').order(ByteOrder.nativeOrder());
        pixelBuffer.put(bytes).flip();
        flippedPixelBuffer = ByteBuffer.allocateDirect('totalByteSize').order(ByteOrder.nativeOrder());
        flippedPixelBuffer.put(flippedBytes).flip();
      }
      void attachTextures(Gui->Image imageObject, Gui->Image flippedImageObject){
        try {
          \super.join();
        }
        print catch Interrupted {}
        if failed == true {
    	  imageObject.setTexture(0);
          return void;
		}
    	
    	imageObject.setTexture(\getTextureFromPixelBuffer(pixelBuffer));
    	if flippedImageObject != null {
    	  flippedImageObject.setTexture(\getTextureFromPixelBuffer(flippedPixelBuffer));  
    	}
      }
      @int getTextureFromPixelBuffer(ByteBuffer pixels){
        
        \int texture = 0;
        IntBuffer textureHandle = ByteBuffer.allocateDirect('INT_SIZE').order(ByteOrder.nativeOrder()).asIntBuffer();
        GL11.glGenTextures(textureHandle);
        texture = textureHandle.get(0);
        GL11.glPushAttrib(GL11.GL_TEXTURE_BIT);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
        GL11.glTexImage2D(GL11.GL_TEXTURE_2D,
          0, 						
          GL11.GL_RGBA8,			
          'imageWidth', 'imageHeight', 					
          0,						
          GL11.GL_RGBA, 			
          GL11.GL_UNSIGNED_BYTE,	
          pixels);
        GL11.glPopAttrib();
		GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
    	Integer result = GLU.gluBuild2DMipmaps(GL11.GL_TEXTURE_2D, GL11.GL_RGBA8,
    		'imageWidth', 'imageHeight',
    		GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, pixels);
    	if result != 0 {
    	  \System.err.println(''"GLApp.makeTextureMipMap(): Error occured while building mip map, result="'' \+ result \+ ''" error="'' \+ GLU.gluErrorString(result) );
    	}
    	GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
    	GL11.glTexEnvf(GL11.GL_TEXTURE_ENV, GL11.GL_TEXTURE_ENV_MODE, GL11.GL_MODULATE);
    	return texture;
      }
    }
  }
}

> String floatBufferArray = "FloatBuffer[][]";
class 'packageName'.gui Gui {
  FloatBuffer placeHolder = null;
  @Boolean isRunning = true;
  ImageLoader imageLoader = null;
  InputHandler inputHandler = null;
  @Game game = null;
  @Renderer renderer = null;
  void load(){
    \initializeDisplay();
    renderer = new Renderer();
    renderer.load(\displayMode);
    inputHandler = new InputHandler();
    inputHandler.load(\displayMode);
    imageLoader = new ImageLoader();
    imageLoader.load();
    game = new Game();
    game.load();
  }
  interface Renderable // {
    Integer getTexture(){}
    void render(){}
    void animate(){}
  }
  interface Statable // {
    Gui->Image->States asStates(){}
    Gui->Drawable asStates(Gui->Drawable drawable){}
  }

  class Image // Renderable {
    String imageFileName = null;
    Gui->Image->Dimensions pixels = null;
    Gui->Image->Dimensions frames = null;
    ~Integer texture = -1;
    ~FloatBuffer[][] textureBuffer = null;
    Integer getImageTexture(){
      return texture;
    }
    void animate(){}
    void render(){
      GL11.glTexCoordPointer(2, 0, textureBuffer[0][0]);
    }
    class Dimensions // {
      Integer width = -1;
      Integer height = -1;
    }
    Gui->Image->Crop getCrop(Integer frameX, Integer frameY){
      return new Gui->Image->Crop(frameX, frameY);
    }
    ~class Crop // Renderable {
      Integer frameX = 0;
      Integer frameY = 0;
      void animate(){}
      void render(){
        GL11.glTexCoordPointer(2, 0, textureBuffer[frameX][frameY]);
      }
      void setFrameX(Integer newX){ frameX = newX; }
      void setFrameY(Integer newY){ frameY = newY; }
      Integer getTexture(){
        return \getImageTexture();
      }
    }
    class States // Renderable Statable {
      ~Gui->Renderable current = null;
      ~ImageStates \id = ImageStates.DEFAULT;
      ~ImageStates state = ImageStates.DEFAULT;
      void animate(){
        current.animate();
      }      
      void render(){
        current.render();
      }
      Integer getTexture(){
        return current.getTexture();
      }
      void changeState(ImageStates newState){
      }
      Gui->Image->States asStates(){
        return this;
      }
      Gui->Drawable asStates(Gui->Drawable drawable){
        return drawable.image(this);
      }
    }
    ~class AnimationType / / Renderable {
      Integer x = 0;
      Integer y = 0;
      void animate(){ }      
      void render(){
        GL11.glTexCoordPointer(2, 0, textureBuffer[x][y]);
      }
      void animationRender(){
        GL11.glTexCoordPointer(2, 0, textureBuffer[x][y]);
      }
      Integer getTexture(){
        return \getImageTexture();
      }
      void setFrameX(Integer newX){ x = newX; }
      void setFrameY(Integer newY){ y = newY; }
      void tick(Double millisSinceLastFrame){
        \animate();
        \setFrameX(x);
        \setFrameY(y);
      }
    }
>@  Map<String, Set<String>> multiElementImages = new HashMap<String, Set<String>>();
>    Map<String,Integer> imageWidths = new HashMap<String,Integer>();
>    Map<String,Integer> imageHeights = new HashMap<String,Integer>();
>   Map<String,Set<String>> declaredTextureBuffers = new HashMap<String,Set<String>>();
>   Map<String,Set<String>> animationStateFirstSet = new HashMap<String,Set<String>>();
>   Set<String> animationStatesByImage = new HashSet<String>();
>   Set<String> animationStates = new HashSet<String>();
>   Map<String, Body > animationStateAscendBodies = new HashMap<String, Body >();
>   Map<String, Body > animationStateChangeSwitches = new HashMap<String, Body >();
>   Map<String,Map<String, Body >> animationStateChangeBodies = new HashMap<String,Map<String, Body >>();
>   Map<String,Map<String, Statement >> animationStateChangeCases = new HashMap<String,Map<String, Statement >>();
>   Map<String, Map<String, Set<String>>> allStatesWithinState = new HashMap<String, Map<String, Set<String>>>();
>   Map<String, Map<String, Set<String>>> allIdsWithinState = new HashMap<String, Map<String, Set<String>>>();
>   Map<String,Map<String, Statement >> firstOrDefaultFlipMethods = new HashMap<String,Map<String, Statement >>();
>   Map<String,Map<String, Statement >> firstOrDefaultStateVariables = new HashMap<String,Map<String, Statement >>();
>   void declaration(%T input){
      try {
        String imageName = 'input->"imageName"';
        String imageClassName = ^input->"imageName";
        String imageFileName = "../Resource/gui/images/"\+'input->"imageFile"'\+'input->"image_type"';
        BufferedImage bimg = ImageIO.read(new File(imageFileName));
        Integer pWidth = bimg.getWidth();
        Integer pHeight = bimg.getHeight();
        imageWidths.put(imageClassName,Integer.parseInt('input->"frameWidth"'));
        imageHeights.put(imageClassName,Integer.parseInt('input->"frameHeight"'));
        Images += @Images->'imageClassName' 'imageName' = new Images->'imageClassName'();
        Images->Flipped += @Images->'imageClassName' 'imageName' = new Images->'imageClassName'();
        Images += class imageClassName / Gui->Image / Gui->Statable {
        }
        Images->'imageClassName'->*.appendToBody({
          imageFileName = '' 'imageFileName' '';
          pixels = new Gui->Image->Dimensions('pWidth','pHeight');
          frames = new Gui->Image->Dimensions('input->"frameWidth"','input->"frameHeight"');
        });
        if declaredTextureBuffers.containsKey('input->"frameWidth"')==false || declaredTextureBuffers.get('input->"frameWidth"').contains('input->"frameHeight"')==false {
          \declareTextureBuffer('input->"frameWidth"','input->"frameHeight"');
        }
        String textureBufferMethodLoaderClassName = "TextureBuffer"\+'input->"frameWidth"'\+"x"\+'input->"frameHeight"'\+"Loader";
        ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
          Images->'imageName'.setTextureBuffer(textureBuffer);
          Images->Flipped->'imageName'.setTextureBuffer(textureBuffer);
        });
        String imageLoaderClassName = "ImageData"\+'pWidth'\+"x"\+'pHeight'\+"Loader";
        ImageLoader.declareImageLoader(imageName,imageFileName,pWidth,pHeight);
        Images->'imageClassName' += class States / Gui->Image->States / {
          void changeState(ImageStates newState){
          }
        }
        Images->'imageClassName' += Images->'imageClassName'->States asStates() { return new Images->'imageClassName'->States(); }
        Images->'imageClassName' += Gui->Drawable asStates(Gui->Drawable drawable) { return drawable.image(new Images->'imageClassName'->States()); }
        Images->'imageClassName'->States += Images->'imageClassName'->States asStates() {
          Images->'imageClassName'->States result = new Images->'imageClassName'->States();
          result.setCurrent(\current);
          result.setState(\state);
          return result;
        }
        Images->'imageClassName'->States += Gui->Drawable asStates(Gui->Drawable drawable) {
          Images->'imageClassName'->States result = new Images->'imageClassName'->States();
          result.setCurrent(\current);
          result.setState(\state);
          return drawable.image(result);
        }
        
        Images->'imageClassName' += Gui->Drawable asDrawable(Gui->Drawable drawable) { return drawable.image(this); }
        ~Boolean isFirst = true;
        
        if input->"animation_state" == null {
          Images->'imageClassName'->States += Gui->Renderable "defaultState" = \Images.'imageName';
          Images->'imageClassName'->States->*.appendToBody({\setCurrent("defaultState");});
        }
        animationStateFirstSet.put(imageClassName,new HashSet<String>());
        animationStateChangeBodies.put(imageClassName, new HashMap<String, Body >());
        animationStateChangeCases.put(imageClassName, new HashMap<String, Statement >());
        allStatesWithinState.put(imageClassName, new HashMap<String, Set<String>>());
        allIdsWithinState.put(imageClassName, new HashMap<String, Set<String>>());
        firstOrDefaultFlipMethods.put(imageClassName, new HashMap<String, Statement >());
        firstOrDefaultStateVariables.put(imageClassName, new HashMap<String, Statement >());
        firstOrDefaultFlipMethods.get(imageClassName).put("", new Statement ());
        firstOrDefaultStateVariables.get(imageClassName).put("", new Statement ());
        Body stateAscendBody = new Body ();
        animationStateAscendBodies.put(imageClassName,stateAscendBody);
        Body stateSwitchBody = new Body ();
        animationStateChangeSwitches.put(imageClassName,stateSwitchBody);
        Body defaultStateBody = new Body ();
        animationStateChangeBodies.get(imageClassName).put("",defaultStateBody);
        Images->'imageClassName'->States->*"changeState".appendToBody({
          if "newState" == ImageStates."ASCEND" {
            switch "state" `stateAscendBody`
            return void;
          }
          switch "state" `stateSwitchBody`
          });
        animationStateChangeSwitches.get(imageClassName).add(|
              case "DEFAULT" {
                switch "newState" `defaultStateBody`
                return void;
              }|);
        allStatesWithinState.get(imageClassName).put("",new HashSet<String>());
        allIdsWithinState.get(imageClassName).put("",new HashSet<String>());
        input : atom : animation_state {
          \getAnimationStateDeclaration(atom,imageName,imageClassName,"");
        }
        \addAllStateChangesToState(imageClassName,"", new HashSet<String>());
      }
      print catch  IO {}
    }
>   void \addAllStateChangesToState(String imageClassName,String currentStateName, Set<String> allStateList){
      for String childStateName : allStatesWithinState.get(imageClassName).get(currentStateName) {
        allStateList.add(childStateName);
      }
      for String childStateName : allStatesWithinState.get(imageClassName).get(currentStateName) {
        Set<String> childStateList = new HashSet<String>();
        childStateList.addAll(allStateList);
        if allStatesWithinState.get(imageClassName).containsKey(childStateName) {
          \addAllStateChangesToState(imageClassName,childStateName,childStateList);
        }
        else {
          Body currentSwitchBody = new Body ();
          animationStateChangeBodies.get(imageClassName).put(childStateName,currentSwitchBody);
          animationStateChangeSwitches.get(imageClassName).add(|
              case 'childStateName' {
                switch "newState" `currentSwitchBody`
                return void;
              }
            |);
          for String allChildStateName : allStateList {
            if allChildStateName.equals(childStateName) == false {
              animationStateChangeBodies.get(imageClassName).get(childStateName).add(
                animationStateChangeCases.get(imageClassName).get(allChildStateName));
            }
          }
        }
      }
      for String childStateName : allStateList {
        animationStateChangeBodies.get(imageClassName).get(currentStateName).add(
          animationStateChangeCases.get(imageClassName).get(childStateName));
      }
    }
>   void getAnimationStateDeclaration(%T declaration, String imageName, String imageClassName, String parentStateName){
      declaration : atom
        : parentState {
          String currentStateName;
          if parentStateName.equals(""){
            currentStateName = 'atom->"animationId"';
          }
          else {
            currentStateName = parentStateName\+"_"\+'atom->"animationId"';
          }
          allStatesWithinState.get(imageClassName).get(parentStateName).add(currentStateName);
          allIdsWithinState.get(imageClassName).get(parentStateName).add('atom->"animationId"');
          allStatesWithinState.get(imageClassName).put(currentStateName,new HashSet<String>());
          allIdsWithinState.get(imageClassName).put(currentStateName,new HashSet<String>());
          Body currentSwitchBody = new Body ();
          animationStateChangeBodies.get(imageClassName).put(currentStateName,currentSwitchBody);
          animationStateChangeSwitches.get(imageClassName).add(|
              case 'currentStateName' {
                switch "newState" `currentSwitchBody`
                return void;
              }
            |);
          Statement firstOrDefaultVariable = new Statement ();
          firstOrDefaultStateVariables.get(imageClassName).put(currentStateName,firstOrDefaultVariable);
          Statement firstOrDefaultMethod = new Statement ();
          firstOrDefaultFlipMethods.get(imageClassName).put(currentStateName,firstOrDefaultMethod);
          if parentStateName.equals("") {
            \declareFlipMethod(animationStatesByImage.add(imageClassName), imageClassName, 'atom->"animationId"', currentStateName, currentStateName, firstOrDefaultStateVariables.get(imageClassName).get(currentStateName));
          }
          else {
            \declareFlipMethod(animationStatesByImage.add(imageClassName), imageClassName, 'atom->"animationId"', currentStateName, parentStateName, firstOrDefaultStateVariables.get(imageClassName).get(currentStateName));
          }
          
          atom : quark : animation_state {
            \getAnimationStateDeclaration(quark,imageName,imageClassName,currentStateName);
          }
          if animationStates.add(currentStateName) {
            ImageStates += void 'currentStateName';
            Gui->Image->States += 'finalImageStatesClassName' 'currentStateName'(){
              \changeState(ImageStates->'currentStateName');
              return this;
            }
          }
          if animationStates.add('atom->"animationId"') {
            String animationIdName = 'atom->"animationId"'; 
            ImageStates += void 'animationIdName';
            Gui->Image->States += 'finalImageStatesClassName' 'atom->"animationId"'(){
              \changeState(ImageStates.'animationIdName');
              return this;
            }
          }
        }
        : finalState {
          ~Boolean isFirst = animationStatesByImage.add(imageClassName);
          String creationMethod = "create"\+'atom->"animationTypeName"';
          ~String currentStateName;
          if parentStateName.equals("") {
            currentStateName = 'atom->"animationId"';
          }
          else {
            currentStateName = parentStateName \+ "_"\+'atom->"animationId"';
          }
          \declareFinalAnimationState(atom, isFirst, imageClassName, imageName, parentStateName, currentStateName, 'atom->"animationId"', creationMethod, false);
          if atom->"flipAnimationId" != null {
            if parentStateName.equals("") {
              currentStateName = 'atom->"flipAnimationId"';
            }
            else {
              currentStateName = parentStateName \+ "_"\+'atom->"flipAnimationId"';
            }
            \declareFinalAnimationState(atom, false, imageClassName, imageName, parentStateName, currentStateName, 'atom->"flipAnimationId"', creationMethod, true);
          }
        }
    }
>   void declareFinalAnimationState(%T atom, boolean isFirstValue, String imageClassName, String imageName, String parentStateName, String currentStateName, String currentAnimationId, String creationMethod, boolean isFlipped){
      FlipMethodReturn flipMethodParameters = \getFlipMethodParameters(atom,isFlipped,imageClassName);
      List< Parameters > arguments = flipMethodParameters.getArguments();
      Integer yLayerSize = flipMethodParameters.getYLayerSize();
      ~boolean isFirst = isFirstValue;
      if arguments.size() == 1{
        if animationStates.add(currentAnimationId) {
          ImageStates += void 'currentAnimationId';
          Gui->Image->States += 'finalImageStatesClassName' 'currentAnimationId'(){
              \changeState(ImageStates->'currentAnimationId');
              return this;
            }
        }
        if animationStates.add(currentStateName) {
          ImageStates += void 'currentStateName';
          Gui->Image->States += 'finalImageStatesClassName' 'currentStateName'(){
              \changeState(ImageStates->'currentStateName');
              return this;
            }
        }
        allStatesWithinState.get(imageClassName).get(parentStateName).add(currentStateName);
        allIdsWithinState.get(imageClassName).get(parentStateName).add(currentAnimationId);
      }
      else if arguments.size() > 1{
        for Integer i < arguments.size() {
          String realCurrentId = 'currentAnimationId'\+"_"\+i;
          String realCurrentState = 'currentAnimationId'\+"_"\+i;
          if animationStates.add(realCurrentId) {
            ImageStates += void 'realCurrentId';
            Gui->Image->States += 'finalImageStatesClassName' 'realCurrentId'(){
                \changeState(ImageStates->'realCurrentId');
                return this;
              }
          }
          if animationStates.add(realCurrentState) {
            ImageStates += void 'realCurrentState';
            Gui->Image->States += 'finalImageStatesClassName' 'realCurrentState'(){
                \changeState(ImageStates->'realCurrentState');
                return this;
              }
          }
          allStatesWithinState.get(imageClassName).get(parentStateName).add(currentStateName\+"_"\+i);
          allIdsWithinState.get(imageClassName).get(parentStateName).add(currentAnimationId\+"_"\+i);
        }
        
      }
      if arguments.size() == 1{
        if isFlipped {
          Images->'imageClassName'->States += Gui->Renderable 'currentStateName'+"State" = Images->Flipped->'imageName'->'creationMethod'(`arguments.get(0)`);
        }
        else {
          Images->'imageClassName'->States += Gui->Renderable 'currentStateName'+"State" = \Images.'imageName'.'creationMethod'(`arguments.get(0)`);
        }
        if animationStateFirstSet.get(imageClassName).add(parentStateName) {
          firstOrDefaultFlipMethods.get(imageClassName).get(parentStateName).add(|"change_to_"+'currentStateName'();|);
          firstOrDefaultStateVariables.get(imageClassName).get(parentStateName).add(|'currentStateName'+"State"|);
        }
        \declareFlipMethod(isFirst, imageClassName, 'currentAnimationId', currentStateName, parentStateName, |'currentStateName'+"State"|);
      }
      else if arguments.size() > 1{
        ~Integer realIndex = 0;
        for Parameters args: arguments {
          Integer indexValue = realIndex;
          if animationStateFirstSet.get(imageClassName).add(parentStateName) {
            firstOrDefaultFlipMethods.get(imageClassName).get(parentStateName).add(|"change_to_"+'currentStateName'+"_"+'realIndex'();|);
            firstOrDefaultStateVariables.get(imageClassName).get(parentStateName).add(|'currentStateName'+"State_"\+'indexValue'|);
          }
          if isFlipped {
            Images->'imageClassName'->States += Gui->Renderable 'currentStateName'+"State_"+'indexValue' = Images->Flipped->'imageName'->'creationMethod'(`args`);
          }
          else {
            Images->'imageClassName'->States += Gui->Renderable 'currentStateName'+"State_"+'indexValue' = \Images.'imageName'.'creationMethod'(`args`);
          }
          
          flipMethodParameters.getYLayers().get(realIndex / flipMethodParameters.getYLayerSize()).add(|'currentStateName'+"State_"+'indexValue'|); 
          \declareFlipMethod(isFirst, imageClassName, 'currentAnimationId'\+"_"\+realIndex, currentStateName\+"_"\+realIndex, parentStateName, |'currentStateName'+"State_"+'indexValue'|);
          realIndex \+= 1;
          isFirst = false;
        }
        int xLayerSize = arguments.size()/yLayerSize;
        Parameters stateRenderablesAsImageArray = new Parameters ();
        ~Parameters currentLayer = new Parameters ();
        for Integer indexValue < arguments.size() {
          currentLayer.add(|"drawable".image("states".'currentStateName'+"State_"+'indexValue')|);
          if indexValue%xLayerSize == xLayerSize-1 {
            Parameters currentLayerValue = currentLayer;
            stateRenderablesAsImageArray.add(|new Gui->Drawable(`currentLayerValue`)[]|);
            currentLayer = new Parameters ();
          }
        }
        Images->'imageClassName' += Gui->Drawable "getAs"+'^currentStateName'(Gui->Drawable drawable){
            Images->'imageClassName'->States states = new Images->'imageClassName'->States();
            return new Gui->Drawable->Multi->Image(new Gui->Drawable(`stateRenderablesAsImageArray`)[][]);
          }
        if multiElementImages.containsKey(imageClassName) == false {
          multiElementImages.put(imageClassName, new HashSet<String>());
        }
        multiElementImages.get(imageClassName).add(currentStateName);
      }
    }
>   FlipMethodReturn getFlipMethodParameters(%T atom, boolean isFlipped, String imageClassName){
      FlipMethodReturn result = new FlipMethodReturn();
      result.getArguments().add( new Parameters () );
      Parameters multipleArguments = new Parameters ();
      Parameters xArgumentLayer = new Parameters();
      atom : element : animation_variable_value {
        \getFlipMethodParameter(element,isFlipped,imageClassName,result,multipleArguments,xArgumentLayer);
      }
      multipleArguments.add(|"new Gui.Renderable[][]{"+`xArgumentLayer`+"}"|);
      return result;
    }
>   void getFlipMethodParameter(%T element, Boolean isFlipped, String imageClassName, FlipMethodReturn result, Parameters multipleArguments, Parameters xArgumentLayer){
      element : value : range {
        List< Parameters > oldArguments = result.getArguments();
        result.setArguments(new ArrayList<Parameters >());
        Integer lowerBound = Integer.parseInt('value->"lowerBound"');
        Integer upperBound = Integer.parseInt('value->"upperBound"');
        for Parameters args: oldArguments {
          if result.getIndex() == 1 {
            result.setYLayerSize(upperBound\-lowerBound \+ 1);
          }
          for Integer i <= upperBound\-lowerBound {
            Parameters newArg = new Parameters ();
            newArg.addAll(args);
            Integer index = i+lowerBound;
            newArg.add(|'index'|);
            result.getArguments().add(newArg);
            if result.getIndex() == 0 {
              Parameters yArgumentLayer = new Parameters ();
              result.getYLayers().add(yArgumentLayer);
              xArgumentLayer.add(|"new Gui.Renderable[]{"+`yArgumentLayer`+"}"|);
            }
          }
        }
        result.incrementIndex();
      }
      : unflippedValue {
        if isFlipped == false {
          \getFlipMethodParameter(value,isFlipped,imageClassName,result,multipleArguments,xArgumentLayer);
          result.incrementIndex();
        }
      }
      : flippedValue {
        if isFlipped == true {
          \getFlipMethodParameter(value,isFlipped,imageClassName,result,multipleArguments,xArgumentLayer);
          result.incrementIndex();
        }
      }
      : animation_type_coordinate_variable {
        if value->"highX" != null {
          if isFlipped {
            Integer lowX  = imageWidths.get(imageClassName)\-1\-Integer.parseInt('value->"highX"');
            Integer highX = imageWidths.get(imageClassName)\-1\-Integer.parseInt('value->"lowX"');
            for Parameters args: result.getArguments() {
              args.add(|'lowX'|);
              args.add(|'value->"highY"'|);
              args.add(|'highX'|);
              args.add(|'value->"lowY"'|);
            }
          }
          else {
            for Parameters args: result.getArguments() {
              args.add(|'value->"lowX"'|);
              args.add(|'value->"lowY"'|);
              args.add(|'value->"highX"'|);
              args.add(|'value->"highY"'|);
            }
          }
        }
        else {
        
          if isFlipped {
            Integer lowX  = imageWidths.get(imageClassName)\-1\-Integer.parseInt('value->"lowX"');
            for Parameters args: result.getArguments() {
              args.add(|'lowX'|);
              args.add(|'value->"lowY"'|);
            }
          }
          else {
            for Parameters args: result.getArguments() {
              args.add(|'value->"lowX"'|);
              args.add(|'value->"lowY"'|);
            }
          }
        }
        if result.getIndex() == 0 {
          Parameters yArgumentLayer = new Parameters ();
          result.getYLayers().add(yArgumentLayer);
          xArgumentLayer.add(|"new Gui.Renderable[]{"+`yArgumentLayer`+"}"|);
          result.setYLayerSize(1) ;
        }
        else if result.getIndex() == 1 {
          result.setYLayerSize(1) ;
        }
        result.incrementIndex();
        result.incrementIndex();
        if value->"highX" != null {
          result.incrementIndex();
          result.incrementIndex();
        }
      }
      : INTEGER {
        for Parameters args: result.getArguments() {
          args.add(|'value'|);
        }
        if result.getIndex() == 0 {
          Parameters yArgumentLayer = new Parameters ();
          result.getYLayers().add(yArgumentLayer);
          xArgumentLayer.add(|"new Gui.Renderable[]{"+`yArgumentLayer`+"}"|);
        }
        else if result.getIndex() == 1 {
          result.setYLayerSize(1) ;
        }
        result.incrementIndex();
      }
      : FLOAT {
        for Parameters args: result.getArguments() {
          args.add(|'value'|);
        }
        result.incrementIndex();
      }
      : quote {
        for Parameters args: result.getArguments() {
          args.add(|'' 'value' ''|);
        }
        result.incrementIndex();
      }
    }
>   void declareFlipMethod(Boolean isFirst, String imageClassName, String singleStateName, String currentStateName, String parentStateName, Statement currentStateVariable){
      Statement firstOrDefaultMethod =   firstOrDefaultFlipMethods.get(imageClassName).get(currentStateName);
      if parentStateName.equals("") {
        Images->'imageClassName'->States += void "change_to_"+'currentStateName'(){
          \setCurrent(`currentStateVariable`);
          "id" = ImageStates->'singleStateName';
          "state" = ImageStates->'currentStateName';
        }
        animationStateAscendBodies.get(imageClassName).add(|
          case 'currentStateName' {
            `firstOrDefaultMethod`;
            return void;}|);
      }
      else {
        Images->'imageClassName'->States += void "change_to_"+'currentStateName'(){
            \setCurrent(`currentStateVariable`);
            "id" = ImageStates->'singleStateName';
            "state" = ImageStates->'currentStateName';
          }
        animationStateAscendBodies.get(imageClassName).add(|
          case 'currentStateName' {
            "change_to_"+'parentStateName'();
            return void;}|);
      }
      if isFirst {
        Images->'imageClassName'->States->*.appendToBody({"change_to_"+'currentStateName'();}); 
      }
      if currentStateName.equals(singleStateName) {
        animationStateChangeCases.get(imageClassName).put(currentStateName, |
          case 'singleStateName' {
            "change_to_"+'currentStateName'();
            return void;}|);
      }
      else {
        animationStateChangeCases.get(imageClassName).put(currentStateName, |
          case 'currentStateName' {
            "change_to_"+'currentStateName'();
            return void;
          }
          case 'singleStateName' {
            "change_to_"+'currentStateName'();
            return void;}|);
      }
    }
>   void declareTextureBuffer(String frameWidth, String frameHeight){
      Float width = Float.parseFloat(frameWidth);
      Float height = Float.parseFloat(frameHeight);
      Integer widthI = Integer.parseInt(frameWidth);
      Integer heightI = Integer.parseInt(frameHeight);
	  Float xFactor = 0.00f/width;
	  Float yFactor = 0.00f/height;
      String textureBufferMethodLoaderClassName = "TextureBuffer"\+'frameWidth'\+"x"\+'frameHeight'\+"Loader";
      String textureBufferMethodLoaderName = "loadTextureBuffer"\+'frameWidth'\+"x"\+'frameHeight'+"Loader";
      String textureBufferName = "textureBuffer"\+'frameWidth'\+"x"\+'frameHeight';
	  if declaredTextureBuffers.isEmpty() {
	    ImageLoader += Map<Integer,Map<Integer,'floatBufferArray'>> textureBuffers = new HashMap<Integer,Map<Integer,'floatBufferArray'>>();
      }
      ImageLoader->*"load".prependToBody({
	    'textureBufferMethodLoaderName'.start();
      });
      ImageLoader->*"load".appendToBody({
        try {
	      'textureBufferMethodLoaderName'.join();
	    }
	    print catch Interrupted {} 
      });
      ImageLoader += Thread 'textureBufferMethodLoaderName' = new ImageLoader->'textureBufferMethodLoaderClassName'();
      ImageLoader += ~class textureBufferMethodLoaderClassName / Thread / {
        void run(){
	      FloatBuffer[][] textureBuffer = "new FloatBuffer["+'frameWidth'+"]["+'frameHeight'+"]";
	      ByteBuffer "byteBuffer" = null;
        }
      }
      for Integer x < widthI {
	    for Integer y < heightI {
		  String currentTextureBuffer = "textureBuffer["\+'x'\+"]["\+'y'\+"]";
		  StringBuilder floatArrayValues = new StringBuilder();
		  floatArrayValues.append("new float[]{");
		  floatArrayValues.append(x\/width\+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+1\/height\-yFactor);
		  floatArrayValues.append("f,");
	      floatArrayValues.append(x\/width\+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+1\/width-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+1\/height\-yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+1\/width\-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+yFactor);
		  floatArrayValues.append("f}"); 
		  ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
		    "byteBuffer" = ByteBuffer.allocateDirect(2*4*4);
            "byteBuffer".order(ByteOrder.nativeOrder());
		    'currentTextureBuffer' = \byteBuffer.asFloatBuffer();
		    'currentTextureBuffer'.put('floatArrayValues');
            'currentTextureBuffer'.position(0);
          });
  	    }
      }
      if declaredTextureBuffers.containsKey(frameWidth)==false {
        declaredTextureBuffers.put(frameWidth, new HashSet<String>());
        #ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
          synchronized "textureBuffers" {
            "textureBuffers".put('widthI', new HashMap<Integer,'floatBufferArray'>);
          }
        });#
      }
      declaredTextureBuffers.get(frameWidth).add(frameHeight);
	  #ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
        synchronized "textureBuffers" {
	      "textureBuffers".get('widthI').put('heightI', "textureBuffer");
	    }
      });#
    }
  }
  class Colour // {
    Float getRedF(){ return null; }
    Float getGreenF(){ return null; }
    Float getBlueF(){ return null; }
    Integer getRedI(){ return null; }
    Integer getGreenI(){ return null; }
    Integer getBlueI(){ return null; }
    Float[] asFloatArray(){return null;}
    int[] asIntegerArray(){return null;}
    Integer getTexture(){
      return 0;
    }
    void render(){}
    void endRender(){}
>   void declaration(%T input){
      String colourName = ^input->"colourName";
      Colours += class colourName / Gui->Colour / {
      }
      input : element : asInt {
        Integer redInt = Integer.parseInt('element->"red"');
        Integer greenInt = Integer.parseInt('element->"green"');
        Integer blueInt = Integer.parseInt('element->"blue"');
        Float redFloat = Float.parseFloat('element->"red"')/256f;
        Float greenFloat = Float.parseFloat('element->"green"')/256f;
        Float blueFloat = Float.parseFloat('element->"blue"')/256f;
        
        Colours->'colourName' += Float[] asFloatArray(){return "new Float[]{"+'redFloat'+"f,"+'greenFloat'+"f,"+'blueFloat'+"f}";}
        Colours->'colourName' += Integer[] asIntArray() {return "new Integer[]{"+'redInt'+","+'greenInt'+","+'blueInt'+"}"; }
        
        Colours->'colourName' += Integer getRedI(){return 'redInt';}
        Colours->'colourName' += Integer getGreenI() {return 'greenInt';}
        Colours->'colourName' += Integer getBlueI(){return 'blueInt';}
        Colours->'colourName' += Float getRedF() {return 'redFloat'+"f";}
        Colours->'colourName' += Float getGreenF() {return 'greenFloat'+"f";}
        Colours->'colourName' += Float getBlueF(){return 'blueFloat'+"f";}
        Colours->'colourName' += void render(){
          GL11.glDisable(GL11.GL_TEXTURE_2D);
		  GL11.glDisable(GL11.GL_LIGHTING);
		  GL11.glColor3f('redFloat'+"f", 'greenFloat'+"f", 'blueFloat'+"f");
		  GL11.glBegin(GL11.GL_TRIANGLE_STRIPS);
		}
		Colours->'colourName' += void endRender(){
		  GL11.glEnd();
		  GL11.glEnable(GL11.GL_TEXTURE_2D);
		  GL11.glEnable(GL11.GL_LIGHTING);
		}
      }
      : asFloat {
        Float redFloat = Float.parseFloat('element->"red"');
        Float greenFloat = Float.parseFloat('element->"green"');
        Float blueFloat = Float.parseFloat('element->"blue"');
        
        Float redIntValue = redFloat*256f;
        Float greenIntValue = greenFloat*256f;
        Float blueIntValue = blueFloat*256f;
        Integer redInt = redIntValue.intValue();
        Integer greenInt = greenIntValue.intValue();
        Integer blueInt = blueIntValue.intValue();
        
        Colours->'colourName' += Float[] asFloatArray(){return "new Float[]{"+'redFloat'+"f,"+'greenFloat'+"f,"+'blueFloat'+"f}";}
        Colours->'colourName' += Integer[] asIntArray() {return "new Integer[]{"+'redInt'+","+'greenInt'+","+'blueInt'+"}"; }
        
        Colours->'colourName' += Integer getRedI(){return 'redInt';}
        Colours->'colourName' += Integer getGreenI() {return 'greenInt';}
        Colours->'colourName' += Integer getBlueI(){return 'blueInt';}
        Colours->'colourName' += Float getRedF() {return 'redFloat'+"f";}
        Colours->'colourName' += Float getGreenF() {return 'greenFloat'+"f";}
        Colours->'colourName' += Float getBlueF(){return 'blueFloat'+"f";}
      }
    }
  }
  class Drawable // {
    ~FloatBuffer vertexBuffer = null;
    ~List<Gui\>Drawable\>ChangeListener> changeListeners = null;
    ~Float visualX = 0f;
    ~Float visualY = 0f;
    ~Float visualWidth = 1f;
    ~Float visualHeight = 1f;
    ~Float visualRotationPointX = 0f;
    ~Float visualRotationPointY = 0f;
    ~Float visualAngle = 0f;
    ~Float angle = 0f;
    
    ~Renderer->Layer displayLayer = null;
    void display(){
      if displayLayer == null {
        displayLayer = Renderer.botLayer;
        displayLayer.add(this);
      }
    }
    void undisplay(){
      if displayLayer == null {
        Renderer.botLayer.remove(this);
      }
      else {
        displayLayer.remove(this);
        displayLayer = null;
      }
    }
    void display(Renderer->Layer layer){
      if displayLayer == null {
        displayLayer = layer;
        displayLayer.add(this);
      }
      else if displayLayer != layer {
        displayLayer.remove(this);
        displayLayer = layer;
        displayLayer.add(this);
      }
    }
    void undisplay(Renderer->Layer layer){
      if displayLayer != null {
        displayLayer.remove(this);
      }
      if layer != null {
        layer.remove(this);
      }
      displayLayer = null;
    }
    void render(){
      
		GL11.glPushMatrix();
		GL11.glTranslatef(visualX, visualY, 0.0f);
		if visualAngle != 0f{
			GL11.glTranslatef(visualRotationPointX, visualRotationPointY, 0.0f);
			GL11.glRotatef(visualAngle, 0, 0, 1);	
			GL11.glTranslatef(-1f*visualRotationPointX, -1f*visualRotationPointY, 0.0f);
		}
		GL11.glScalef(visualWidth, visualHeight, 1f);
		GL11.glVertexPointer(3, 0, vertexBuffer);
    }
    void animate(){
    }
    void load(){
    }
    Integer getTexture(){
      return 0;
    }
    Gui->Drawable image(Gui->Renderable image){
      return null;
    }
    Gui->Drawable colour(Gui->Colour colour){
      return null;
    }
    void add(Gui\>Drawable\>ChangeListener changeListener){
      if changeListeners == null {
        changeListeners = new ArrayList<Gui\>Drawable\>ChangeListener>();
      }
      changeListeners.add(changeListener);
    }
    class ChangeListener // {
      void setVisualX(Float newX){
      }
      void setVisualY(Float newY){
      }
      void setVisualWidth(Float newWidth){
      }
      void setVisualHeight(Float newHeight){
      }
      void setAngle(Float newAngle){
      }
    }
    class Multi // {
      class Image /Drawable/ {
        Gui->Drawable[][] images = null;
        void setVisualX(Float newVisualX){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualX(newVisualX\+j*visualWidth);
            }
          }
        }
        void setVisualY(Float newVisualY){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualY(newVisualY\+i*visualHeight);
            }
          }
        }
        void setVisualWidth(Float newVisualWidth){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualWidth(newVisualWidth);
            }
          }
        }
        void setVisualHeight(Float newVisualHeight){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualHeight(newVisualHeight);
            }
          }
        }
        void setVisualRotationPointX(Float newVisualRotationPointX){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualRotationPointX(newVisualRotationPointX);
            }
          }
        }
        void setVisualRotationPointY(Float newVisualRotationPointY){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualRotationPointY(newVisualRotationPointY);
            }
          }
        }
        void setVisualAngle(Float newVisualAngle){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualAngle(newVisualAngle);
            }
          }
        }
        void setAngle(Float newAngle){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setAngle(newAngle);
            }
          }
        }
        void display(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].display();
            }
          }
        }
        void undisplay(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].undisplay();
            }
          }
        }
        void display(Renderer->Layer layer){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].display(layer);
            }
          }
        }
        void undisplay(Renderer->Layer layer){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].undisplay(layer);
            }
          }
        }
        void render(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].render();
            }
          }
        }
        void animate(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].animate();
            }
          }
        }
        void load(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].load();
            }
          }
        }
        Integer getTexture(){
          return images[0][0].getTexture();
        }
      }
    }
>   void setup(){
      Gui->Drawable->*"setVisualX".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualX("newVisualX");
          }
        }
      });
      Gui->Drawable->*"setVisualY".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualY("newVisualY");
          }
        }
      });
      Gui->Drawable->*"setVisualWidth".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualWidth("newVisualWidth");
          }
        }
      });
      Gui->Drawable->*"setVisualHeight".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualHeight("newVisualHeight");
          }
        }
      });
      Gui->Drawable->*"setAngle".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setAngle("newAngle");
          }
        }
      });
      Gui->Drawable->*"setAngle".prependToBody({
        "visualAngle" = "(float)(newAngle" * 180.0 / "Math.PI)"; 
      });
    }
>   void declaration(%T input){
      String drawableName = 'input->"drawableName"';
      String drawableClassName = ^input->"drawableName";
      Drawables += class drawableClassName / Gui->Drawable / {
        void load(){
        }
        Drawables->'drawableClassName' image(Gui->Renderable image){
          Drawables->'drawableClassName' newImage = new Drawables->'drawableClassName'->Image(image);
          newImage.setVertexBuffer("vertexBuffer");
          return newImage;
        }
        Drawables->'drawableClassName' colour(Gui->Colour colour){
          Drawables->'drawableClassName' newColour = new Drawables->'drawableClassName'->Colour(colour);
          newColour.setVertexBuffer("vertexBuffer");
          return newColour;
        }
      }
      Drawables += @Drawables->'drawableClassName' 'drawableName' = new Drawables->'drawableClassName'();  
      ImageLoader->*"load".prependToBody({ \Drawables.'drawableName'.load(); });
      
      StringBuilder vertexArray = new StringBuilder();
      ~Float gridWidth = -1f;
      ~Float gridHeight = -1f;
      ~Boolean buildingWidth = true;
      input : element : drawable_grid_element {
        if element->"endLine" != null {
          gridHeight \+= 1f;
          buildingWidth = false;
        }
        else if buildingWidth {
          gridWidth \+= 1f;
        }
      }
      ~Float gridX = 0f;
      ~Float gridY = 0f;
      ~Float gridAHeight = gridHeight - 1;
      ~Integer numberOfElements = 0;
      Map<Integer,Float> gridXMap = new HashMap<Integer,Float>();
      Map<Integer,Float> gridYMap = new HashMap<Integer,Float>();
      input : element : drawable_grid_element {
        if element->"point" != null {
          element : atom : point {
            gridXMap.put(Integer.parseInt('atom'), gridX / gridWidth );
            gridYMap.put(Integer.parseInt('atom'), 1f \- gridY / gridAHeight );
          }
          numberOfElements \+= 1;
        }
        if element->"endLine" != null {
          gridY \+= 1f;
          gridX = 0f;
        }
        else {
          gridX \+= 1f;
        }
      }
      vertexArray.append("float[] vertices = new float[]{");
      ~String comma = "";
      for Integer i < numberOfElements {
        vertexArray.append(comma);
        vertexArray.append(gridXMap.get(i\+1));
        vertexArray.append("f,");
        vertexArray.append(gridYMap.get(i\+1));
        vertexArray.append("f,0f");
        comma = ",";
      }
      vertexArray.append("}");
      Integer sizeOfByteBuffer = numberOfElements * 4 * 3;
      Drawables->'drawableClassName'->*"load".appendToBody({
        'vertexArray';
		ByteBuffer byteBuffer = ByteBuffer.allocateDirect('sizeOfByteBuffer');
		byteBuffer.order(ByteOrder.nativeOrder());
		"vertexBuffer" = byteBuffer.asFloatBuffer();
		"vertexBuffer".clear();
		"vertexBuffer".put("vertices");
		"vertexBuffer".position(0);
      });
      Integer numberOfElementsValue = numberOfElements;
      Drawables->'drawableClassName' += class Image / 'drawableClassName' / {
        Gui->Renderable image = null;
        void render(){
          image.render();
          super.render();
          GL11.glDrawArrays(GL11.GL_TRIANGLE_STRIP, 0, 'numberOfElementsValue');
		  GL11.glPopMatrix();
        }
        void animate(){
          image.animate();
        }
        Integer getTexture(){
          return image.getTexture();
        }
      }
      Drawables->'drawableClassName' += class Colour / 'drawableClassName' / {
        Gui->Colour colour = null;
        void render(){
          colour.render();
        }
        Integer getTexture(){
          return colour.getTexture();
        }
      }
      Drawables->'drawableClassName'->Colour->*"render".appendToBody({
        colour.endRender();
      });
    }
>   void multipleDeclaration(%T input){
      String multipleName = 'input->"multipleName"';
      String multipleClassName = ^multipleName;
      Drawables += class multipleClassName / Gui->Drawable / {
        void load(){
        }
        void render(){
        }
        void animate(){
        }
        Drawables->'multipleClassName' image(Gui->Renderable image){
        }
      }
      Drawables += @Drawables->'multipleClassName' 'multipleName' = new Drawables->'multipleClassName'(); 
      Drawables->'multipleClassName' += class Image / 'multipleClassName' / {
        Integer imageTexture = -1;
        void render(){
        }
        void animate(){
        }
        Integer getTexture(){
          return imageTexture;
        }
      }
      ~Integer imageIndex = 1;
      Parameters imageParameters = new Parameters ();
      imageParameters.add(|"image".getTexture()|);
      input : element : drawable_multiple_element {
        String imageName = "image"\+imageIndex;
        String drawableName = 'element->"drawableName"';
        if element->"newStateName" != null {
          Drawables->'multipleClassName'->*"image".appendToBody({
            Gui->Image->States 'imageName' = "((Gui.Statable)image).asStates()";
          });
          element : atom : newStateName {
            Drawables->'multipleClassName'->*"image".appendToBody({
              'imageName'.changeState( "Gui.Image.States."+'atom' );
            });
          }
          imageParameters.add(|\Drawables.'drawableName'.image('imageName')|);
        }
        else {
          imageParameters.add(|\Drawables.'drawableName'.image("image")|);
        }
        String changeListenerClassName = ^imageName \+ "ChangeListener";
        Drawables->'multipleClassName'->Image += ~class changeListenerClassName / Gui->Drawable->ChangeListener / { 
          void setVisualX(Float newX){
          }
          void setVisualY(Float newY){
          }
          void setVisualWidth(Float newWidth){
          }
          void setVisualHeight(Float newHeight){
          }
          void setAngle(Float newAngle){
          }
        }
        \addChangeListener(element->"angle",Drawables->'multipleClassName'->Image,imageName,\NORMAL, "setAngle");
        \addChangeListener(element->"position",Drawables->'multipleClassName'->Image,imageName,"setVisualX","setVisualY");
        \addChangeListener(element->"dimensions",Drawables->'multipleClassName'->Image,imageName,"setVisualWidth","setVisualHeight");
        if element->"rotation" != null {
          \addChangeListener(element->"rotation",Drawables->'multipleClassName'->Image,imageName,"setVisualRotationPointX","setVisualRotationPointY");
        }
        
        Drawables->'multipleClassName'->Image += Gui->Drawable 'imageName' = null;
        Drawables->'multipleClassName'->Image->*"render".appendToBody({'imageName'.render();});
        Drawables->'multipleClassName'->Image->*"animate".appendToBody({'imageName'.animate();});
        
        Drawables->'multipleClassName'->Image->*.appendToBody({\add(new Drawables->'multipleClassName'->Image->'changeListenerClassName'());});
        imageIndex \+= 1;
      }
      Drawables->'multipleClassName'->Image->*.appendToBody({
        if changeListeners != null {
        for Gui->Drawable->ChangeListener changeListener : changeListeners {
		  "changeListener".setVisualX(0f);
		  "changeListener".setVisualY(0f);
		  "changeListener".setVisualWidth(1f);
		  "changeListener".setVisualHeight(1f);
		  "changeListener".setAngle(0f);
		}
		}
      });
      Drawables->'multipleClassName'->*"image".appendToBody({
        return new Drawables->'multipleClassName'->Image(`imageParameters`);
      });
    }
>   Integer LEFT_SUPPLEMENTARY = 1;
>   Integer RIGHT_SUPPLEMENTARY = 2;
>   Integer NORMAL = 3;
>   Statement getMultipleValue(%T input, Integer status){
      ~Statement result = null;
      if input->"angle" != null {
        if status == LEFT_SUPPLEMENTARY {
          return |\Math.cos(\getAngle())|;
        }
        else if status == RIGHT_SUPPLEMENTARY {
          return |\Math.sin(\getAngle())|;
        }
        else if status == NORMAL {
          return |\getAngle()|;
        }
      }
      else if input->"x" != null {
        return |\getVisualX()|;
      }
      else if input->"y" != null {
        return |\getVisualY()|;
      }
      else if input->"width" != null {
        return |\getVisualWidth()|;
      }
      else if input->"height" != null {
        return |\getVisualHeight()|;
      }
      else if input->"FLOAT" != null {
        return |'input->"FLOAT"'+"f"|;
      }
      else if input->"INTEGER" != null {
        return |'input->"INTEGER"'|;
      }
      \System.err.println("Drawable.getMultipleValue() could not parse:");
      input.print();
      return null;
    }
        
>   void addChangeListener(%T input, Class masterClass, String drawableToChange, String leftParameterSetMethod, String rightParameterSetMethod){
      \addChangeListener(input->"leftParameter",masterClass,drawableToChange, LEFT_SUPPLEMENTARY, leftParameterSetMethod);
      \addChangeListener(input->"rightParameter",masterClass,drawableToChange, RIGHT_SUPPLEMENTARY, rightParameterSetMethod);
    }
>   void addChangeListener(%T input, Class masterClass, String drawableToChange, Integer status, String setMethod){
      String changeListenerClassName = ^drawableToChange \+ "ChangeListener";
      Statement statement = new Statement ();
      Set<String> toChangeMethods = new HashSet<String>();
      input : element : drawable_multiple_value {
        statement.add(\getMultipleValue(element,status));
        if element->"width" != null {
          toChangeMethods.add("setVisualWidth");
        }
        else if element->"height" != null {
          toChangeMethods.add("setVisualHeight");
        }
        else if element->"x" != null {
          toChangeMethods.add("setVisualX");
        }
        else if element->"y" != null {
          toChangeMethods.add("setVisualY");
        }
        else if element->"angle" != null {
          toChangeMethods.add("setAngle");
        }
      }
      : drawable_arthmetic_operator {
        statement.set('element');
      }
      input : element : supplementary {
        element : atom : drawable_multiple_value {
          statement.add(\getMultipleValue(atom,status));
          if atom->"width" != null {
            toChangeMethods.add("setVisualWidth");
          }
          else if atom->"height" != null {
            toChangeMethods.add("setVisualHeight");
          }
          else if atom->"x" != null {
            toChangeMethods.add("setVisualX");
          }
          else if atom->"y" != null {
            toChangeMethods.add("setVisualY");
          }
          else if atom->"angle" != null {
            toChangeMethods.add("setAngle");
          }
        }
        : drawable_arthmetic_operator {
          statement.set('atom');
        }
      }
      for String changeMethod : toChangeMethods {
        masterClass->'changeListenerClassName'->*'changeMethod'.appendToBody({
          'drawableToChange'.'setMethod'("(float)("+`statement`+")");
        });
      }
    }
  }
> void setup(){
    Gui->Drawable.setup();
  }
> void importAny(%T import_any){
	import_any : import_colours : import_colour {
      import_colours : element : colour_declaration {
		Gui->Colour.declaration(element);
	  }
	}
	import_any : import_animation_types : import_animation_type {
	  import_animation_types : element : animation_type_declaration {
		ImageLoader.declaration(element,Gui->Image->AnimationType);
	  }
	}
	import_any : import_images : import_image {
	  import_images : element : image_declaration {
		Gui->Image.declaration(element);
	  }
	}
	import_any : import_draws : import_drawable {
	  import_draws : element : drawable_declaration {
		Gui->Drawable.declaration(element);
	  }
	  import_draws : element : multiple_drawable_declaration {
		Gui->Drawable.multipleDeclaration(element);
	  }
	}
	import_any : import_layers : import_layer {
	  import_layers : element : layer_declaration {
		Renderer.addLayer('element->"layerName"');
	  }
	}
  }
}

> class 'packageName'.misc FlipMethodReturn {
  ~List< Parameters > arguments = new ArrayList< Parameters >();
  ~List< Parameters > yLayers = new ArrayList< Parameters >();
  ~Integer yLayerSize = 0;
  ~Integer index = 0;
  void incrementIndex(){
    index \+= 1;
  }
  void setArguments(List< Parameters > newArguments){
    arguments = newArguments;
  }
  void setYLayers(List< Parameters > newYLayers){
    yLayers = newYLayers;
  }
  void setYLayerSize(int newYLayerSize){
    yLayerSize = newYLayerSize;
  }
}
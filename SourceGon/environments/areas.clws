import area_regions.clws
class 'packageName'.environments Areas {
}
class 'packageName'.environments Area Environment->Position {
> Integer tickEventArrayLength = 256;
  class Id // {
  }
  Area->Id getId(){
    return null;
  }
  ~ArrayList<Tile> tiles = new ArrayList<Tile>();
  ~Map<Integer, Map<Integer, Tiles\>Floor>> layout = new HashMap<Integer, Map<Integer, Tiles\>Floor>>();
  ~ArrayList<Tiles\>EntryPoint> entryPoints = new ArrayList<Tiles\>EntryPoint>();
  ~Map<Tile\>Id, ArrayList<Tile>> tileMap = new HashMap<Tile\>Id, ArrayList<Tile>>();
  ~ArrayList<Tiles\>Floor> floorTiles = new ArrayList<Tiles\>Floor>();
  ~Map<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>> floorMap = new HashMap<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>>();
  ~Map<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>> terrainMap = new HashMap<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>>();
  
  ~Map<Integer, Map<Integer, ArrayList<Tiles\>Floor>>> entryToEntryPaths = new HashMap<Integer, Map<Integer, ArrayList<Tiles\>Floor>>>();
  ~Map<Area, Tiles\>EntryPoint> sisterAreas = new HashMap<Area, Tiles\>EntryPoint>();
  ~Map<Integer, Set<Area>> areaDistances = new HashMap<Integer, Set<Area>>();
  ~int furthestDistanceToArea = 0; 
  
  ~Entity->List entities = new Entity->List();
  ~Integer width = 0;
  ~Integer height = 0;
  ~Integer currentTickPosition = 0;
  
  ~Area->Event->\Tick->Listener[] tickEvents = new Area->Event->\Tick->Listener['tickEventArrayLength']; 
  
  class Event // {
    interface Tick // {
      void tick(Double millisSinceLastFrame){
      }
      class Listener / ArrayList<Area\>Event\>Tick> / {
        void tick(Double millisSinceLastFrame){
          for Area->Event->Tick ticker: \this {
            ticker.tick(millisSinceLastFrame);
          }
          \clear();
        }
      }
    }
  }
  class Generator // {
    Area generate(){
      return null;
    }
  }
  class Generators // {
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area1) - origin.getDistanceTo(area2))";
        }
      }
      class Descending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area2) - origin.getDistanceTo(area1))";
        }
      }
    }
  }
> void setup(%Pass data){
  }
> Double declaration(%T declarationToken, String mapName, List<String> floorTiles, Boolean isFirst, Double previousChance){
    String areaClassName = ^declarationToken->"areaName";
    String areaName = areaClassName.toLowerCase();
    Double chance = Double.parseDouble('declarationToken->"chance"')/100.0\+previousChance;
    Area->TerrainChoice->'mapName' += class areaClassName // {}
    Area->Generators->'mapName' += class areaClassName / Area->Generator / {
       Environment parent = null;
       Area generate(){
         Area newArea = new Area();
         parent.add(newArea);
       }
       Tiles->Floor generateFloor(Integer x, Integer y){
         Tiles->Floor result = null;
       }
       Tiles->EntryPoint generateEntryPoint(Integer x, Integer y){
         Tiles->EntryPoint result = null;
       }
     }
    Areas->'mapName'->Generator += ~Area->Generators->'mapName'->'areaClassName' 'areaName' = null;
    Areas->'mapName'->Generator->*.appendToBody(|'areaName' = new Area->Generators->'mapName'->'areaClassName'("parent");|);
    if isFirst {
      Areas->'mapName'->Generator->*"generate".appendToBody(|
        if "chance" <= 'chance' {
          return 'areaName'.generate();
        }|);
    }
    else {
      Areas->'mapName'->Generator->*"generate".appendToBody(|
        else if "change" <= 'chance' {
          return 'areaName'.generate();
        }|);
    }
    ~String entryPointTileName = null;
    ~Integer lowEntryBound = 0;
    ~Integer upperEntryBound = -1;
    declarationToken : element : area_element {
      element : atom : entryPointGeneration {
        lowEntryBound = Integer.parseInt('atom->"range"->"lowerBound"')\+1;
        upperEntryBound = Integer.parseInt('atom->"range"->"upperBound"')\+1;
        entryPointTileName = 'atom->"tile_names"';
      }
    }
    if upperEntryBound == -1 {
      upperEntryBound = upperEntryBound \+ 1;
    }
    
    \readBlueprint(declarationToken,'declarationToken->"bluePrintName"',mapName, areaClassName,lowEntryBound,upperEntryBound, entryPointTileName);
    Body floorSwitchBody = new Body ();
    Integer numberOfFloorTiles = floorTiles.size();
    Area->Generators->'mapName'->'areaClassName'->*"generateFloor".appendToBody(|switch Range.getRandom(0,'numberOfFloorTiles') `floorSwitchBody`|);
    ~Integer floorIndex = 0;
    for String floorName: floorTiles {
      Integer floorIndexValue = floorIndex;
      floorSwitchBody.add(|case 'floorIndexValue' { "result" = new Tiles->'mapName'->'floorName'("x","y","parent"); "break"; }|);
      floorIndex \+= 1;
    }
    Area->Generators->'mapName'->'areaClassName'->*"generate".appendToBody(| return "newArea"; |);
    Area->Generators->'mapName'->'areaClassName'->*"generateFloor".appendToBody(|return "result";|);
    Area->Generators->'mapName'->'areaClassName'->*"generateEntryPoint".appendToBody(|return "result";|);
    return chance;
  }
> void readBlueprint(%T decTok, String fileName, String mapName, String areaClassName, Integer lowEntryBound, Integer upperEntryBound, String entryPointTileName ){
	ByteBuffer pixelBuffer = null;
	~BufferedImage bufferedImage = null;
	try {
	  bufferedImage = ImageIO.read(new File("../Resource/environments/maps/blueprints/"+fileName));
	}
	print catch * {}
	Integer width = bufferedImage.getWidth();
	Integer height = bufferedImage.getHeight();
	int[] pixels = new int[width*height];
	PixelGrabber pixelGrabber = new PixelGrabber(bufferedImage,0,0,width,height,pixels,0,width);
	try {
	  pixelGrabber.grabPixels();
	}
	catch * {
	  System.err.println("Pixel Grabbing interrupted!");
	  return void;
	}
	byte[] bytes = new byte[width*height*4];
	Map<Integer,Map<Integer, Region>> regions = new HashMap<Integer, Map<Integer, Region>>();
	for Integer i < width {
	  regions.put(i, new HashMap<Integer, Region>());
	  for Integer j < height {
		regions.get(i).put(j,new Region(j,width\-i, pixels[i*32+j]));
	  }
	}
	for Integer x < width\-1{
	  for Integer y < height\-1{
	    if regions.get(x).get(y).isCompatible(regions.get(x+1).get(y)) {
		  regions.get(x).get(y).add(regions.get(x+1).get(y));
		  regions.get(x+1).put(y, regions.get(x).get(y));
	    }
	    if regions.get(x).get(y).isCompatible(regions.get(x).get(y+1)) {
 		  regions.get(x).get(y).add(regions.get(x).get(y+1));
	      regions.get(x).put(y+1, regions.get(x).get(y));
        }
	  }
	}
	if regions.get(width\-2).get(height\-1).isCompatible(regions.get(width\-1).get(height\-1)) {
	  regions.get(width\-2).get(height\-1).add(regions.get(width\-1).get(height\-1));
	  regions.get(width\-1).put(height\-1, regions.get(width\-2).get(height\-1));
    }
	if regions.get(width\-1).get(height\-2).isCompatible(regions.get(width\-1).get(height\-1)) {
	  regions.get(width\-1).get(height\-2).add(regions.get(width\-1).get(height\-1));
	  regions.get(width\-1).put(height\-1, regions.get(width\-1).get(height\-2));
	}
	Set<Region> regionSet = new HashSet<Region>();
    for Integer x < width {
	  for Integer y < height {
		if(regions.get(x).get(y).getPixel()!=Region.PIXEL_ZERO&&regions.get(x).get(y).getPixel()!= -1){
		  regionSet.add(regions.get(x).get(y));
		}
	  }
	}
	for Region region: regionSet {
	  List<List<RegionPoint>> zones = region.getZones();
	  List<RegionZone> points = region.getPoints(zones);
	  ~int zoneIndex = 0;
      Body switchBody = new Body ();
      Integer numberOfZones = points.size();
	  Area->Generators->'mapName'->'areaClassName'->*"generate".appendToBody(|
	    switch Range.getRandom(0,'numberOfZones') `switchBody`|);
      
	  for RegionZone zone: points {
		Integer startX = zone.getLowerBoundX();
		Integer startY = zone.getLowerBoundY();
		Integer zoneIndexValue = zoneIndex;
		~Integer entryPointIndex = 0;
		~Integer floorIndex = 0;
		Body caseBody = new Body ();
        Body entryWhileBody = new Body ();
        Body terrainWhileBody = new Body ();
        Body terrainChanceBody = new Body (); 
		switchBody.add(|case 'zoneIndexValue' { "generateZone"+'zoneIndexValue'("newArea"); "break"; }|);
		caseBody.add(|
	      Integer numberOfEntryPoints = Range.getRandom('lowEntryBound','upperEntryBound');
	      Set<Integer> chosenEntryPoints = new HashSet<Integer>();
	      while chosenEntryPoints.size() < numberOfEntryPoints `entryWhileBody` 
	      Integer numberOfTerrainPoints = 0; |);
	    caseBody.add(terrainChanceBody);
	    caseBody.add(|
	      Integer terrainsGenerated = 0;
	      Map<Integer, TerrainChoice > chosenTerrainPoints = new HashMap<Integer, TerrainChoice>();
	      while terrainsGenerated < \numberOfTerrainPoints `terrainWhileBody` |);
	    Map<Integer, Map<Integer, Map<Integer, Statement >>> terrainMap = new HashMap<Integer, Map<Integer, Map<Integer, Statement >>>();
        Map<Integer, Map<Integer, Integer >>               terrainIndexMap = new HashMap<Integer, Map<Integer, Integer >>();
        
		
		for RegionPoint point: zone {
		  if point != null {
		    Integer floorIndexValue = floorIndex;
		    floorIndex \+= 1;
		    Integer pointX = point.getX()\-startX;
		    Integer pointY = point.getY()\-startY;
		    if terrainIndexMap.containsKey(pointX) == false {
		      terrainIndexMap.put(pointX, new HashMap<Integer, Integer>());
		    }
		    terrainIndexMap.get(pointX).put(pointY, floorIndexValue);
		    \addTerrainIndex(terrainIndexMap,terrainMap,floorIndexValue,pointX,pointY,4);
		    if zone.getUps().containsKey(point.getX()) {
		      for RegionEdge edge: zone.getUps().get(point.getX()) {
		        if point.getY() >= edge.getStart() && point.getY() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX\-1, pointY, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    else if zone.getDowns().containsKey(point.getX()) {
		      for RegionEdge edge: zone.getDowns().get(point.getX()) {
		        if point.getY() >= edge.getStart() && point.getY() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX\+1, pointY, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    if zone.getRights().containsKey(point.getY()) {
		      for RegionEdge edge: zone.getRights().get(point.getY()) {
		        if point.getX() >= edge.getStart() && point.getX() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX, pointY\+1, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    else if zone.getLefts().containsKey(point.getY()) {
		      for RegionEdge edge: zone.getLefts().get(point.getY()) {
		        if point.getX() >= edge.getStart() && point.getX() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX, pointY\-1, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
	        caseBody.add(|
	          if "chosenTerrainPoints".containsKey('floorIndexValue') {
	            Tiles->Floor newFloorTile = "chosenTerrainPoints".get('floorIndexValue').getFloorFactory().create('pointX','pointY',"parent");
	            newFloorTile.setTerrain("chosenTerrainPoints".get('floorIndexValue').getTerrainFactory().create(newFloorTile));
	            "newArea".add(newFloorTile);
	          }
	          else {
	            "newArea".add(\generateFloor('pointX','pointY'));
	          }|);
	      }
		}
		Area->Generators->'mapName'->'areaClassName' += void "generateZone"+'zoneIndexValue'(Area newArea){}
		Area->Generators->'mapName'->'areaClassName'->*"generateZone"+'zoneIndexValue'.appendToBody(caseBody);
		
		Integer entryPointIndexValue = entryPointIndex;
		entryWhileBody.add(|"chosenEntryPoints".add(Range.getRandom(0,'entryPointIndexValue'));|);
		Integer floorIndexValue = floorIndex;
		String generateTerrainChoiceName = \makeTerrainBody(decTok,mapName,areaClassName,terrainChanceBody,terrainMap,floorIndex);
		terrainWhileBody.add(|"terrainsGenerated" \+= Area->TerrainChoice->'mapName'->'areaClassName'->'generateTerrainChoiceName'.generate("chosenTerrainPoints");|);
		
		
        zoneIndex \+= 1;
	  }
	}
	
	Area->Generators->'mapName'->'areaClassName'->*"generate".appendToBody({
		  Integer numberOfEntryPoints = "newArea".getEntryPoints().size();
		  for Integer i < numberOfEntryPoints {
		    Integer j = i \+ 1;
		    while j < numberOfEntryPoints {
		      ArrayList<Tiles\>Floor> path = "newArea".getAbsolutePathBetweenEntryPoints(i,j);
		      ArrayList<Tiles\>Floor> obstructions = new ArrayList<Tiles\>Floor>();
		      Tiles->Floor previousStep = null;
		      if path != null {
		        for Tiles->Floor step: path {
		          if previousStep != null {
		            if step.isPassable(previousStep.getX()\-step.getX(), previousStep.getY()\-step.getY()) == false {
		              obstructions.add(step);
		            }
		          }
		          previousStep = step;
		        }
		        for Tiles->Floor step : obstructions {
		          if step.getTerrain() != null && step.getTerrain().isPassable(0,0) == false{
		            "newArea".changeTerrain(step.getTerrain(),null);
		            step.setTerrain(null);
		          }
		          if step.isPassable(0,0) == false {
		            "newArea".remove(step);
		            Tiles->Floor newTile = \generateFloor(step.getX(),step.getY());
		            while newTile.isPassable(0,0) == false {
		              newTile = \generateFloor(step.getX(),step.getY());
		            }
		            "newArea".add(newTile);
		          }
		        }
		        if obstructions.isEmpty() == false {
		          "newArea".clearAbsolutePathBetweenEntryPoints(i,j);
		          "newArea".getAbsolutePathBetweenEntryPoints(i,j);
		        }
		      }
		      "++j";
		    }
		  }
		});
  }
> Statement addAreaEntryPoint(Integer pointX,Integer pointY, String mapName, String entryPointTileName,Integer entryPointIndex) {
    return |if "chosenEntryPoints".contains('entryPointIndex') {
        "newArea".add(new EntryPoints->'mapName'->'entryPointTileName'('pointX','pointY',"parent"));
      }|;
  }
> void addTerrainIndex(Map<Integer, Map<Integer, Integer>> terrainIndexMap, Map<Integer, Map<Integer, Map<Integer, Statement >> > terrainMap, Integer terrainIndex, Integer x, Integer y, Integer backtrackLength){
    terrainMap.put(terrainIndex, new HashMap<Integer, Map<Integer, Statement >>());
    for Integer dx < backtrackLength {
      for Integer dy < backtrackLength {
        if terrainIndexMap.containsKey(x\-dx) && terrainIndexMap.get(x\-dx).containsKey(y\-dy) {
          Map<Integer, Map<Integer, Statement >> toAdd = terrainMap.get(terrainIndexMap.get(x\-dx).get(y\-dy));
          if toAdd.containsKey(dx) == false {
            toAdd.put(dx, new HashMap<Integer, Statement >());
          }
          if toAdd.get(dx).containsKey(dy) == false {
            toAdd.get(dx).put(dy, new Statement ());
          }
          toAdd.get(dx).get(dy).add(|'terrainIndex'|);
        }
      }
    }
  }
> ~Integer terrainChoiceMakerIndex = 0;
> String makeTerrainBody(%T declarationToken, String mapName, String areaClassName, Body terrainChanceBody, Map<Integer, Map<Integer, Map<Integer, Statement >>> terrainMap, Integer layoutSize){
    Map<Integer, Set<Integer>> terrainMappedDimensions = new HashMap<Integer, Set<Integer>>(); 
    Integer terrainChoiceMakerIndexValue = terrainChoiceMakerIndex;
    terrainChoiceMakerIndex \+= 1;
    String generateTerrainChoiceName = "Generator"\+'terrainChoiceMakerIndexValue';
    Area->TerrainChoice->'mapName'->'areaClassName' += class generateTerrainChoiceName // {
        @Integer generate(Map<Integer, TerrainChoice> terrainMap){}
      } 
    ~Double terrainChanceBuilder = 0.0;
    terrainChanceBody.add(|Float terrainChance = Range.getRandomFloat();|);
    Area->TerrainChoice->'mapName'->'areaClassName'->'generateTerrainChoiceName'->*"generate".appendToBody({Integer startIndex = Range.getRandom(0,'layoutSize');});
    declarationToken : element : area_element {
      element : atom : terrainGeneration {
        ~Boolean isFirst = true;
        atom : quark : probability {
          Double terrainChanceValue = Double.parseDouble('quark->"percent"')\/100.0\+terrainChanceBuilder;
          if isFirst {
            terrainChanceBody.add(|if "terrainChance" <= 'terrainChanceValue' {
                "numberOfTerrainPoints" = 'quark->"amount"';
              }|);
          }
          else {
            terrainChanceBody.add(|else if "terrainChance" <= 'terrainChanceValue' {
                "numberOfTerrainPoints" = 'quark->"amount"';
              }|);
          }
          isFirst = false;
          terrainChanceBuilder = terrainChanceValue;
        }
        
        ~Integer choiceCount = 0;
        atom : quark : patch_element {
          choiceCount \+= 1;
        }
        
        Body terrainSwitchBody = new Body ();
        Integer choiceCountValue = choiceCount;
        Area->TerrainChoice->'mapName'->'areaClassName'->'generateTerrainChoiceName'->*"generate".appendToBody(| 
          switch Range.getRandom(0,'choiceCountValue') `terrainSwitchBody` |);
        ~Integer choiceIndex = 0;
        atom : quark : patch_element {
          Integer choiceIndexValue = choiceIndex;
          String terrainTileName = ^quark->"tile_names";
          String terrainTileNameValue = 'quark->"tile_names"'.toLowerCase();
          Body terrainCaseBody = new Body ();
          Area->TerrainChoice->'mapName'->'areaClassName'->'generateTerrainChoiceName' +=  @TerrainChoice 'terrainTileNameValue' = new TerrainChoice(
                 new Tiles->'mapName'->'terrainTileName'->\FloorFactory(),
                 new Tiles->'mapName'->'terrainTileName'->Factory());
          Integer width;
          if quark->"patchHeight" != null {
            width = Integer.parseInt('quark->"patchWidth"')\-1;
          }
          else {
            width = 0;
          }
          Integer height;
          if quark->"patchHeight" != null {
            height = Integer.parseInt('quark->"patchHeight"')\-1;
          }
          else {
            height = 0;
          }
          if width == 0 && height == 0 {
            terrainCaseBody.add(|"terrainMap".put("startIndex", 'terrainTileNameValue');|);
            terrainCaseBody.add(|return 1;|);
          }
          else {
            Statement usableTerrainStatement = new Statement ();
            terrainCaseBody.add(|"startIndex" = Range.getRandom(0,`usableTerrainStatement`);|);
            
            Integer widthPlus = width\+1;
            Integer heightPlus = height\+1;
            terrainCaseBody.add(|Integer chosenTerrainWidth = Range.getRandom(0,'widthPlus');|);
            terrainCaseBody.add(|Integer chosenTerrainHeight = Range.getRandom(0,'heightPlus');|);
            for Integer w <= width {
              Body widthIfBody = new Body ();
              if w == 0 {
                terrainCaseBody.add(|     if "chosenTerrainWidth" <= 'w' `widthIfBody` |);
              }
              else {
                terrainCaseBody.add(|else if "chosenTerrainWidth" <= 'w' `widthIfBody` |);
              }
              for Integer h <= height {
                if h == 0 {
                  widthIfBody.add(|
                    if "chosenTerrainHeight" <= 'h' {
                      terrainMap.put("map"+'width'+"x"+'height'["startIndex",'w','h'], 'terrainTileNameValue');
                    }|);
                }
                else {
                  widthIfBody.add(|
                    else if "chosenTerrainHeight" <= 'h' {
                      terrainMap.put("map"+'width'+"x"+'height'["startIndex",'w','h'], 'terrainTileNameValue');
                    }|);
                }
              }
            }
            ~Boolean hasDimensions = false;
            Parameters indexParameters = new Parameters ();
            if terrainMappedDimensions.containsKey(width) && terrainMappedDimensions.get(width).contains(height) {
              hasDimensions = true;
            }
            else {
              if terrainMappedDimensions.containsKey(width) == false {
                terrainMappedDimensions.put(width, new HashSet<Integer>());
              }
              terrainMappedDimensions.get(width).add(height);
              Area->TerrainChoice->'mapName'->'areaClassName'->'generateTerrainChoiceName' +=  @int[][][] "map"+'width'+"x"+'height' = new int(`indexParameters`)[][][];
            }
            ~Integer usableTerrainCount = 0;
            for Integer floorIndex < layoutSize {
              if terrainMap.containsKey(floorIndex) && terrainMap.get(floorIndex).containsKey(width) && terrainMap.get(floorIndex).get(width).containsKey(height) {
                usableTerrainCount \+= 1;
                if hasDimensions == false {
                  ~Statement previousRealIndex = |'floorIndex'|;
                  Parameters widthParameters = new Parameters ();
                  indexParameters.add(|new int(`widthParameters`)[][]|);
                  for Integer w <= width {
                    
                    Parameters heightParameters = new Parameters ();
                    widthParameters.add(|new int(`heightParameters`)[]|);
                    for Integer h <= height {
                      if terrainMap.containsKey(floorIndex) && terrainMap.get(floorIndex).containsKey(w) && terrainMap.get(floorIndex).get(w).containsKey(h) {
                        previousRealIndex = terrainMap.get(floorIndex).get(w).get(h);
                      }
                      heightParameters.add(previousRealIndex);
                    }
                  }
                }
              }
            }
            Integer usableTerrainCountValue = usableTerrainCount;
            usableTerrainStatement.add(|'usableTerrainCountValue'|);
            terrainCaseBody.add(|return 1; |);
          }
          terrainSwitchBody.add(|
            case 'choiceIndexValue' `terrainCaseBody`|);
          choiceIndex \+= 1;
        }
      }
    }
    Area->TerrainChoice->'mapName'->'areaClassName'->'generateTerrainChoiceName'->*"generate".appendToBody({return 0;});
    return generateTerrainChoiceName;
  }
>  byte getPixelA(int p){
    return (byte)((p >> 24) & 0xFF);
  }
>  byte getPixelR(int p){
    return (byte)((p >> 16) & 0xFF);
  }
>  byte getPixelG(int p){
    return (byte)((p >> 8) & 0xFF);
  }
>  byte getPixelB(int p){
    return (byte)((p >> 0) & 0xFF);
  }
  void display(){
    for Tiles->Floor->Id floorId : floorMap.keySet() {
      for Tiles\>Floor tile : floorMap.get(floorId) {
        tile.display();
      }
    }
    for Tiles\>EntryPoint tile : entryPoints {
      tile.display();
    }
  }
  void undisplay(){
    for Tiles->Floor->Id floorId : floorMap.keySet() {
      for Tiles\>Floor tile : floorMap.get(floorId) {
        tile.undisplay();
      }
    }
    for Tiles\>EntryPoint tile : entryPoints {
      tile.undisplay();
    }
  }
  Tiles->Floor getFloorTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->MonsterDen getMonsterDen(Tile->Id findId){
    if tileMap.containsKey(findId) == false || tileMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return (Tiles->MonsterDen)Range.select(tileMap.get(findId));
    }
  }
  Tiles->MonsterDen getMonsterDen(Predicate<Tile> findId){
    Collectors collects = null;
    '"java.util.List<Tile>"' list = tiles.parallelStream().filter(findId).collect(Collectors.toList());
    if list.isEmpty() {
      return null;
    }
    else {
      return (Tiles->MonsterDen)Range.select(list);
    }
  }
  Tiles->Floor getTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  int getDistanceToArea(Area area){
    if this == area {
      return 0;
    }
    for Integer i : areaDistances.keySet() {
      if areaDistances.get(i).contains(area) {
        return i;
      }
    }
    return -1;
  }
  void findDistance(Area findArea){
    for Tiles->EntryPoint entryPoint: entryPoints {
      if entryPoint.getSister() != null && entryPoint.getSister().getArea() == findArea {
        \setDistanceToArea(1,findArea);
        return void;
      }
    }
    for Integer i : areaDistances.keySet() {
      for Area area : areaDistances.get(i) {
        for Tiles->EntryPoint entryPoint: area.entryPoints {
          if entryPoint.getSister().getArea() == findArea {
            \setDistanceToArea(i\+1,findArea);
            return void;
          }
        }
      }
    }
  }
  void setDistanceToArea(int distance, Area area){
    if areaDistances.containsKey(distance) == false {
      areaDistances.put(distance,new HashSet<Area>());
      if distance > furthestDistanceToArea {
        furthestDistanceToArea = distance;
      }
    }
    areaDistances.get(distance).add(area);
  }
  Tiles->EntryPoint getEntryPoint(Integer index){
    return entryPoints.get(index);
  }
  Tile getTile(Tile->Id findId){
    if tileMap.containsKey(findId) == false || tileMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(tileMap.get(findId));
    }
  }
  Tile getTile(Tiles->Floor->Id findId){
    if floorMap.containsKey(findId) == false || floorMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(floorMap.get(findId));
    }
  }
  Tile getTile(Tiles->Terrain->Id findId){
    if terrainMap.containsKey(findId) == false || terrainMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(terrainMap.get(findId));
    }
  }
  void load(){
    for Integer currentTickPosition < 'tickEventArrayLength' {
      tickEvents[currentTickPosition] = new Area->Event->Tick->Listener();
    }
    for Tile tile: tiles {
      tile.load();
    }
  }
  void tick(Double millisSinceLastFrame){
    for Tile tile: tiles {
      tile.tick(millisSinceLastFrame);
    }
    tickEvents["currentTickPosition++"].tick(millisSinceLastFrame);
    if currentTickPosition >= 'tickEventArrayLength' {
      currentTickPosition = 0;
    }
  }
  void addEvent(Integer offset, Area->Event->Tick event) {
    Integer putIndex = currentTickPosition\+offset;
    if putIndex >= 'tickEventArrayLength' {
      putIndex \-= 'tickEventArrayLength';
    }
    tickEvents[putIndex].add(event);
  }
  Boolean add(Entity entity){
    if \getParent() != null && entity.getIsPlayerAffiliated() {
      \getParent().addActiveArea(this);
    }
    return entities.add(entity);
  }
  Boolean remove(Entity entity){
    if \getParent() != null && entity.getIsPlayerAffiliated() {
      \getParent().removeActiveArea(this);
    }
    return entities.remove(entity);
  }
  Boolean add(Tile newTile){
    newTile.setArea(this);
    if newTile.getX() \+ newTile.getWidth() > width {
      width = newTile.getX() \+ newTile.getWidth();
    }
    if newTile.getY() \+ newTile.getHeight() > height {
      height = newTile.getY() \+ newTile.getHeight();
    }
    if tileMap.containsKey(newTile.getId()) == false {
      tileMap.put(newTile.getId(), new ArrayList<Tile>());
    }
    tileMap.get(newTile.getId()).add(newTile);
    if "newTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.add("((Tiles.EntryPoint)newTile)");
    }
    if "newTile.getId() instanceof Tiles.Floor.Id" {
      floorTiles.add((Tiles->Floor)newTile);
      if floorMap.containsKey(newTile.getId()) == false {
        floorMap.put("(Tiles.Floor.Id)newTile.getId()",new ArrayList<Tiles\>Floor>());
      }
      floorMap.get("(Tiles.Floor.Id)newTile.getId()").add("(Tiles.Floor)newTile");
      if layout.containsKey(newTile.getX()) == false {
        layout.put(newTile.getX(), new HashMap<Integer,Tiles\>Floor>());
      }
      layout.get(newTile.getX()).put(newTile.getY(),"(Tiles.Floor)newTile");
    }
    else if "newTile.getId() instanceof Tiles.Terrain.Id" {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile.getId()",new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add("(Tiles.Terrain)newTile");
    }
    if \parent != null {
      \parent.add(newTile);
    }
    return tiles.add(newTile);
  }
  void changeFloorLocation(Integer oldX, Integer oldY, Integer newX, Integer newY){
    if layout.containsKey(newX) == false {
      layout.put(newX,new HashMap<Integer, Tiles\>Floor>());
    }
    layout.get(newX).put(newY, layout.get(oldX).remove(oldY));
  }
  void changeTerrain(Tiles\>Terrain oldTile, Tiles\>Terrain newTile){
    if oldTile != null {
      if terrainMap.containsKey(oldTile.getId()) {
        terrainMap.get("(Tiles.Terrain.Id)oldTile".getId()).remove(oldTile);
      }
    }
    if newTile != null {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile".getId(), new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add(newTile);
    }
  }
  Boolean remove(Entity entity){
    return entities.remove(entity);
  }
  Boolean remove(Tile oldTile){
    for Tile neighbour: oldTile.getNeighbours() {
      neighbour.resetNeighbour(oldTile);
    }
    oldTile.setArea(null);
    tileMap.get(oldTile.getId()).remove(oldTile);
    if "oldTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.remove(oldTile);
    }
    else if "oldTile.getId() instanceof Tiles.Floor.Id" {
      floorMap.get(oldTile.getId()).remove("(Tiles.Floor)oldTile");
      if layout.containsKey(oldTile.getX()) {
        layout.get(oldTile.getX()).remove(oldTile.getY());
      }
    }
    else if "oldTile.getId() instanceof Tiles.Terrain.Id" {
      terrainMap.get(oldTile.getId()).remove("(Tiles.Terrain)oldTile");
    }
    return tiles.remove(oldTile);
  }
  boolean has(Predicate<Tile> criteria){
    return tiles.parallelStream().anyMatch(criteria);
  }
  Tiles->Floor getUnexploredPoint(Entity explorer){
    if entryPoints.isEmpty() {
      return null;
    }
    else {
      for Tiles\>EntryPoint tile: entryPoints {
        if ( tile.getSister() == null || tile.getSister().getArea() == null || explorer.hasExplored(tile.getSister().getArea()) == false ) && tile.hasOccupant(explorer) == false {
          return tile;
        }
      }
      return null;
    }
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range){
    Entity->List result = new Entity->List();
    for Entity entity: entities {
      if entity.getLocation().getDistanceTo(position) <= range {
        result.add(entity);
      }
    }
    return result;
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range, Predicate<Entity> criteria){
    Entity->List result = new Entity->List();
    for Entity entity: entities {
      if entity.getLocation().getDistanceTo(position) <= range && criteria.test(entity) {
        result.add(entity);
      }
    }
    return result;
  }
  Entity getClosestEntity(Environment->Position position, Predicate<Entity> criteria){
    Entity candidate = null;
    Double distance = Double.MAX_VALUE;
    for Entity entity: entities {
      Double candidateDistance = entity.getLocation().getDistanceTo(position);
      if candidateDistance < distance && criteria.test(entity) {
        candidate = entity;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestTile(Environment->Position position, Tile->Id tileId){
    if tileMap.containsKey(tileId) == false {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: tileMap.get(tileId) {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestTile(Environment->Position position, Predicate<Tile> criteria){
    for Integer distance < furthestDistanceToArea {
      ArrayList<Tile> tiles = new ArrayList<Tile>();
      \getAllTiles(distance,tiles);
      Tile result = tiles.parallelStream().filter(criteria).sorted(new Tile->Comparators->Distance->Ascending->Complex(position)).findFirst().orElse(null);
      if result != null {
        return result;
      }
    }
    return null;
  }
  void getAllTiles(int distance,ArrayList<Tile> collector){
    if distance == 0 {
      collector.addAll(tiles);
    }
    else {
      if areaDistances.containsKey(distance) {
        for Area area: areaDistances.get(distance) {
          collector.addAll(area.tiles);
        }
      }
    }
  }
  Tile getClosestTile(Environment->Position position, Tiles->Terrain->Id terrainId){
    if terrainMap.containsKey(terrainId) == false {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: terrainMap.get(terrainId) {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestEntryPoint(Environment->Position position){
    if entryPoints.isEmpty() {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: entryPoints {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Boolean isWithin(Environment->Position otherPosition){
    return otherPosition.getX() >= 0 && otherPosition.getX() < "width" && otherPosition.getY() >= 0 && otherPosition.getY() < "height";
  }
  Tiles->EntryPoint getEntryPointToward(Area area){
    if sisterAreas.containsKey(area) {
      return sisterAreas.get(area);
    }
    else {
      for Tiles\>EntryPoint entryPoint: entryPoints {
        if entryPoint.getSister() != null && entryPoint.getSister().getArea() == area {
          sisterAreas.put(area,entryPoint);
          return entryPoint;
        }
        else if entryPoint.getSister() != null && entryPoint.getSister().getArea() != null {
          Set<Area> investigated = new HashSet<Area>();
          if entryPoint.getSister().getArea().canGetToAreaFrom(area,entryPoint.getSister(),investigated) {
            investigated.add(this);
            sisterAreas.put(area,entryPoint);
            return entryPoint;
          }
        }
      }
    }
    return null;
  }
  Boolean canGetToAreaFrom(Area findArea,Tiles->EntryPoint previousEntryPoint, Set<Area> investigated){
    if this == findArea {
      return true;
    }
    if investigated.add(this) {
      for Tiles\>EntryPoint entryPoint: entryPoints {
        if previousEntryPoint == entryPoint {
          "continue";
        }
        if entryPoint.getSister() != null && entryPoint.getSister().getArea() != null {
          if entryPoint.getSister().getArea().canGetToAreaFrom(findArea,entryPoint.getSister(),investigated) {
            return true;
          }
        }
      }
    }
    return false;
  }
  ArrayList<Tiles\>Floor> getAbsolutePathBetweenEntryPoints(Integer startPoint, Integer endPoint){
    if entryToEntryPaths.containsKey(startPoint) {
      if entryToEntryPaths.get(startPoint).containsKey(endPoint) {
        return entryToEntryPaths.get(startPoint).get(endPoint);
      }
    }
    else {
      entryToEntryPaths.put(startPoint, new HashMap<Integer, ArrayList<Tiles\>Floor>>());
    }
    Tiles->Floor endTile = entryPoints.get(endPoint);
    Tiles->Floor tile = entryPoints.get(startPoint);
    Tiles->Floor->Path path = new Tiles->Floor->Path(null,tile,endTile);
    Tiles->Floor->Path->Ways ways = new Tiles->Floor->Path->Ways();
    ways.add(path);
    Set<Tiles\>Floor> investigated = new HashSet<Tiles\>Floor>();
    investigated.add(null);
    investigated.add(tile);
    ArrayList<Tiles\>Floor\>Path> tried = new ArrayList<Tiles\>Floor\>Path>(); 
    while path.getTile() != endTile && ways.isEmpty() == false {
      path = ways.pollFirst();
      tried.add(path);
      for Tiles->Floor neighbour: path.getTile().getNeighbours() {
        if investigated.add(neighbour) {
          ways.add(new Tiles->Floor->Path(path,neighbour,endTile));
        }
      }
    }
    if path.getTile() == endTile {
      entryToEntryPaths.get(startPoint).put(endPoint, path);
      if entryToEntryPaths.containsKey(endPoint) == false {
        entryToEntryPaths.put(endPoint, new HashMap<Integer, ArrayList<Tiles\>Floor>>());
      }
      entryToEntryPaths.get(endPoint).put(startPoint, path.reverse());
      return path;
    }
    else {
      System.err.println('' "Could not make path!" '');
      for Tiles->Floor->Path trie: tried {
        System.out.println(path);
      }
      return null;
    }
  }
  void clearAbsolutePathBetweenEntryPoints(Integer startPoint, Integer endPoint){
    if entryToEntryPaths.containsKey(startPoint) {
      if entryToEntryPaths.get(startPoint).containsKey(endPoint) {
        entryToEntryPaths.get(startPoint).remove(endPoint);
      } 
    }
    if entryToEntryPaths.containsKey(endPoint) {
      if entryToEntryPaths.get(startPoint).containsKey(startPoint) {
        entryToEntryPaths.get(endPoint).remove(startPoint);
      } 
    }
  }
  
  
  class TerrainChoice // {
    Tiles->Floor->Factory floorFactory = null;
    Tiles->Terrain->Factory terrainFactory = null;
  }
}
import area_regions.clws
< Collector : java.util.stream;
< Collections : java.util;
class 'packageName'.environments Areas {
}
class 'packageName'.environments Area Environment->Position EntryPointJoinable {
> Integer tickEventArrayLength = 256;
  class Id // {
  }
  enum Imports //{
    Collector collector = null;
    enum IdMap //{}
    enum TypeMap //{}
  }
  interface EntryPointListener // {
    Boolean listen(Tiles->EntryPoint newEntryPoint){}
  }
  Area->Id getId(){
    return null;
  }
  ~List<Tile> tiles = Collections.synchronizedList(new ArrayList<Tile>());
  ~Map<Integer, Map<Integer, Tiles\>Floor>> layout = new HashMap<Integer, Map<Integer, Tiles\>Floor>>();
  ~ArrayList<Tiles\>EntryPoint> entryPoints = new ArrayList<Tiles\>EntryPoint>();
  ~ArrayList<EntryPointListener> entryPointsListeners = new ArrayList<EntryPointListener>();
  ~Tile->IdMap tileMap = new Tile->IdMap();
  ~ArrayList<Tiles\>Floor> floorTiles = new ArrayList<Tiles\>Floor>();
  ~Tiles->Floor->IdMap floorMap = new Tiles->Floor->IdMap();
  ~Tiles->Terrain->IdMap terrainMap = new Tiles->Terrain->IdMap();
  
  ~Map<Integer, Map<Integer, ArrayList<Tiles\>Floor>>> entryToEntryPaths = new HashMap<Integer, Map<Integer, ArrayList<Tiles\>Floor>>>();
  ~Map<Area, Tiles\>EntryPoint> sisterAreas = new HashMap<Area, Tiles\>EntryPoint>();
  ~ArrayList<Set<Area>> areaDistances = new ArrayList<Set<Area>>(32);
  ~int furthestDistanceToArea = 0;
  
  ~Building->TypeMap buildings = new Building->TypeMap();
  
  ~List<Entity> entities = Collections.synchronizedList(new ArrayList());
  ~Integer width = 0;
  ~Integer height = 0;
  ~Integer currentTickPosition = 0;
  
  ~Area->Event->\Tick->Listener[] tickEvents = new Area->Event->\Tick->Listener['tickEventArrayLength'];
  ~Area->Generators->FloorGenerator generator = null;  
  
  class Event // {
    interface Tick // {
      void tick(Double millisSinceLastFrame){
      }
      class Listener / ArrayList<Area\>Event\>Tick> / {
        void tick(~Double millisSinceLastFrame){
          this.stream().forEach(("T")->"T".tick(millisSinceLastFrame));
          \clear();
        }
      }
    }
  }
  class Generator // {
    Area generate(){
      return null;
    }
  }
  class Generators // {
    class FloorGenerator // {
      Tiles->Floor generateFloor(int x, int y, Environment parent){
        return null;
      }
    }
    class NonGenerator //Area->TileGenerator {
      @NonGenerator non = new NonGenerator();
      void generateAt(int x, int y, Area newArea){}
      void setInnerFloor(Area->FloorChoice choice){}
      void setLeftSideFloor(Area->FloorChoice choice){}
      void setUpSideFloor(Area->FloorChoice choice){}
      void setRightSideFloor(Area->FloorChoice choice){}
      void setDownSideFloor(Area->FloorChoice choice){}
      void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}
    }
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area1) - origin.getDistanceTo(area2))";
        }
      }
      class Descending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area2) - origin.getDistanceTo(area1))";
        }
      }
    }
  }
> void setup(%Pass data){
    \createIdMap(Building->Type, Building);
  }
> class GeneratorMapValues // {
    ~Class acceptorClass = null;
    Set<String> tilesAdded = new HashSet<String>();
    Map<Integer, Set<Integer>> mappedDimensions = new HashMap<Integer, Set<Integer>>();
    ~Integer layoutSize = 0;
    ~Integer width = 0;
    ~Integer height = 0;
    ~int subGenerators = 0;
    ~Statement generationPointArraySize = new Statement ();
    ~Parameters relativePositions = new Parameters ();
    void set(Class newAcceptorClass, int newWidth, int newHeight, int newLayoutSize){
      acceptorClass = newAcceptorClass;
      width = newWidth;
      height = newHeight;
      layoutSize = newLayoutSize;
      #Parameters startIndices = new Parameters ();
      for int x < width {
        Parameters line = new Parameters ();
        startIndices.add(|new int(`line`)[]|);
        for int y < height {
          line.add(|'new Integer(x*width\+y)'|);
        }
      }
      acceptorClass.addVariable(@int[][] startIndex = new int(`startIndices`)[][];);#
    }
    String addTerrainTile(String mapName, String generatorName, String tileName, %T patchGoto){
      String tileVariableName = tileName.toLowerCase();
      if patchGoto != null {
        String roomName;
        String roomVariableName;
        if patchGoto->"destination"->"room_names" != null{
          roomName = 'patchGoto->"destination"->"room_names"';
          roomVariableName = roomName;
          String tileVariableNameValue = tileVariableName\+roomVariableName;
          if tilesAdded.add(tileVariableNameValue){
            acceptorClass->'generatorName'.addVariable(
              @EntryPoints->'mapName'->'tileName'->\JoinGenerator 'tileVariableNameValue' = null;);            
            acceptorClass->'generatorName'.getMethod("setupChoices").appendToBody({
              'tileVariableNameValue' =  new EntryPoints->'mapName'->'tileName'->\JoinGenerator('roomName.toLowerCase()'); 
            });
          }
          return tileVariableNameValue;
        }
        else if patchGoto->"destination"->"map_names" != null {
          roomVariableName = 'patchGoto->"destination"->"map_names"';
          String tileVariableNameValue = tileVariableName\+roomVariableName;
          if tilesAdded.add(tileVariableNameValue){
            acceptorClass.addVariable(
              @EntryPoints->'mapName'->'tileName'->\JoinGenerator 'tileVariableNameValue' = new EntryPoints->'mapName'->'tileName'->\JoinGenerator(
                  `Environments.getId('patchGoto->"destination"->"map_names"')`););
          }
          return tileVariableNameValue;
        }
        else {
          roomVariableName = null;
          roomName = null;
          return null;
        }
      }
      else {
        if tilesAdded.add(tileName){
          if Tiles->'mapName'->'tileName'->'"FloorFactory"' != null {
             acceptorClass.addVariable(@Area->TerrainChoice 'tileVariableName' = new Area->TerrainChoice(
                new Tiles->'mapName'->'tileName'->\FloorFactory(),
                new Tiles->'mapName'->'tileName'->Factory()););
           }
           else {
             acceptorClass.addVariable(@Area->TerrainChoice 'tileVariableName' = new Area->TerrainChoice(
               new Tiles->'mapName'->'tileName'->Factory(),
               null););
          }
        }
      }
      return tileVariableName;
    }
    String getRoomGenerator(String roomName){
      String roomGenerator = roomName\+"RoomGenerator";
      return roomGenerator;
    }
    String getNextSubGenerator(){
      String name = "PatchGenerator"\+subGenerators;
      subGenerators\+=1;
      return name;
    }
    Integer getNextRelativePosition(Integer x, Integer y){
      Integer startingIndex = relativePositions.size();
      relativePositions.add(|'x'|);
      relativePositions.add(|'y'|);
      return startingIndex;
    }
    void addDefaultVariablesAndMethods(String generatorName, Class defaultFloorGeneratorClass){
      acceptorClass->'generatorName'+=
        Area->TileGenerator floorGenerator = new 'defaultFloorGeneratorClass.getFullName()'();
      acceptorClass->'generatorName'+=
        @int[] relativePositions = new int(`\getRelativePositions()`)[];
      acceptorClass->'generatorName'+=
        ~Stream<Area\>FloorChoice> generationPoints = null;
	  acceptorClass->'generatorName'+=
          void generateAt(int startX, int startY, Area newArea){
            generationPoints = IntStream.range(0,`\getGenerationPointArraySize()`).parallel().mapToObj(("I")->new Area->FloorChoice(acceptorClass->'generatorName'.this, "I", startX, startY, 'width', 'height'));
          }
      acceptorClass->'generatorName'+=
          void setInnerFloor(Area->FloorChoice choice){
            choice.setGenerator(\floorGenerator);
          }
      acceptorClass->'generatorName'+=
          void setLeftSideFloor(Area->FloorChoice choice){
          }
      acceptorClass->'generatorName'+=
          void setUpSideFloor(Area->FloorChoice choice){
          }
      acceptorClass->'generatorName'+=
          void setRightSideFloor(Area->FloorChoice choice){
          }
      acceptorClass->'generatorName'+=
          void setDownSideFloor(Area->FloorChoice choice){
          }
      acceptorClass->'generatorName'+=
          void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){
            choice.setX(startX\+\relativePositions[index]);
            choice.setY(startY\+\relativePositions[index\+1]);
          }
      acceptorClass->'generatorName'+=
          void addOneAnywhere(Area->TileGenerator generator){
            generationPoints = Streamer.performOnce(Range.getRandom(0,'layoutSize'),generationPoints, ("P")->"P".setGenerator(generator));
          }
    }
    void finish() {
      generationPointArraySize.add(|'new Integer(layoutSize\+2\*width\+2\*height\+relativePositions.size()\/2)'|);
    }
  }
> Map<Class , Map<String, GeneratorMapValues >> generatorMapValues = new HashMap<Class , Map<String, GeneratorMapValues>>();
> Map<String, Map<String, Integer>> generatorIndices = new HashMap<String,Map<String,Integer>>();
> void addGeneratorSuperClass(Class generatorClass) {
    generatorMapValues.put(generatorClass, new HashMap<String, GeneratorMapValues>());
  }
> GeneratorMapValues addGeneratorClass(Class acceptorClass, String generatorName, int width, int height, int size){
    GeneratorMapValues result = new GeneratorMapValues();
    result.set(acceptorClass, width, height, size);
    generatorMapValues.get(acceptorClass).put(generatorName, result);
    return result;
  }
> double declaration(%T declarationToken, String mapName, List<String> floorTiles, double previousChance){
    if generatorIndices.containsKey(mapName) == false {
      Area.generatorIndices.put(mapName, new HashMap<String,Integer>());
      Areas->'mapName' += class AnyGenerator / Area->Generator / {
        Environment parent = null;
        Area generate(){
          Float chance = Range.getRandomFloat();
          Area newArea = new Area();
          parent.add(newArea);
        }      
        @void joinEntryPoints(Area newArea){
		  Integer numberOfEntryPoints = newArea.getEntryPoints().size();
		  IntStream.range(0,numberOfEntryPoints).parallel().forEach(
		    "I"->IntStream.range("I"\+1,numberOfEntryPoints).parallel().forEach(("J")->\joinEntryPoints(newArea, "I", "J")));
		}
		@void joinEntryPoints(Area newArea, int i, int j){
		  ArrayList<Tiles\>Floor> path = "newArea".getAbsolutePathBetweenEntryPoints(i,j);
          
          if path != null {
		    ArrayList<Tiles\>Floor> obstructions = 
		      (ArrayList<Tiles\>Floor>)\IntStream.range(1,path.size()).parallel()
		        .filter(("P")->path.get("P").isPassable(path.get("P"\-1).getX()\-path.get("P").getX(), path.get("P"\-1).getY()\-path.get("P").getY()) == false)
		        .mapToObj(("I")->path.get("I"))
		        .collect(Collectors.toList());
		    Area->Generators->FloorGenerator floorGenerator = newArea.getGenerator();
		    obstructions.parallelStream()
		      .filter(("S")->"S".getTerrain() != null && "S".getTerrain().isPassable(0,0) == false)
		      .forEach(("S")->"{newArea.changeTerrain(S.getTerrain(),null);S.setTerrain(null);}");
		    obstructions.parallelStream()
		      .filter(("S")->"S".isPassable(0,0) == false)
		      .forEach(("S")->"{Tiles.Floor newTile;do{newTile = floorGenerator.generateFloor(S.getX(),S.getY(),newArea.getParent());}while(newTile.isPassable(0,0) == false);newArea.replace(S,newTile);}");
		    if obstructions.isEmpty() == false {
		      newArea.clearAbsolutePathBetweenEntryPoints(i,j);
		      newArea.getAbsolutePathBetweenEntryPoints(i,j);
		    }
		  }
		}
      }
    }
    String areaClassName = ^declarationToken->"areaName";
    String areaName = areaClassName.toLowerCase();
    Double chance = Double.parseDouble('declarationToken->"chance"')/100.0\+previousChance;
    Areas->'mapName' += class areaClassName /Area/ {}
    Areas->'mapName'->'areaClassName' += class Generators // {}
    \addGeneratorSuperClass(Areas->'mapName'->'areaClassName'->Generators);
    generatorIndices.get(mapName).put(areaClassName,0);
    ~String entryPointTileName = null;
    ~Integer lowEntryBound = 0;
    ~Integer upperEntryBound = -1;
    declarationToken : element : area_element {
      element : atom : entryPointGeneration {
        lowEntryBound = Integer.parseInt('atom->"range"->"lowerBound"')\+1;
        upperEntryBound = Integer.parseInt('atom->"range"->"upperBound"')\+1;
        entryPointTileName = 'atom->"tile_names"';
      }
    }
    if upperEntryBound == -1 {
      upperEntryBound = upperEntryBound \+ 1;
    }
    if declarationToken->"bluePrintName" != null {
      # \readBlueprint(declarationToken,'declarationToken->"bluePrintName"',mapName, areaClassName,lowEntryBound,upperEntryBound, entryPointTileName, chance); #
    }
    else {
      ~Integer generatorIndex = generatorIndices.get(mapName).get(areaClassName);
      String generatorName = "Generator"\+generatorIndex;
      String generatorVariableName = "generator"\+generatorIndex;
      if generatorIndex == 0 {
        Areas->'mapName'->AnyGenerator->*"generate".appendToBody(|
          if "chance" <= 'chance' {
              'generatorName.toLowerCase()'.generate("newArea");
              \joinEntryPoints("newArea"); 
              return "newArea";
          }|);
      }
      else {
        Areas->'mapName'->AnyGenerator->*"generate".appendToBody(|
          else if "chance" <= 'chance' {
              'generatorName'.generate("newArea");
              \joinEntryPoints("newArea");
              return "newArea";
          }|);
      }
      Integer floorWidth = Integer.parseInt('declarationToken->"defaultSize"->"patchWidth"');
      Integer floorHeight = Integer.parseInt('declarationToken->"defaultSize"->"patchHeight"');
      Integer floorSize = floorWidth\*floorHeight;
      GeneratorMapValues generatorValues = \addGeneratorClass(Areas->'mapName'->'areaClassName'->Generators,generatorName,
                                              floorWidth,floorHeight,floorSize);
      generatorIndices.get(mapName).put(areaClassName,generatorIndex\+1);
      Areas->'mapName'->'areaClassName'->Generators += class generatorName / Area->Generators->FloorGenerator / Area->TileGenerator{
	      void generate(Area newArea){
	        newArea.setGenerator(this);
	        \generateAt(0,0,newArea);
	      }
	      
	    }
	  Areas->'mapName'->'areaClassName'->Generators->'generatorName' += class FloorGenerator //Area->TileGenerator {
	      void generateAt(int x, int y, Area newArea){
            newArea.add(new Tiles->'mapName'->'declarationToken->"defaultTileName"'(x,y,newArea.getParent()));
          }
          Tiles->Floor generateFloor(int x, int y, Environment parent){
            return new Tiles->'mapName'->'declarationToken->"defaultTileName"'(x,y,parent);
          }
          
          void setInnerFloor(Area->FloorChoice choice){}
          void setLeftSideFloor(Area->FloorChoice choice){}
          void setUpSideFloor(Area->FloorChoice choice){}
          void setRightSideFloor(Area->FloorChoice choice){}
          void setDownSideFloor(Area->FloorChoice choice){}
          void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}
	    }
	  generatorValues.addDefaultVariablesAndMethods('generatorName',
	    Areas->'mapName'->'areaClassName'->Generators->'generatorName'->'"FloorGenerator"');
	  Areas->'mapName'->AnyGenerator += ~Areas->'mapName'->'areaClassName'->Generators->'generatorName' 'generatorVariableName' = null;
      Areas->'mapName'->AnyGenerator->*.appendToBody(|'generatorVariableName' = new Areas->'mapName'->'areaClassName'->Generators->'generatorName'();|);
      
	  declarationToken : element : patch_element {
	    Areas->'mapName'->'areaClassName'->Generators->'generatorName'->*"generateAt".appendToBody(
	      \getPatchElement(element,mapName,Areas->'mapName'->'areaClassName'->Generators,'generatorName'));
	  }
	  Areas->'mapName'->'areaClassName'->Generators->'generatorName'->*"generateAt".appendToBody(|
             "generationPoints".forEach(("P")->"P".generate("newArea"));|);
	  generatorValues.finish();
    }
    Body floorSwitchBody = new Body ();
    Integer numberOfFloorTiles = floorTiles.size();
    Areas->'mapName'->'areaClassName'->Generators += class FloorGenerator /Area->Generators->FloorGenerator/Area->TileGenerator {
        Tiles->Floor generateFloor(int x, int y, Environment parent){
          Tiles->Floor result = null;
        }
        void generateAt(int x, int y, Area newArea){
          newArea.add(\generateFloor(x,y,newArea.getParent()));
        }
        void setInnerFloor(Area->FloorChoice choice){}
        void setLeftSideFloor(Area->FloorChoice choice){}
        void setUpSideFloor(Area->FloorChoice choice){}
        void setRightSideFloor(Area->FloorChoice choice){}
        void setDownSideFloor(Area->FloorChoice choice){}
        void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}
      }
    Areas->'mapName'->'areaClassName'->Generators->FloorGenerator->*"generateFloor".appendToBody(|switch Range.getRandom(0,'numberOfFloorTiles') `floorSwitchBody`|);
    ~Integer floorIndex = 0;
    for String floorName: floorTiles {
      Integer floorIndexValue = floorIndex;
      floorSwitchBody.add(|case 'floorIndexValue' { "result" = new Tiles->'mapName'->'floorName'("x","y","parent"); "break"; }|);
      floorIndex \+= 1;
    }
    Areas->'mapName'->'areaClassName'->Generators->FloorGenerator->*"generateFloor".appendToBody(|return "result";|);
    
    return chance;
  }
> Body getPatchElement(%T patchElement, String mapName, Class generatorsClass, String generatorName ){
    Body result = new Body ();
    GeneratorMapValues values = generatorMapValues.get(generatorsClass).get(generatorName);
    ArrayList< %T > patchElements = new ArrayList < %T >();
    patchElements.add(patchElement);
	return \makeTerrainBody(patchElements,mapName,generatorName,values,false,values.getLayoutSize());
  }
> Statement addAreaEntryPoint(Integer pointX,Integer pointY, String mapName, String entryPointTileName,Integer entryPointIndex) {
    return |if "chosenEntryPoints".contains('entryPointIndex') {
        "newArea".add(new EntryPoints->'mapName'->'entryPointTileName'('pointX','pointY',"parent"));
      }|;
  }
> void addPatchProbabilities(%T atom, Body acceptor){
     
    ~Double terrainChanceBuilder = 0.0;
    ~Boolean isFirst = true;
    atom : quark : probability {
      Parameters amounts = new Parameters ();
      ~double times = 0.0;
      quark : amount : amount {
        amounts.add(|'amount'|);
        times \+= 1.0;
      }
      Double terrainChanceValue = Double.parseDouble('quark->"percent"')\*times\/100.0\+terrainChanceBuilder;
      if isFirst {
        if amounts.size() == 1 {
          acceptor.add(|if "terrainChance" <= 'terrainChanceValue' {
           "numberOfTerrainPoints" = `amounts`;
          }|);
        }
        else {
          acceptor.add(|if "terrainChance" <= 'terrainChanceValue' {
           "numberOfTerrainPoints" = Range.select(new Integer(`amounts`)[]);
          }|);
        }
      }
      else {
        if amounts.size() == 1 {
          acceptor.add(|else if "terrainChance" <= 'terrainChanceValue' {
            "numberOfTerrainPoints" = `amounts`;
              }|);
        }
        else {
          acceptor.add(|
            else if "terrainChance" <= 'terrainChanceValue' {
              "numberOfTerrainPoints" = Range.select(new Integer(`amounts`)[]);
            }|);
        }
      }
      isFirst = false;
      terrainChanceBuilder = terrainChanceValue;
    }
  }

> Body makeTerrainBody(ArrayList< %T > patchElements,String mapName, String generatorName, GeneratorMapValues generatorValues, boolean hasReturnValue, Integer layoutSize){
    ~Body result = null;
    ~Integer choiceCount = 0;
    for %T quark : patchElements {
      choiceCount \+= 1;
    }
    
    Body terrainSwitchBody = new Body ();
    if choiceCount > 1 {
      Integer choiceCountValue = choiceCount;
      result = new Body ();
      result.add(| 
        switch Range.getRandom(0,'choiceCountValue') `terrainSwitchBody` |);
    }
    ~Integer choiceIndex = 0;
    for %T quark : patchElements {
      Body innerSwitchBody = new Body ();
      ~int segmentation = 0;
      quark : width : patchWidth {
        segmentation\+=1;
      }
      String terrainTileName = ^quark->"tile_names";
      String terrainTileNameValue = generatorValues.addTerrainTile('mapName','generatorName','terrainTileName', quark->"patch_goto");
      ArrayList<Integer> startXs = new ArrayList<Integer>();
      ArrayList<Integer> startYs = new ArrayList<Integer>();
      ArrayList<Integer> endXs = new ArrayList<Integer>();
      ArrayList<Integer> endYs = new ArrayList<Integer>();
      if quark->"patchWidth" == null {
        startXs.add(1);
        startYs.add(1);
        endXs.add(1);
        endYs.add(1);
      }
      else {
        quark : width : patchWidth {
          startXs.add(\getPatchDimension(width,false));
          endXs.add(\getPatchDimension(width,true));
        }
        quark : height : patchHeight {
          startYs.add(\getPatchDimension(height,false));
          endYs.add(\getPatchDimension(height,true));
        }
      }
      ~int segmentIndex = 0;
      ~int choiceMaxWidth = 0;
      ~int choiceMaxHeight = 0;
      for Integer i < startXs.size() {
        Body caseBody = new Body ();
        caseBody.add(\getTerrainPatch("this",terrainTileNameValue,startXs.get(i),endXs.get(i),startYs.get(i),endYs.get(i)));
        if endXs.get(i) > choiceMaxWidth {
          choiceMaxWidth = endXs.get(i);
        }
        if endYs.get(i) > choiceMaxHeight {
          choiceMaxHeight = endYs.get(i);
        }
        if hasReturnValue {
          caseBody.add(|return 1;|);
        }
        else if segmentation > 1 {
          caseBody.add(|"break";|);
        }
        if segmentation > 1 {
          Integer segmentIndexValue = segmentIndex;
          innerSwitchBody.add(|
            case 'segmentIndexValue' `caseBody`|);
          segmentIndex\+=1;
        }
        else {
          innerSwitchBody.add(caseBody);
        }
      }
      Body terrainCaseBody;
      if quark->"patch_relative_position" != null {
        if quark->"patch_relative_position"->"offside" != null && choiceMaxWidth==1 && choiceMaxHeight==1 {
          terrainCaseBody = {
            \generationPoints = Streamer.performOnce(
              'new Integer(generatorValues.getLayoutSize())'\+
              Range.getRandom(0,'new Integer(2*generatorValues.getWidth()\+2*generatorValues.getHeight())'),
              \generationPoints,("P")->"P".setGenerator('terrainTileNameValue'));};
        }
        else {
          String subGeneratorName = generatorValues.getNextSubGenerator();
          Integer patchCaseWidth = choiceMaxWidth;
          Integer patchCaseHeight = choiceMaxHeight;
          Integer patchCaseSize = patchCaseWidth\*patchCaseHeight;
          generatorValues.getAcceptorClass().getSubClass(generatorName).addSubClass(
            class subGeneratorName // Area->TileGenerator {
              ~Stream<Area\>FloorChoice> generationPoints = null; 
              void generateAt(int startX, int startY, Area newArea){
                generationPoints = IntStream.range(0,'patchCaseSize').parallel().mapToObj(("I")->
                  new Area->FloorChoice('generatorValues.getAcceptorClass().getSubClass(generatorName).getFullName()'->'subGeneratorName'.this,
                     "I",startX,startY,'patchCaseWidth','patchCaseHeight'));
              }
              void addOneAnywhere(Area->TileGenerator generator){
                \generationPoints = Streamer.performOnce(Range.getRandom(0,'patchCaseSize'),generationPoints,("P")->"P".setGenerator('terrainTileNameValue'));
              }
              
              void setInnerFloor(Area->FloorChoice choice){}
              void setLeftSideFloor(Area->FloorChoice choice){}
              void setUpSideFloor(Area->FloorChoice choice){}
              void setRightSideFloor(Area->FloorChoice choice){}
              void setDownSideFloor(Area->FloorChoice choice){}
              void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}
            }
          );
          if segmentation > 1 {
            Integer segmentationValue = segmentation;
            generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName).getMethod("generateAt").appendToBody({
              switch Range.getRandom(0,'segmentationValue') `innerSwitchBody`
              });
          }
          else {
            generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName).getMethod("generateAt").appendToBody(innerSwitchBody);
          }
          generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName).getMethod("generateAt").appendToBody(|
	        \generationPoints.forEach(("P")->"P".generate("newArea"));|);
	      for Integer i < startXs.size() {
	        \addFillMethod(
               generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName),
               endXs.get(i),endYs.get(i),patchCaseWidth,patchCaseHeight);
	        }
          if quark->"patch_relative_position"->"offside" != null {
            terrainCaseBody = {
              \generationPoints = Streamer.performOnce(
                'new Integer(generatorValues.getLayoutSize())'\+Range.getRandom(0,'new Integer(2*generatorValues.getWidth()\+2*generatorValues.getHeight())'),
                \generationPoints,
                ("P")->"P".setGenerator(new 'subGeneratorName'()));};
            segmentation = 1; 
          }
          else {
            Integer relativeStartX = \getPatchDimension(quark->"patch_relative_position"->"patchWidth", true);
            Integer relativeEndX   = \getPatchDimension(quark->"patch_relative_position"->"patchWidth", true);
            Integer relativeStartY = \getPatchDimension(quark->"patch_relative_position"->"patchHeight", false);
            Integer relativeEndY   = \getPatchDimension(quark->"patch_relative_position"->"patchHeight", true);
            if relativeStartX == relativeEndX && relativeStartY == relativeEndY {
              terrainCaseBody = {
                \generationPoints = Streamer.performOnce(
                  'new Integer(generatorValues.getNextRelativePosition(relativeEndX,relativeEndY))',
                  \generationPoints,
                  ("P")->"P".setGenerator(new 'subGeneratorName'()));};
              segmentation = 1;
            }
            else {
              Integer relativeSize = (relativeEndX\-relativeStartX\+1)\*(\relativeStartX\-relativeEndX\+1);
              terrainCaseBody = new Body ();
              for Integer x < (relativeEndX\-relativeStartX) {
                for Integer y < (relativeEndY\-relativeStartY) {
                  terrainCaseBody.add(|
                    \generationPoints = Streamer.performOnce(
                      'new Integer(generatorValues.getNextRelativePosition(x,y))',
                      \generationPoints,
                      ("P")->"P".setGenerator(new 'subGeneratorName'()));
                    \break;|);
                }
              }
              segmentation = relativeSize;
            }
          }
        }
      }
      else {
        for Integer i < startXs.size() {
	      \addFillMethod(
	        generatorValues.getAcceptorClass().getSubClass(generatorName),
            endXs.get(i),endYs.get(i),generatorValues.getWidth(),generatorValues.getHeight());
	    }
        terrainCaseBody = innerSwitchBody;
      }
      if choiceCount > 1 {
        if segmentation > 1 {
          Integer segmentationValue = segmentation;
          terrainSwitchBody.add(| 
            switch Range.getRandom(0,'segmentationValue') `terrainCaseBody` |);
        }
        else {
          terrainSwitchBody.add(terrainCaseBody);
        }
        if hasReturnValue {
            terrainSwitchBody.add(|return 0;|);
        }
        else {
          terrainSwitchBody.add(|\break;|);
        }
      }
      else {
        if segmentation > 1 {
          result = new Body ();
          Integer segmentationValue = segmentation;
          result.add(| 
            switch Range.getRandom(0,'segmentationValue') `terrainCaseBody` |);
        }
        else {
          result = terrainCaseBody;
        }
      }
      choiceIndex \+= 1;
    }
    if hasReturnValue && choiceCount > 1 {
      result.add({return 0;});
    }
    return result;
  }
> Integer getPatchDimension(%T dimension, boolean isUpper){
    if isUpper {
      if dimension->"upperBound" != null {
        return Integer.parseInt('dimension->"upperBound"');
      }
      else {
        return Integer.parseInt('dimension');
      }
    }
    else {
      if dimension->"lowerBound" != null {
        return Integer.parseInt('dimension->"lowerBound"');
      }
      else {
        return Integer.parseInt('dimension');
      }
    }
  }
> Statement getTerrainPatch(String generator,String tileName, Integer startX, Integer endX, Integer startY, Integer endY){
    if endX == 1 && endY == 1 {
      return |'generator'.addOneAnywhere('tileName');|;
    }
    else { 
      if startX == endX {
        if startY == endY {
          return |'generator'."fill"+'endX'+"x"+'endY'('endX','endY','tileName');|;
        }
        else {
          return |'generator'."fill"+'endX'+"x"+'endY'('endX',Range.getRandom('new Integer(startY\-1)','endY'),'tileName');|;
        }
      }
      else {
        if startY == endY {
          return |'generator'."fill"+'endX'+"x"+'endY'(Range.getRandom('new Integer(startX\-1)','endX'),'endY','tileName');|;
        }
        else {
          return |'generator'."fill"+'endX'+"x"+'endY'(Range.getRandom('new Integer(startX\-1)','endX'),Range.getRandom('new Integer(startY\-1)','endY'),'tileName');|;
        }
      }
    }
  }
> void addFillMethod(Class acceptorClass, int width, int height, Integer parentWidth, Integer parentHeight){
    if width == 1 && height == 1 {
      return void;
    }
    String methodName = "fill"\+width\+"x"\+height;
    if acceptorClass.getMethod(methodName) == null {
      acceptorClass.addMethod(void 'methodName'(int width, int height, Area->TileGenerator generator){
          int x = Range.getRandom(0,'new Integer(parentWidth\-width\+1)');
          int y = Range.getRandom(0,'new Integer(parentHeight\-height\+1)');
          \generationPoints = Streamer.perform(
                      ("I")->"I"<'new Integer(parentWidth*parentHeight)' && "I"%'parentWidth'>=x&&"I"%'parentWidth'<x\+width&& "I"/'parentHeight'>=y&&"I"/'parentHeight'<y\+height,
                      \generationPoints,
                      ("P")->"P".setGenerator(generator));
        });
    }
  }
  void display(){
    floorTiles.parallelStream().forEach(("T")->"T".display());
    entryPoints.parallelStream().forEach(("T")->"T".display());
  }
  void undisplay(){
    floorTiles.parallelStream().forEach(("T")->"T".undisplay());
    entryPoints.parallelStream().forEach(("T")->"T".undisplay());
  }
  Tiles->Floor getTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->Floor getFloorTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->MonsterDen getMonsterDen(Tile->Id findId){
    if tileMap.has(findId) == false {
      return null;
    }
    else {
      return (Tiles->MonsterDen)Range.select(tileMap.getAll(findId));
    }
  }
  Tiles->MonsterDen getMonsterDen(Predicate<Tile> findCriteria){
    return (Tiles->MonsterDen)\tiles.parallelStream().filter(findCriteria).findAny().orElse(null);
  }
  int getDistanceToArea(Area area){
    if this == area {
      return 0;
    }
    return IntStream.range(1,furthestDistanceToArea).parallel()
      .filter(("I")->areaDistances.get("I").contains(area)).findFirst().orElse(-1);
  }
  void findDistance(Area findArea){
    IntStream.range(0,furthestDistanceToArea).filter(("I")->areaDistances.get("I").parallelStream()
        .flatMap((\area)->area.entryPoints.parallelStream())
        .filter((\entryPoint)->\entryPoint.getSister()!= null)
        .anyMatch((\entryPoint)->\entryPoint.getSister().getArea() == findArea))
      .findFirst().ifPresent(("I")->\setDistanceToArea("I"\+1,findArea));
  }
  void setDistanceToArea(int distance, Area area){
    if distance > furthestDistanceToArea {
      furthestDistanceToArea = distance;
    }
    areaDistances.get(distance).add(area);
  }
  Tiles->EntryPoint getEntryPoint(Integer index){
    return entryPoints.get(index);
  }
  Tile getTile(Tile->Id findId){
    if tileMap.has(findId) == false {
      return null;
    }
    else {
      return Range.select(tileMap.getAll(findId));
    }
  }
  Tile getTile(Tiles->Floor->Id findId){
    if floorMap.has(findId) == false {
      return null;
    }
    else {
      return Range.select(floorMap.getAll(findId));
    }
  }
  Tile getTile(Tiles->Terrain->Id findId){
    if terrainMap.has(findId) == false {
      return null;
    }
    else {
      return Range.select(terrainMap.getAll(findId));
    }
  }
  Boolean load(){
    IntStream.range(0,32).forEach(("A")->areaDistances.add(new HashSet<Area>()));
    areaDistances.get(0).add(this);
    IntStream.range(0,'tickEventArrayLength').parallel().forEach(("C")->tickEvents["C"] = new Area->Event->Tick->Listener());
    tiles.stream().forEach(("T")->"T".load());
    return true;
  }
  Boolean tick(Double millisSinceLastFrame){
    tiles.stream().forEach((\T)->\T.tick(millisSinceLastFrame));
    tickEvents[currentTickPosition].tick(millisSinceLastFrame);
    if currentTickPosition >= 'new Integer(tickEventArrayLength\-1)' {
      currentTickPosition = 0;
    }
    else {
     "++currentTickPosition";
    }
    return true;
  }
  Boolean join(Tiles->EntryPoint yourEntryPoint){
    Tiles->EntryPoint myEntryPoint = entryPoints.stream()
      .filter(("E")->"E".getSister()==null||"E".getSister().getArea()==null)
      .findAny().orElse(null);
    if myEntryPoint != null && yourEntryPoint != null {
      myEntryPoint.setSister(yourEntryPoint);
      yourEntryPoint.setSister(myEntryPoint);
      \getParent().getAreas().stream()
        .forEach((\A)->\A.findDistance(yourEntryPoint.getArea()));
      yourEntryPoint.getArea().getParent().getAreas().stream()
        .forEach((\A)->\A.findDistance(myEntryPoint.getArea()));
      return true;
    }
    else {
      entryPointsListeners.add("(newEntryPoint)->{newEntryPoint.setSister(yourEntryPoint);yourEntryPoint.setSister(newEntryPoint);newEntryPoint.getArea().getParent().getAreas().stream().forEach((A)->A.findDistance(yourEntryPoint.getArea()));yourEntryPoint.getArea().getParent().getAreas().stream().forEach((A)->A.findDistance(newEntryPoint.getArea()));return false;}");
      return false;
    }
  }
  void addEvent(Integer offset, Area->Event->Tick event) {
    tickEvents[(currentTickPosition\+offset)%'tickEventArrayLength'].add(event);
  }
  Boolean add(Entity entity){
    if \getParent() != null && entity.getIsPlayerAffiliated() {
      \getParent().addActiveArea(this);
    }
    return entities.add(entity);
  }
  Boolean remove(Entity entity){
    if \getParent() != null && entity.getIsPlayerAffiliated() {
      \getParent().removeActiveArea(this);
    }
    return entities.remove(entity);
  }
  void replace(Tile toRemove, Tile toAdd){
    \remove(toRemove);
    \add(toAdd);
  }
  Boolean add(Tile newTile){
    newTile.setArea(this);
    if newTile.getX() \+ newTile.getWidth() > width {
      width = newTile.getX() \+ newTile.getWidth();
    }
    if newTile.getY() \+ newTile.getHeight() > height {
      height = newTile.getY() \+ newTile.getHeight();
    }
    tileMap.add(newTile);
    if "newTile.getId() instanceof Tiles.EntryPoint.Id" {
      synchronized entryPoints {
        if entryPointsListeners.isEmpty() == false {
          ~boolean canContinue = true;
          while canContinue && entryPointsListeners.isEmpty() == false {
            canContinue = entryPointsListeners.remove(0).listen((Tiles.EntryPoint)newTile);
          }
        }
        entryPoints.add(((Tiles.EntryPoint)newTile));
      }
    }
    if "newTile.getId() instanceof Tiles.Floor.Id" {
      
      floorMap.add((Tiles->Floor)newTile);
      synchronized layout {
        floorTiles.add((Tiles->Floor)newTile);
        if layout.containsKey(newTile.getX()) == false {
          layout.put(newTile.getX(), new HashMap<Integer,Tiles\>Floor>());
        }
        layout.get(newTile.getX()).put(newTile.getY(),"(Tiles.Floor)newTile");
      }
    }
    else if "newTile.getId() instanceof Tiles.Terrain.Id" {
      terrainMap.add((Tiles->Terrain)newTile);
    }
    if \parent != null {
      \parent.add(newTile);
    }
    return tiles.add(newTile);
  }
  void changeFloorLocation(Integer oldX, Integer oldY, Integer newX, Integer newY){
    if layout.containsKey(newX) == false {
      layout.put(newX,new HashMap<Integer, Tiles\>Floor>());
    }
    layout.get(newX).put(newY, layout.get(oldX).remove(oldY));
  }
  void changeTerrain(Tiles\>Terrain oldTile, Tiles\>Terrain newTile){
    if oldTile != null {
      terrainMap.remove(oldTile);
    }
    if newTile != null {
      terrainMap.add(newTile);
    }
  }
  Boolean remove(Entity entity){
    return entities.remove(entity);
  }
  Boolean remove(Tile oldTile){
  	oldTile.getNeighbours().stream().forEach(("N")->"N".resetNeighbour(oldTile));
    oldTile.setArea(null);
    tileMap.remove(oldTile);
    if "oldTile.getId() instanceof Tiles.EntryPoint.Id" {
      synchronized entryPoints {
        entryPoints.remove(oldTile);
      }
    }
    else if "oldTile.getId() instanceof Tiles.Floor.Id" {
      floorMap.remove((Tiles.Floor)oldTile);
      if layout.containsKey(oldTile.getX()) {
        layout.get(oldTile.getX()).remove(oldTile.getY());
      }
    }
    else if "oldTile.getId() instanceof Tiles.Terrain.Id" {
      terrainMap.remove((Tiles.Terrain)oldTile);
    }
    return tiles.remove(oldTile);
  }
  boolean has(Predicate<Tile> criteria){
    return tiles.parallelStream().anyMatch(criteria);
  }
  Tiles->Floor getUnexploredPoint(Entity explorer){
    return entryPoints.stream()
      .filter(
        \tile\->( \tile.getSister() == null || \tile.getSister().getArea() == null || explorer.hasExplored(\tile.getSister().getArea()) == false ))
      .filter(\tile\->\tile.hasOccupant(explorer) == false)
      .findAny().orElse(null);
  }
  List<Entity> collectEntities(Predicate<Entity> predicate){
    return entities.parallelStream().filter(predicate).collect(Collectors.toList()); 
  }
  List<Entity> getEntitiesWithin(Environment->Position position, Float range){
    return \collectEntities((\entity)->\entity.getLocation().getDistanceTo(position) <= range);
  }
  List<Entity> getEntitiesWithin(Environment->Position position, Float range, Predicate<Entity> criteria){
    return entities.parallelStream().filter(criteria).filter((\entity)->\entity.getLocation().getDistanceTo(position) <= range)
             .collect(Collectors.toList());
  }
  Entity getClosestEntity(Environment->Position position, Predicate<Entity> criteria){
    return entities.stream().filter(criteria).sorted(new Entity->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tiles->EntryPoint getClosestEntryPoint(Environment->Position position){
    return entryPoints.stream().sorted(new Tile->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tiles->Terrain getClosestTile(Environment->Position position, Tiles->Terrain->Id terrainId){
    if terrainMap.has(terrainId) == false {
      return null;
    }
    return terrainMap.getAll(terrainId).stream().sorted(new Tile->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tile getClosestTile(Environment->Position position, Tile->Id tileId){
    if tileMap.has(tileId) == false {
      return null;
    }
    return tileMap.getAll(tileId).stream().sorted(new Tile->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tile getClosestTile(Environment->Position position, Predicate<Tile> criteria){
    return IntStream.range(0,furthestDistanceToArea).parallel().boxed()
      .flatMap(("I")->\getAllTilesAsStream("I"))
      .filter(criteria)
      .sorted(new Tile->Comparators->Distance->Ascending->Complex(position)).findFirst().orElse(null);
  }
  void getAllTiles(int distance,ArrayList<Tile> collector){
    areaDistances.get(distance).stream().forEach(("A")->collector.addAll("A".tiles));
  }
  List<Tile> getAllTiles(int distance){
    return areaDistances.get(distance).parallelStream().flatMap(("A")->"A".tiles.parallelStream()).collect(Collectors.toList());
  }
  Stream<Tile> getAllTilesAsStream(int distance){
    return areaDistances.get(distance).parallelStream().flatMap(("A")->"A".tiles.parallelStream());
  }
  void add(Building building) {
    buildings.add(building);
  }
  
  Boolean isWithin(Environment->Position otherPosition){
    return otherPosition.getX() >= 0 && otherPosition.getX() < "width" && otherPosition.getY() >= 0 && otherPosition.getY() < "height";
  }
  Tiles->EntryPoint getEntryPointToward(Area area){
    if sisterAreas.containsKey(area) {
      return sisterAreas.get(area);
    }
    else {
      Tiles->EntryPoint found = entryPoints.parallelStream().filter(("E")->"E".getSister()!=null&&"E".getSister().getArea() == area)
        .findAny().orElseGet(
          ("")->
          entryPoints.parallelStream()
            .filter(("E")->"E".getSister()!=null&&"E".getSister().getArea() != null)
            .filter(("E")->"E".getSister().getArea().canGetToAreaFrom(area,"E".getSister(),Collections.synchronizedSet("new HashSet<Area>(){{add(Area.this);}}"))).findFirst().orElse(null)
                 
        );
      if found!=null{
        sisterAreas.put(area,found);
      }
      return found;
    }
  }
  Boolean canGetToAreaFrom(Area findArea,Tiles->EntryPoint previousEntryPoint, Set<Area> investigated){
    if this == findArea {
      return true;
    }
    if investigated.add(this) {
      return entryPoints.parallelStream()
        .filter((\entryPoint)->\entryPoint!=previousEntryPoint&&
                (\entryPoint)->\entryPoint.getSister()!=null&&
                (\entryPoint)->\entryPoint.getSister().getArea()!=null)
        .anyMatch((\entryPoint)->\entryPoint.getSister().getArea().canGetToAreaFrom(findArea,\entryPoint.getSister(),investigated));
    }
    else {
      return false;
    }
  }
  ArrayList<Tiles\>Floor> getAbsolutePathBetweenEntryPoints(Integer startPoint, Integer endPoint){
    synchronized entryToEntryPaths {
      if entryToEntryPaths.containsKey(startPoint) {
        if entryToEntryPaths.get(startPoint).containsKey(endPoint) {
          return entryToEntryPaths.get(startPoint).get(endPoint);
        }
        else {
          entryToEntryPaths.put(endPoint, new HashMap<Integer, ArrayList<Tiles\>Floor>>());
        }
      }
      else {
        entryToEntryPaths.put(startPoint, new HashMap<Integer, ArrayList<Tiles\>Floor>>());
      }
    }
    Tiles->Floor endTile = entryPoints.get(endPoint);
    Tiles->Floor tile = entryPoints.get(startPoint);
    List<Tiles\>Floor\>Path> tried = new ArrayList<Tiles\>Floor\>Path>();
    Tiles->Floor->Path->Ways ways = new Tiles->Floor->Path->Ways(endTile);
    Set<Tiles\>Floor> investigated = new HashSet<Tiles\>Floor>();
    investigated.add(null);
    Iterator<Tiles\>Floor\>Path> paths = Stream<Tiles\>Floor\>Path>
      .iterate(
        new Tiles->Floor->Path(null,tile,endTile),
        P => {
          P.getTile().getNeighbours().stream()
            .filter ( N => investigated.add(N))
            .forEach( N => ways.extend(P,N));
          return ways.pollFirst();
          })
      .iterator();
    Tiles->Floor->Path path = paths.next();
    tried.add(path);
    while path.getTile() != endTile && ways.isEmpty() == false {
      path = paths.next();
      tried.add(path);
    }
    
    if path.getTile() == endTile {
      List<Tiles\>Floor> pathAsList = path.collect();
      synchronized entryToEntryPaths {
        entryToEntryPaths.get(startPoint).put(endPoint, pathAsList);
        entryToEntryPaths.get(endPoint).put(startPoint, Collections.reverse(pathAsList));
      }
      return pathAsList;
    }
    else {
      System.err.println('' "Could not make path!" '');
      tried.stream().forEach("System.err::println");
      return null;
    }
  }
  void clearAbsolutePathBetweenEntryPoints(Integer startPoint, Integer endPoint){
    synchronized entryToEntryPaths {
      if entryToEntryPaths.containsKey(startPoint) {
        if entryToEntryPaths.get(startPoint).containsKey(endPoint) {
          entryToEntryPaths.get(startPoint).remove(endPoint);
        } 
      }
      if entryToEntryPaths.containsKey(endPoint) {
        if entryToEntryPaths.get(startPoint).containsKey(startPoint) {
          entryToEntryPaths.get(endPoint).remove(startPoint);
        } 
      }
    }
  }
  
  interface TileGenerator //{
    void generateAt(int x, int y, Area acceptor){}
    void setInnerFloor(Area->FloorChoice choice){}
    void setLeftSideFloor(Area->FloorChoice choice){}
    void setUpSideFloor(Area->FloorChoice choice){}
    void setRightSideFloor(Area->FloorChoice choice){}
    void setDownSideFloor(Area->FloorChoice choice){}
    void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}
  }
  class FloorChoice // Indexable {
    ~TileGenerator generator = Area.Generators.NonGenerator.non;
    ~Area->TileGenerator parent = null;
    int index;
    int x = 0;
    int y = 0;
    FloorChoice *(Area->TileGenerator initialParent, int initialIndex, int initialX, int initialY, int initialWidth, int initialHeight) {
      parent = initialParent;
      index = initialIndex;
      if index<initialWidth*initialHeight{
        x = initialX \+ index%initialWidth;
        y = initialY \+ index/initialHeight;
        parent.setInnerFloor(this);
      }
      else {
        initialIndex -= initialWidth*initialHeight;
        if initialIndex < initialWidth {
          x = initialX \+ initialIndex;
          y = initialY \- 1;
          parent.setDownSideFloor(this);
        }
        else {
          initialIndex -= initialWidth;
          if initialIndex < initialWidth {
            x = initialX \+ initialIndex;
            y = initialY \+ initialHeight;
            parent.setUpSideFloor(this);
          }
          else {
            initialIndex -= initialWidth;
            if initialIndex < initialHeight {
              x = initialX \- 1;
              y = initialY \+ initialIndex;
              parent.setLeftSideFloor(this);
            }
            else {
              initialIndex -= initialHeight;
              if initialIndex < initialHeight {
                x = initialX \+ initialWidth;
                y = initialY \+ initialIndex;
                parent.setRightSideFloor(this);
              }
              else {
                initialIndex -= initialHeight;
                parent.setRelativeFloor(this, initialIndex, initialX, initialY);
              }
            }
          }
        }
      }
    }
    FloorChoice setGenerator(TileGenerator newGenerator){
      generator = newGenerator;
      return this;
    }
    void generate(Area newArea){
      generator.generateAt(x,y,newArea);
    } 
  }
  class TerrainChoice //TileGenerator {
    Tiles->Floor->Factory floorFactory = null;
    Tiles->Terrain->Factory terrainFactory = new NullTerrainFactory();
    
    void generateAt(int x, int y, Area acceptor){
      Tiles->Floor newFloorTile = floorFactory.create(x,y,acceptor.getParent());
      newFloorTile.setTerrain(terrainFactory.create(newFloorTile));
      acceptor.add(newFloorTile);
    }
    void setInnerFloor(Area->FloorChoice choice){}
    void setLeftSideFloor(Area->FloorChoice choice){}
    void setUpSideFloor(Area->FloorChoice choice){}
    void setRightSideFloor(Area->FloorChoice choice){}
    void setDownSideFloor(Area->FloorChoice choice){}
    void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}

    class NullTerrainFactory // Tiles->Terrain->Factory {
      Tiles->Terrain create(Tiles->Floor parentFloorTile){
        return null;
      }
      Tiles->Terrain create() {
		return null;
	  }
    }
  }
}
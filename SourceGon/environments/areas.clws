import area_regions.clws
< Collector : java.util.stream;
class 'packageName'.environments Areas {
}
class 'packageName'.environments Area Environment->Position EntryPointJoinable {
> Integer tickEventArrayLength = 256;
  class Id // {
  }
  enum Imports //{
    Collector collector = null;
  }
  interface EntryPointListener // {
    Boolean listen(Tiles->EntryPoint newEntryPoint){}
  }
  Area->Id getId(){
    return null;
  }
  ~ArrayList<Tile> tiles = new ArrayList<Tile>();
  ~Map<Integer, Map<Integer, Tiles\>Floor>> layout = new HashMap<Integer, Map<Integer, Tiles\>Floor>>();
  ~ArrayList<Tiles\>EntryPoint> entryPoints = new ArrayList<Tiles\>EntryPoint>();
  ~ArrayList<EntryPointListener> entryPointsListeners = new ArrayList<EntryPointListener>();
  ~Map<Tile\>Id, ArrayList<Tile>> tileMap = new HashMap<Tile\>Id, ArrayList<Tile>>();
  ~ArrayList<Tiles\>Floor> floorTiles = new ArrayList<Tiles\>Floor>();
  ~Map<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>> floorMap = new HashMap<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>>();
  ~Map<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>> terrainMap = new HashMap<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>>();
  
  ~Map<Integer, Map<Integer, ArrayList<Tiles\>Floor>>> entryToEntryPaths = new HashMap<Integer, Map<Integer, ArrayList<Tiles\>Floor>>>();
  ~Map<Area, Tiles\>EntryPoint> sisterAreas = new HashMap<Area, Tiles\>EntryPoint>();
  ~Map<Integer, Set<Area>> areaDistances = new HashMap<Integer, Set<Area>>();
  ~int furthestDistanceToArea = 0; 
  
  ~Entity->List entities = new Entity->List();
  ~Integer width = 0;
  ~Integer height = 0;
  ~Integer currentTickPosition = 0;
  
  ~Area->Event->\Tick->Listener[] tickEvents = new Area->Event->\Tick->Listener['tickEventArrayLength'];
  ~Area->Generators->FloorGenerator generator = null;  
  
  class Event // {
    interface Tick // {
      void tick(Double millisSinceLastFrame){
      }
      class Listener / ArrayList<Area\>Event\>Tick> / {
        void tick(Double millisSinceLastFrame){
          for Area->Event->Tick ticker : this {
            ticker.tick(millisSinceLastFrame);
          }
          \clear();
        }
      }
    }
  }
  class Generator // {
    Area generate(){
      return null;
    }
  }
  class Generators // {
    class FloorGenerator // {
      Tiles->Floor generateFloor(int x, int y, Environment parent){
        return null;
      }
    }
    class NonGenerator //Area->TileGenerator {
      @NonGenerator non = new NonGenerator();
      void generateAt(int x, int y, Area newArea){
      }
    }
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area1) - origin.getDistanceTo(area2))";
        }
      }
      class Descending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area2) - origin.getDistanceTo(area1))";
        }
      }
    }
  }
> void setup(%Pass data){
  }
> class GeneratorMapValues // {
    ~Class acceptorClass = null;
    Set<String> tilesAdded = new HashSet<String>();
    Map<Integer, Set<Integer>> mappedDimensions = new HashMap<Integer, Set<Integer>>();
    ~Integer layoutSize = 0;
    ~Integer width = 0;
    ~Integer height = 0;
    ~int subGenerators = 0;
    ~Statement generationPointArraySize = new Statement ();
    ~Parameters relativePositions = new Parameters ();
    void set(Class newAcceptorClass, int newWidth, int newHeight, int newLayoutSize){
      acceptorClass = newAcceptorClass;
      width = newWidth;
      height = newHeight;
      layoutSize = newLayoutSize;
      #Parameters startIndices = new Parameters ();
      for int x < width {
        Parameters line = new Parameters ();
        startIndices.add(|new int(`line`)[]|);
        for int y < height {
          line.add(|'new Integer(x*width\+y)'|);
        }
      }
      acceptorClass.addVariable(@int[][] startIndex = new int(`startIndices`)[][];);#
    }
    String addTerrainTile(String mapName, String tileName, %T patchGoto){
      String tileVariableName = tileName.toLowerCase();
      if patchGoto != null {
        String roomName;
        String roomVariableName;
        if patchGoto->"destination"->"room_names" != null{
          roomName = 'patchGoto->"destination"->"room_names"';
          roomVariableName = roomName;
          String tileVariableNameValue = tileVariableName\+roomVariableName;
          if tilesAdded.add(tileVariableNameValue){
            acceptorClass.addVariable(
              ~EntryPoints->'mapName'->'tileName'->\JoinGenerator 'tileVariableNameValue' = null;);            
            acceptorClass.getMethod("setupChoices").appendToBody({
              'tileVariableNameValue' =  new EntryPoints->'mapName'->'tileName'->\JoinGenerator('roomName'); 
            });
          }
          return tileVariableNameValue;
        }
        else if patchGoto->"destination"->"map_names" != null {
          roomVariableName = 'patchGoto->"destination"->"map_names"';
          String tileVariableNameValue = tileVariableName\+roomVariableName;
          if tilesAdded.add(tileVariableNameValue){
            acceptorClass.addVariable(
              @EntryPoints->'mapName'->'tileName'->\JoinGenerator 'tileVariableNameValue' = new EntryPoints->'mapName'->'tileName'->\JoinGenerator(
                  `Environments.getId('patchGoto->"destination"->"map_names"')`););
          }
          return tileVariableNameValue;
        }
        else {
          roomVariableName = null;
          roomName = null;
          return null;
        }
      }
      else {
        if tilesAdded.add(tileName){
          if Tiles->'mapName'->'tileName'->'"FloorFactory"' != null {
             acceptorClass.addVariable(@TerrainChoice 'tileVariableName' = new TerrainChoice(
                new Tiles->'mapName'->'tileName'->\FloorFactory(),
                new Tiles->'mapName'->'tileName'->Factory()););
           }
           else {
             acceptorClass.addVariable(@TerrainChoice 'tileVariableName' = new TerrainChoice(
               new Tiles->'mapName'->'tileName'->Factory(),
               null););
          }
        }
      }
      return tileVariableName;
    }
    String getRoomGenerator(String roomName){
      String roomGenerator = roomName\+"RoomGenerator";
      return roomGenerator;
    }
    String getNextSubGenerator(){
      String name = "PatchGenerator"\+subGenerators;
      subGenerators\+=1;
      return name;
    }
    Integer getNextRelativePosition(Integer x, Integer y){
      Integer startingIndex = relativePositions.size();
      relativePositions.add(|'x'|);
      relativePositions.add(|'y'|);
      return startingIndex;
    }
    void addDefaultVariablesAndMethods(String generatorName, Class defaultFloorGeneratorClass){
      acceptorClass->'generatorName'+=
        @Area->TileGenerator floorGenerator = new 'defaultFloorGeneratorClass.getFullName()'();
      acceptorClass->'generatorName'+=
        @int[] relativePositions = new int(`\getRelativePositions()`)[];
      acceptorClass->'generatorName'+=
        ~ArrayList<Area\>FloorChoice> generationPoints = null;
	  acceptorClass->'generatorName'+=
          void generateAt(int startX, int startY, Area newArea){
            generationPoints = new ArrayList<FloorChoice>(`\getGenerationPointArraySize()`);
	        for int index < 'layoutSize' {
	          generationPoints.add(new Area->FloorChoice(\floorGenerator,startX\+index%'width',startY\+index/'height'));
	        }
	        for int index < 'height' {
	          generationPoints.add(new Area->FloorChoice(Area->Generators->\NonGenerator.non,startX\-1           ,\startY\+index));
  	          generationPoints.add(new Area->FloorChoice(Area->Generators->\NonGenerator.non,startX\+'width',\startY\+index));
	        }
	        for int index < 'width' {
  	          generationPoints.add(new Area->FloorChoice(Area->Generators->\NonGenerator.non,startX\+index       ,\startY\-1));
	          generationPoints.add(new Area->FloorChoice(Area->Generators->\NonGenerator.non,startX\+index       ,\startY\+'width'));
	        }
	        for int index < \relativePositions.length {
	          generationPoints.add(new Area->FloorChoice(Area->Generators->\NonGenerator.non,startX\+\relativePositions[index]      ,startY\+\relativePositions[index\+1]));
	          ""++index;
	        }
          }
      acceptorClass->'generatorName'+=
          void addOneAnywhere(Area->TileGenerator generator){
            generationPoints.get(Range.getRandom(0,'layoutSize')).setGenerator(generator);
          }
    }
    void finish() {
      generationPointArraySize.add(|'new Integer(layoutSize\+2\*width\+2\*height\+relativePositions.size()\/2)'|);
    }
  }
> Map<Class , Map<String, GeneratorMapValues >> generatorMapValues = new HashMap<Class , Map<String, GeneratorMapValues>>();
> Map<String, Map<String, Integer>> generatorIndices = new HashMap<String,Map<String,Integer>>();
> void addGeneratorSuperClass(Class generatorClass) {
    generatorMapValues.put(generatorClass, new HashMap<String, GeneratorMapValues>());
  }
> GeneratorMapValues addGeneratorClass(Class acceptorClass, String generatorName, int width, int height, int size){
    GeneratorMapValues result = new GeneratorMapValues();
    result.set(acceptorClass, width, height, size);
    generatorMapValues.get(acceptorClass).put(generatorName, result);
    return result;
  }
> double declaration(%T declarationToken, String mapName, List<String> floorTiles, double previousChance){
    if generatorIndices.containsKey(mapName) == false {
      Area.generatorIndices.put(mapName, new HashMap<String,Integer>());
      Areas->'mapName' += class AnyGenerator / Area->Generator / {
        Environment parent = null;
        Area generate(){
          Float chance = Range.getRandomFloat();
          Area newArea = new Area();
          parent.add(newArea);
        }      
        @void joinEntryPoints(Area newArea){
		  Integer numberOfEntryPoints = "newArea".getEntryPoints().size();
		  for Integer i < numberOfEntryPoints {
		    Integer j = i \+ 1;
		    while j < numberOfEntryPoints {
		      ArrayList<Tiles\>Floor> path = "newArea".getAbsolutePathBetweenEntryPoints(i,j);
		      ArrayList<Tiles\>Floor> obstructions = new ArrayList<Tiles\>Floor>();
		      Tiles->Floor previousStep = null;
		      if path != null {
		        for Tiles->Floor step: path {
		          if previousStep != null {
		            if step.isPassable(previousStep.getX()\-step.getX(), previousStep.getY()\-step.getY()) == false {
		              obstructions.add(step);
		            }
		          }
		          previousStep = step;
		        }
		        Area->Generators->FloorGenerator floorGenerator = "newArea".getGenerator();
		        for Tiles->Floor step : obstructions {
		          if step.getTerrain() != null && step.getTerrain().isPassable(0,0) == false{
		            "newArea".changeTerrain(step.getTerrain(),null);
		            step.setTerrain(null);
		          }
		          if step.isPassable(0,0) == false {
		            "newArea".remove(step);
		            Tiles->Floor newTile = floorGenerator.generateFloor(step.getX(),step.getY(),"newArea".getParent());
		            while newTile.isPassable(0,0) == false {
		              newTile = floorGenerator.generateFloor(step.getX(),step.getY(),"newArea".getParent());
		            }
		            "newArea".add(newTile);
		          }
		        }
		        if obstructions.isEmpty() == false {
		          "newArea".clearAbsolutePathBetweenEntryPoints(i,j);
		          "newArea".getAbsolutePathBetweenEntryPoints(i,j);
		        }
		      }
		      "++j";
		    }
		  }
		}
      }
    }
    String areaClassName = ^declarationToken->"areaName";
    String areaName = areaClassName.toLowerCase();
    Double chance = Double.parseDouble('declarationToken->"chance"')/100.0\+previousChance;
    Areas->'mapName' += class areaClassName /Area/ {}
    Areas->'mapName'->'areaClassName' += class Generators // {}
    \addGeneratorSuperClass(Areas->'mapName'->'areaClassName'->Generators);
    generatorIndices.get(mapName).put(areaClassName,0);
    ~String entryPointTileName = null;
    ~Integer lowEntryBound = 0;
    ~Integer upperEntryBound = -1;
    declarationToken : element : area_element {
      element : atom : entryPointGeneration {
        lowEntryBound = Integer.parseInt('atom->"range"->"lowerBound"')\+1;
        upperEntryBound = Integer.parseInt('atom->"range"->"upperBound"')\+1;
        entryPointTileName = 'atom->"tile_names"';
      }
    }
    if upperEntryBound == -1 {
      upperEntryBound = upperEntryBound \+ 1;
    }
    if declarationToken->"bluePrintName" != null {
      \readBlueprint(declarationToken,'declarationToken->"bluePrintName"',mapName, areaClassName,lowEntryBound,upperEntryBound, entryPointTileName, chance);
    }
    else {
      ~Integer generatorIndex = generatorIndices.get(mapName).get(areaClassName);
      String generatorName = "Generator"\+generatorIndex;
      String generatorVariableName = "generator"\+generatorIndex;
      if generatorIndex == 0 {
        Areas->'mapName'->AnyGenerator->*"generate".appendToBody(|
          if "chance" <= 'chance' {
              'generatorName.toLowerCase()'.generate("newArea");
              \joinEntryPoints("newArea"); 
              return "newArea";
          }|);
      }
      else {
        Areas->'mapName'->AnyGenerator->*"generate".appendToBody(|
          else if "chance" <= 'chance' {
              'generatorName'.generate("newArea");
              \joinEntryPoints("newArea");
              return "newArea";
          }|);
      }
      Integer floorWidth = Integer.parseInt('declarationToken->"defaultSize"->"patchWidth"');
      Integer floorHeight = Integer.parseInt('declarationToken->"defaultSize"->"patchHeight"');
      Integer floorSize = floorWidth\*floorHeight;
      GeneratorMapValues generatorValues = \addGeneratorClass(Areas->'mapName'->'areaClassName'->Generators,generatorName,
                                              floorWidth,floorHeight,floorSize);
      generatorIndices.get(mapName).put(areaClassName,generatorIndex\+1);
      Areas->'mapName'->'areaClassName'->Generators += class generatorName /Areas->'mapName'->'areaClassName'->Generators->FloorGenerator/ TileGenerator{
	      void generate(Area newArea){
	        newArea.setGenerator(this);
	        \generateAt(0,0,newArea);
	      }
	    }
	  Areas->'mapName'->'areaClassName'->Generators->'generatorName' += class FloorGenerator //Area->TileGenerator {
	      void generateAt(int x, int y, Area newArea){
            newArea.add(new Tiles->'mapName'->'declarationToken->"defaultTileName"'(x,y,newArea.getParent()));
          }
          Tiles->Floor generateFloor(int x, int y, Environment parent){
            return new Tiles->'mapName'->'declarationToken->"defaultTileName"'(x,y,parent);
          }
	    }
	  generatorValues.addDefaultVariablesAndMethods('generatorName',
	    Areas->'mapName'->'areaClassName'->Generators->'generatorName'->'"FloorGenerator"');
	  Areas->'mapName'->AnyGenerator += ~Areas->'mapName'->'areaClassName'->Generators->'generatorName' 'generatorVariableName' = null;
      Areas->'mapName'->AnyGenerator->*.appendToBody(|'generatorVariableName' = new Areas->'mapName'->'areaClassName'->Generators->'generatorName'();|);
      
	  declarationToken : element : patch_element {
	    Areas->'mapName'->'areaClassName'->Generators->'generatorName'->*"generateAt".appendToBody(
	      \getPatchElement(element,mapName,Areas->'mapName'->'areaClassName'->Generators,'generatorName'));
	  }
	  Areas->'mapName'->'areaClassName'->Generators->'generatorName'->*"generateAt".appendToBody(|
	      "newArea" = "generationPoints".stream().reduce("newArea","FloorChoice::generate",("A,B")->"A");|);
	  generatorValues.finish();
    }
    Body floorSwitchBody = new Body ();
    Integer numberOfFloorTiles = floorTiles.size();
    Areas->'mapName'->'areaClassName'->Generators += class FloorGenerator /Area->Generators->FloorGenerator/Area->TileGenerator {
        Tiles->Floor generateFloor(int x, int y, Environment parent){
          Tiles->Floor result = null;
        }
        void generateAt(int x, int y, Area newArea){
          newArea.add(\generateFloor(x,y,newArea.getParent()));
        }
      }
    Areas->'mapName'->'areaClassName'->Generators->FloorGenerator->*"generateFloor".appendToBody(|switch Range.getRandom(0,'numberOfFloorTiles') `floorSwitchBody`|);
    ~Integer floorIndex = 0;
    for String floorName: floorTiles {
      Integer floorIndexValue = floorIndex;
      floorSwitchBody.add(|case 'floorIndexValue' { "result" = new Tiles->'mapName'->'floorName'("x","y","parent"); "break"; }|);
      floorIndex \+= 1;
    }
    Areas->'mapName'->'areaClassName'->Generators->FloorGenerator->*"generateFloor".appendToBody(|return "result";|);
    
    return chance;
  }
> Body getPatchElement(%T patchElement, String mapName, Class generatorsClass, String generatorName ){
    Body result = new Body ();
    GeneratorMapValues values = generatorMapValues.get(generatorsClass).get(generatorName);
    ArrayList< %T > patchElements = new ArrayList < %T >();
    patchElements.add(patchElement);
	return \makeTerrainBody(patchElements,mapName,generatorName,values,false,values.getLayoutSize());
  }
> void readBlueprint(%T decTok, String fileName, String mapName, String areaClassName, Integer lowEntryBound, Integer upperEntryBound, String entryPointTileName, Double chance){
	ByteBuffer pixelBuffer = null;
	~BufferedImage bufferedImage = null;
	try {
	  bufferedImage = ImageIO.read(new File("../Resource/environments/maps/blueprints/"+fileName));
	}
	print catch * {}
	Integer width = bufferedImage.getWidth();
	Integer height = bufferedImage.getHeight();
	int[] pixels = new int[width*height];
	PixelGrabber pixelGrabber = new PixelGrabber(bufferedImage,0,0,width,height,pixels,0,width);
	try {
	  pixelGrabber.grabPixels();
	}
	catch * {
	  System.err.println("Pixel Grabbing interrupted!");
	  return void;
	}
	byte[] bytes = new byte[width*height*4];
	Map<Integer,Map<Integer, Region>> regions = new HashMap<Integer, Map<Integer, Region>>();
	for Integer i < width {
	  regions.put(i, new HashMap<Integer, Region>());
	  for Integer j < height {
		regions.get(i).put(j,new Region(j,width\-i, pixels[i*32+j]));
	  }
	}
	for Integer x < width\-1{
	  for Integer y < height\-1{
	    if regions.get(x).get(y).isCompatible(regions.get(x+1).get(y)) {
		  regions.get(x).get(y).add(regions.get(x+1).get(y));
		  regions.get(x+1).put(y, regions.get(x).get(y));
	    }
	    if regions.get(x).get(y).isCompatible(regions.get(x).get(y+1)) {
 		  regions.get(x).get(y).add(regions.get(x).get(y+1));
	      regions.get(x).put(y+1, regions.get(x).get(y));
        }
	  }
	}
	if regions.get(width\-2).get(height\-1).isCompatible(regions.get(width\-1).get(height\-1)) {
	  regions.get(width\-2).get(height\-1).add(regions.get(width\-1).get(height\-1));
	  regions.get(width\-1).put(height\-1, regions.get(width\-2).get(height\-1));
    }
	if regions.get(width\-1).get(height\-2).isCompatible(regions.get(width\-1).get(height\-1)) {
	  regions.get(width\-1).get(height\-2).add(regions.get(width\-1).get(height\-1));
	  regions.get(width\-1).put(height\-1, regions.get(width\-1).get(height\-2));
	}
	Set<Region> regionSet = new HashSet<Region>();
    for Integer x < width {
	  for Integer y < height {
		if(regions.get(x).get(y).getPixel()!=Region.PIXEL_ZERO&&regions.get(x).get(y).getPixel()!= -1){
		  regionSet.add(regions.get(x).get(y));
		}
	  }
	}
	for Region region: regionSet {
	  List<List<RegionPoint>> zones = region.getZones();
	  List<RegionZone> points = region.getPoints(zones);
	  ~int zoneIndex = 0;
      Integer numberOfZones = points.size();
      Body switchBody = new Body ();
      if generatorIndices.get(mapName).get(areaClassName) == 0 {
        Areas->'mapName'->AnyGenerator->*"generate".appendToBody(|
          if "chance" <= 'chance' {
              switch Range.getRandom(0,'numberOfZones') `switchBody`
              \joinEntryPoints("newArea"); 
              return "newArea";
          }|);
      }
      else {
        Areas->'mapName'->AnyGenerator->*"generate".appendToBody(|
          else if "chance" <= 'chance' {
              switch Range.getRandom(0,'numberOfZones') `switchBody`
              \joinEntryPoints("newArea");
              return "newArea";
          }|);
      }
      ~Integer generatorIndex = generatorIndices.get(mapName).get(areaClassName);
	  for RegionZone zone: points {
		Integer startX = zone.getLowerBoundX();
		Integer startY = zone.getLowerBoundY();
		Integer zoneIndexValue = zoneIndex;
		~Integer entryPointIndex = 0;
		~Integer floorIndex = 0;
		Body caseBody = new Body ();
        Body entryWhileBody = new Body ();
	    Statement floorIndexMaximum = new Statement ();
	    Integer zoneUpperBoundX = zone.getUpperBoundX()\-zone.getLowerBoundX()\+1;
	    Integer zoneUpperBoundY = zone.getUpperBoundY()\-zone.getLowerBoundY()\+1;
	    String generatorName = "Generator"\+'generatorIndex';
	    String generatorVariableName = "generator"\+'generatorIndex';
	    generatorIndex\+=1;
	    GeneratorMapValues generatorValues = new GeneratorMapValues();
	    generatorMapValues.get(Areas->'mapName'->'areaClassName'->Generators).put(generatorName, generatorValues);
	    generatorMapValues.get(Areas->'mapName'->'areaClassName'->Generators).get(generatorName).setAcceptorClass(Areas->'mapName'->'areaClassName'->Generators);
	    Areas->'mapName'->'areaClassName'->Generators += class generatorName /Areas->'mapName'->'areaClassName'->Generators->FloorGenerator/ TileGenerator{
	        ~ArrayList<Area\>FloorChoice> generationPoints = null;
            ~Area->TileGenerator floorGenerator = new Areas->'mapName'->'areaClassName'->Generators->FloorGenerator();
            ~int startX = 0;
            ~int startY = 0;
	        void generate(Area newArea){
	          newArea.setGenerator(this);
	        }
            void generateAt(int x, int y, Area acceptor){
              int previousX = startX;
              int previousY = startY;
              startX = x;
              startY = y;
              \generate(acceptor);
              startX = previousX;
              startY = previousY;
            }
            void addOneAnywhere(Area->TileGenerator generator){
              Range.select(generationPoints).setGenerator(generator);
            }
	      }
	    Areas->'mapName'->AnyGenerator += ~Area->'mapName'->'areaClassName'->Generators->'generatorName' 'generatorVariableName' = null;
        Areas->'mapName'->AnyGenerator->*.appendToBody(|'generatorVariableName' = new Areas->'mapName'->'areaClassName'->Generators->'generatorName'();|);
        
		switchBody.add(|case 'zoneIndexValue' { 
		  'generatorVariableName'.generate("newArea");
		  "break"; }|);
		caseBody.add(|
	      \generationPoints = new ArrayList<FloorChoice>();
	      for Integer index < `floorIndexMaximum` {
	        \generationPoints.add(new Area->FloorChoice(\floorGenerator,\startX\+index%'zoneUpperBoundX',\startY\+index/'zoneUpperBoundX'));
	      }
	      Integer numberOfEntryPoints = Range.getRandom('lowEntryBound','upperEntryBound');
	      Set<Integer> chosenEntryPoints = new HashSet<Integer>();
	      while chosenEntryPoints.size() < numberOfEntryPoints `entryWhileBody` 
	      |);
        
		for RegionPoint point: zone {
		  if point != null {
		    Integer floorIndexValue = floorIndex;
		    floorIndex \+= 1;
		    Integer pointX = point.getX()\-startX;
		    Integer pointY = point.getY()\-startY;
		    if zone.getUps().containsKey(point.getX()) {
		      for RegionEdge edge: zone.getUps().get(point.getX()) {
		        if point.getY() >= edge.getStart() && point.getY() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX\-1, pointY, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    else if zone.getDowns().containsKey(point.getX()) {
		      for RegionEdge edge: zone.getDowns().get(point.getX()) {
		        if point.getY() >= edge.getStart() && point.getY() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX\+1, pointY, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    if zone.getRights().containsKey(point.getY()) {
		      for RegionEdge edge: zone.getRights().get(point.getY()) {
		        if point.getX() >= edge.getStart() && point.getX() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX, pointY\+1, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    else if zone.getLefts().containsKey(point.getY()) {
		      for RegionEdge edge: zone.getLefts().get(point.getY()) {
		        if point.getX() >= edge.getStart() && point.getX() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX, pointY\-1, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
	      }
		}
		Areas->'mapName'->'areaClassName'->Generators->'generatorName'->*"generate".appendToBody(caseBody);
		
		Integer entryPointIndexValue = entryPointIndex;
		entryWhileBody.add(|"chosenEntryPoints".add(Range.getRandom(0,'entryPointIndexValue'));|);
		Integer floorIndexValue = floorIndex;
		
		floorIndexMaximum.add(|'floorIndexValue'|);
		
        
        generatorIndices.get(mapName).put(areaClassName,generatorIndex);
	    caseBody.add(|Integer terrainsGenerated = 0;|);
		\makeTerrainBodies(decTok,mapName,areaClassName,generatorName,caseBody,generatorValues,floorIndex,floorIndex);
		caseBody.add(|"newArea" = "generationPoints".stream().reduce("newArea","FloorChoice::generate",("A,B")->"A");|);
		
        zoneIndex \+= 1;
	  }
	}
	
  }
> Statement addAreaEntryPoint(Integer pointX,Integer pointY, String mapName, String entryPointTileName,Integer entryPointIndex) {
    return |if "chosenEntryPoints".contains('entryPointIndex') {
        "newArea".add(new EntryPoints->'mapName'->'entryPointTileName'('pointX','pointY',"parent"));
      }|;
  }
> void makeTerrainBodies(%T declarationToken, String mapName, String areaClassName, String generatorName, Body caseBody, GeneratorMapValues generatorValues, Integer floorIndex, Integer layoutSize){
    ~Integer patchIndex = 0;
    caseBody.add(|float terrainChance = 0f;|);
    caseBody.add(|int numberOfTerrainPoints = 0;|);
    declarationToken : element : area_element {
      element : atom : terrainGeneration {  
        Integer patchIndexValue = patchIndex;
	    String generateMethodName = "generatePatchElement"+'patchIndexValue';
        patchIndex\+=1;
        Areas->'mapName'->'areaClassName'->Generators->'generatorName' += 
          @Integer 'generateMethodName'(){
            int startIndex = 0;
          }
        Body terrainChanceBody = new Body ();
        Body terrainWhileBody = new Body ();
        caseBody.add(|\numberOfTerrainPoints = 0;|);
        caseBody.add(|\terrainChance = Range.getRandomFloat();|); 
	    caseBody.add(terrainChanceBody);
	    caseBody.add(|
	      \terrainsGenerated = 0;
	      while \terrainsGenerated < \numberOfTerrainPoints {
	        \terrainsGenerated \+= Areas->'mapName'->'areaClassName'->Generators->'generatorName'."generatePatchElement"+'patchIndexValue'("generationPoints");
	      }|);
	    \addPatchProbabilities(atom,terrainChanceBody);
	    ArrayList< %T > patchElements = new ArrayList < %T >();
	    atom : quark : patch_element {
	      patchElements.add(quark);
	    }
	    Areas->'mapName'->'areaClassName'->Generators->'generatorName'->*'generateMethodName'.appendToBody(
	      \makeTerrainBody(patchElements,mapName,generatorName,generatorValues,true,floorIndex));
	    
	  }
	}
  }
> void addPatchProbabilities(%T atom, Body acceptor){
     
    ~Double terrainChanceBuilder = 0.0;
    ~Boolean isFirst = true;
    atom : quark : probability {
      Parameters amounts = new Parameters ();
      ~double times = 0.0;
      quark : amount : amount {
        amounts.add(|'amount'|);
        times \+= 1.0;
      }
      Double terrainChanceValue = Double.parseDouble('quark->"percent"')\*times\/100.0\+terrainChanceBuilder;
      if isFirst {
        if amounts.size() == 1 {
          acceptor.add(|if "terrainChance" <= 'terrainChanceValue' {
           "numberOfTerrainPoints" = `amounts`;
          }|);
        }
        else {
          acceptor.add(|if "terrainChance" <= 'terrainChanceValue' {
           "numberOfTerrainPoints" = Range.select(new Integer(`amounts`)[]);
          }|);
        }
      }
      else {
        if amounts.size() == 1 {
          acceptor.add(|else if "terrainChance" <= 'terrainChanceValue' {
            "numberOfTerrainPoints" = `amounts`;
              }|);
        }
        else {
          acceptor.add(|
            else if "terrainChance" <= 'terrainChanceValue' {
              "numberOfTerrainPoints" = Range.select(new Integer(`amounts`)[]);
            }|);
        }
      }
      isFirst = false;
      terrainChanceBuilder = terrainChanceValue;
    }
  }

> Body makeTerrainBody(ArrayList< %T > patchElements,String mapName, String generatorName, GeneratorMapValues generatorValues, boolean hasReturnValue, Integer layoutSize){
    ~Body result = null;
    ~Integer choiceCount = 0;
    for %T quark : patchElements {
      choiceCount \+= 1;
    }
    
    Body terrainSwitchBody = new Body ();
    if choiceCount > 1 {
      Integer choiceCountValue = choiceCount;
      result = new Body ();
      result.add(| 
        switch Range.getRandom(0,'choiceCountValue') `terrainSwitchBody` |);
    }
    ~Integer choiceIndex = 0;
    for %T quark : patchElements {
      Body innerSwitchBody = new Body ();
      ~int segmentation = 0;
      quark : width : patchWidth {
        segmentation\+=1;
      }
      String terrainTileName = ^quark->"tile_names";
      String terrainTileNameValue = generatorValues.addTerrainTile('mapName','terrainTileName', quark->"patch_goto");
      ArrayList<Integer> startXs = new ArrayList<Integer>();
      ArrayList<Integer> startYs = new ArrayList<Integer>();
      ArrayList<Integer> endXs = new ArrayList<Integer>();
      ArrayList<Integer> endYs = new ArrayList<Integer>();
      if quark->"patchWidth" == null {
        startXs.add(1);
        startYs.add(1);
        endXs.add(1);
        endYs.add(1);
      }
      else {
        quark : width : patchWidth {
          startXs.add(\getPatchDimension(width,false));
          endXs.add(\getPatchDimension(width,true));
        }
        quark : height : patchHeight {
          startYs.add(\getPatchDimension(height,false));
          endYs.add(\getPatchDimension(height,true));
        }
      }
      ~int segmentIndex = 0;
      ~int choiceMaxWidth = 0;
      ~int choiceMaxHeight = 0;
      for Integer i < startXs.size() {
        Body caseBody = new Body ();
        caseBody.add(\getTerrainPatch("this",terrainTileNameValue,startXs.get(i),endXs.get(i),startYs.get(i),endYs.get(i)));
        if endXs.get(i) > choiceMaxWidth {
          choiceMaxWidth = endXs.get(i);
        }
        if endYs.get(i) > choiceMaxHeight {
          choiceMaxHeight = endYs.get(i);
        }
        if hasReturnValue {
          caseBody.add(|return 1;|);
        }
        else if segmentation > 1 {
          caseBody.add(|"break";|);
        }
        if segmentation > 1 {
          Integer segmentIndexValue = segmentIndex;
          innerSwitchBody.add(|
            case 'segmentIndexValue' `caseBody`|);
          segmentIndex\+=1;
        }
        else {
          innerSwitchBody.add(caseBody);
        }
      }
      Body terrainCaseBody;
      if quark->"patch_relative_position" != null {
        if quark->"patch_relative_position"->"offside" != null && choiceMaxWidth==1 && choiceMaxHeight==1 {
          terrainCaseBody = {\generationPoints.get('new Integer(generatorValues.getLayoutSize())'\+Range.getRandom(0,'new Integer(2*generatorValues.getWidth()\+2*generatorValues.getHeight())')).setGenerator('terrainTileNameValue');};
        }
        else {
          String subGeneratorName = generatorValues.getNextSubGenerator();
          Integer patchCaseWidth = choiceMaxWidth;
          Integer patchCaseHeight = choiceMaxHeight;
          Integer patchCaseSize = patchCaseWidth\*patchCaseHeight;
          generatorValues.getAcceptorClass().getSubClass(generatorName).addSubClass(
            class subGeneratorName //Area->TileGenerator {
              ~ArrayList<Area\>FloorChoice> generationPoints = null; 
              void generateAt(int startX, int startY, Area newArea){
                generationPoints = new ArrayList<Area\>FloorChoice>('patchCaseSize');
	            for Integer index < 'patchCaseSize' {
	              generationPoints.add(new Area->FloorChoice(Area->Generators->\NonGenerator.non,startX\+index%'patchCaseWidth',startY\+index/'patchCaseHeight'));
	            }
              }
              void addOneAnywhere(Area->TileGenerator generator){
                generationPoints.get(Range.getRandom(0,'patchCaseSize')).setGenerator(generator);
              }
            }
          );
          if segmentation > 1 {
            Integer segmentationValue = segmentation;
            generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName).getMethod("generateAt").appendToBody({
              switch Range.getRandom(0,'segmentationValue') `innerSwitchBody`
              });
          }
          else {
            generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName).getMethod("generateAt").appendToBody(innerSwitchBody);
          }
          generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName).getMethod("generateAt").appendToBody(|
	        "newArea" = "generationPoints".stream().reduce("newArea","FloorChoice::generate",("A,B")->"A");|);
	      for Integer i < startXs.size() {
	        \addFillMethod(
               generatorValues.getAcceptorClass().getSubClass(generatorName).getSubClass(subGeneratorName),
               endXs.get(i),endYs.get(i),patchCaseWidth,patchCaseHeight);
	        }
          if quark->"patch_relative_position"->"offside" != null {
            terrainCaseBody = {\generationPoints.get('new Integer(generatorValues.getLayoutSize())'\+Range.getRandom(0,'new Integer(2*generatorValues.getWidth()\+2*generatorValues.getHeight())')).setGenerator(new 'subGeneratorName'());};
            segmentation = 1; 
          }
          else {
            Integer relativeStartX = \getPatchDimension(quark->"patch_relative_position"->"patchWidth", true);
            Integer relativeEndX   = \getPatchDimension(quark->"patch_relative_position"->"patchWidth", true);
            Integer relativeStartY = \getPatchDimension(quark->"patch_relative_position"->"patchHeight", false);
            Integer relativeEndY   = \getPatchDimension(quark->"patch_relative_position"->"patchHeight", true);
            if relativeStartX == relativeEndX && relativeStartY == relativeEndY {
              terrainCaseBody = {\generationPoints.get('new Integer(generatorValues.getNextRelativePosition(relativeEndX,relativeEndY))').setGenerator(new 'subGeneratorName'());};
              segmentation = 1;
            }
            else {
              Integer relativeSize = (relativeEndX\-relativeStartX\+1)\*(\relativeStartX\-relativeEndX\+1);
              terrainCaseBody = new Body ();
              for Integer x < (relativeEndX\-relativeStartX) {
                for Integer y < (relativeEndY\-relativeStartY) {
                  terrainCaseBody.add(|\generationPoints.get('new Integer(generatorValues.getNextRelativePosition(x,y))').setGenerator(new 'subGeneratorName'());\break;|);
                }
              }
              segmentation = relativeSize;
            }
          }
        }
      }
      else {
        for Integer i < startXs.size() {
	      \addFillMethod(
	        generatorValues.getAcceptorClass().getSubClass(generatorName),
            endXs.get(i),endYs.get(i),generatorValues.getWidth(),generatorValues.getHeight());
	    }
        terrainCaseBody = innerSwitchBody;
      }
      if choiceCount > 1 {
        if segmentation > 1 {
          Integer segmentationValue = segmentation;
          terrainSwitchBody.add(| 
            switch Range.getRandom(0,'segmentationValue') `terrainCaseBody` |);
        }
        else {
          terrainSwitchBody.add(terrainCaseBody);
        }
        if hasReturnValue {
            terrainSwitchBody.add(|return 0;|);
        }
        else {
          terrainSwitchBody.add(|\break;|);
        }
      }
      else {
        if segmentation > 1 {
          result = new Body ();
          Integer segmentationValue = segmentation;
          result.add(| 
            switch Range.getRandom(0,'segmentationValue') `terrainCaseBody` |);
        }
        else {
          result = terrainCaseBody;
        }
      }
      choiceIndex \+= 1;
    }
    if hasReturnValue && choiceCount > 1 {
      result.add({return 0;});
    }
    return result;
  }
> Integer getPatchDimension(%T dimension, boolean isUpper){
    if isUpper {
      if dimension->"upperBound" != null {
        return Integer.parseInt('dimension->"upperBound"');
      }
      else {
        return Integer.parseInt('dimension');
      }
    }
    else {
      if dimension->"lowerBound" != null {
        return Integer.parseInt('dimension->"lowerBound"');
      }
      else {
        return Integer.parseInt('dimension');
      }
    }
  }
> Statement getTerrainPatch(String generator,String tileName, Integer startX, Integer endX, Integer startY, Integer endY){
    if endX == 1 && endY == 1 {
      return |'generator'.addOneAnywhere('tileName');|;
    }
    else { 
      if startX == endX {
        if startY == endY {
          return |'generator'."fill"+'endX'+"x"+'endY'('endX','endY','tileName');|;
        }
        else {
          return |'generator'."fill"+'endX'+"x"+'endY'('endX',Range.getRandom('new Integer(startY\-1)','endY'),'tileName');|;
        }
      }
      else {
        if startY == endY {
          return |'generator'."fill"+'endX'+"x"+'endY'(Range.getRandom('new Integer(startX\-1)','endX'),'endY','tileName');|;
        }
        else {
          return |'generator'."fill"+'endX'+"x"+'endY'(Range.getRandom('new Integer(startX\-1)','endX'),Range.getRandom('new Integer(startY\-1)','endY'),'tileName');|;
        }
      }
    }
  }
> void addFillMethod(Class acceptorClass, int width, int height, Integer parentWidth, Integer parentHeight){
    if width == 1 && height == 1 {
      return void;
    }
    String methodName = "fill"\+width\+"x"\+height;
    if acceptorClass.getMethod(methodName) == null {
      acceptorClass.addMethod(void 'methodName'(int width, int height, Area->TileGenerator generator){
          int x = Range.getRandom(0,'new Integer(parentWidth\-width\+1)');
          int y = Range.getRandom(0,'new Integer(parentHeight\-height\+1)');
          for int dx < width {
            int fx = (x\+dx)*'parentWidth';
            for int dy < height {
              \generationPoints.get(fx\+y\+dy).setGenerator(generator);
            }
          }
        });
    }
  }
>  byte getPixelA(int p){
    return (byte)((p >> 24) & 0xFF);
  }
>  byte getPixelR(int p){
    return (byte)((p >> 16) & 0xFF);
  }
>  byte getPixelG(int p){
    return (byte)((p >> 8) & 0xFF);
  }
>  byte getPixelB(int p){
    return (byte)((p >> 0) & 0xFF);
  }
  void display(){
    floorTiles.stream().forEach("Tile::display");
    entryPoints.stream().forEach("Tile::display");
  }
  void undisplay(){
    floorTiles.stream().forEach("Tile::undisplay");
    entryPoints.stream().forEach("Tile::undisplay");
  }
  Tiles->Floor getTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->Floor getFloorTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->MonsterDen getMonsterDen(Tile->Id findId){
    if tileMap.containsKey(findId) == false || tileMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return (Tiles->MonsterDen)Range.select(tileMap.get(findId));
    }
  }
  Tiles->MonsterDen getMonsterDen(Predicate<Tile> findCriteria){
    return (Tiles->MonsterDen)\tiles.parallelStream().filter(findCriteria).findAny().orElse(null);
  }
  int getDistanceToArea(Area area){
    if this == area {
      return 0;
    }
    for Integer i : areaDistances.keySet() {
      if areaDistances.get(i).contains(area) {
        return i;
      }
    }
    return -1;
  }
  void findDistance(Area findArea){
    if entryPoints.stream()
        .filter(
          (\entryPoint)->\entryPoint.getSister()!= null)
        .anyMatch(
          (\entryPoint)->\entryPoint.getSister().getArea() == findArea) {
      \setDistanceToArea(1,findArea);
      return void;
    }
    for Integer i : areaDistances.keySet() {
      if
        areaDistances.get(i).stream()
        .flatMap((\area)->area.entryPoints.stream())
        .filter(
          (\entryPoint)->\entryPoint.getSister()!= null)
        .anyMatch(
          (\entryPoint)->\entryPoint.getSister().getArea() == findArea) {
        \setDistanceToArea(i\+1,findArea);
        return void;
      }
    }
  }
  void setDistanceToArea(int distance, Area area){
    if areaDistances.containsKey(distance) == false {
      areaDistances.put(distance,new HashSet<Area>());
      if distance > furthestDistanceToArea {
        furthestDistanceToArea = distance;
      }
    }
    areaDistances.get(distance).add(area);
  }
  Tiles->EntryPoint getEntryPoint(Integer index){
    return entryPoints.get(index);
  }
  Tile getTile(Tile->Id findId){
    if tileMap.containsKey(findId) == false || tileMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(tileMap.get(findId));
    }
  }
  Tile getTile(Tiles->Floor->Id findId){
    if floorMap.containsKey(findId) == false || floorMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(floorMap.get(findId));
    }
  }
  Tile getTile(Tiles->Terrain->Id findId){
    if terrainMap.containsKey(findId) == false || terrainMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(terrainMap.get(findId));
    }
  }
  Boolean load(){
    for Integer currentTickPosition < 'tickEventArrayLength' {
      tickEvents[currentTickPosition] = new Area->Event->Tick->Listener();
    }
    tiles.stream().forEach("Tile::load");
    return true;
  }
  Boolean tick(Double millisSinceLastFrame){
    tiles.stream().forEach((\T)->\T.tick(millisSinceLastFrame));
    tickEvents[currentTickPosition].tick(millisSinceLastFrame);
    if currentTickPosition >= 'new Integer(tickEventArrayLength\-1)' {
      currentTickPosition = 0;
    }
    else {
     "++currentTickPosition";
    }
    return true;
  }
  Boolean join(Tiles->EntryPoint yourEntryPoint){
    Tiles->EntryPoint myEntryPoint = entryPoints.stream()
      .filter(("E")->"E".getSister()==null||"E".getSister().getArea()==null)
      .findAny().orElse(null);
    if myEntryPoint != null && yourEntryPoint != null {
      myEntryPoint.setSister(yourEntryPoint);
      yourEntryPoint.setSister(myEntryPoint);
      \getParent().getAreas().stream()
        .forEach((\A)->\A.findDistance(yourEntryPoint.getArea()));
      yourEntryPoint.getArea().getParent().getAreas().stream()
        .forEach((\A)->\A.findDistance(myEntryPoint.getArea()));
      return true;
    }
    else {
      entryPointsListeners.add("(newEntryPoint)->{newEntryPoint.setSister(yourEntryPoint);yourEntryPoint.setSister(newEntryPoint);newEntryPoint.getArea().getParent().getAreas().stream().forEach((A)->A.findDistance(yourEntryPoint.getArea()));yourEntryPoint.getArea().getParent().getAreas().stream().forEach((A)->A.findDistance(newEntryPoint.getArea()));return false;}");
      return false;
    }
  }
  void addEvent(Integer offset, Area->Event->Tick event) {
    tickEvents[(currentTickPosition\+offset)%'tickEventArrayLength'].add(event);
  }
  Boolean add(Entity entity){
    if \getParent() != null && entity.getIsPlayerAffiliated() {
      \getParent().addActiveArea(this);
    }
    return entities.add(entity);
  }
  Boolean remove(Entity entity){
    if \getParent() != null && entity.getIsPlayerAffiliated() {
      \getParent().removeActiveArea(this);
    }
    return entities.remove(entity);
  }
  Boolean add(Tile newTile){
    newTile.setArea(this);
    if newTile.getX() \+ newTile.getWidth() > width {
      width = newTile.getX() \+ newTile.getWidth();
    }
    if newTile.getY() \+ newTile.getHeight() > height {
      height = newTile.getY() \+ newTile.getHeight();
    }
    if tileMap.containsKey(newTile.getId()) == false {
      tileMap.put(newTile.getId(), new ArrayList<Tile>());
    }
    tileMap.get(newTile.getId()).add(newTile);
    if "newTile.getId() instanceof Tiles.EntryPoint.Id" {
      if entryPointsListeners.isEmpty() == false {
        ~boolean canContinue = true;
        while canContinue && entryPointsListeners.isEmpty() == false {
          canContinue = entryPointsListeners.remove(0).listen((Tiles.EntryPoint)newTile);
        }
      }
      entryPoints.add(((Tiles.EntryPoint)newTile));
    }
    if "newTile.getId() instanceof Tiles.Floor.Id" {
      floorTiles.add((Tiles->Floor)newTile);
      if floorMap.containsKey(newTile.getId()) == false {
        floorMap.put("(Tiles.Floor.Id)newTile.getId()",new ArrayList<Tiles\>Floor>());
      }
      floorMap.get("(Tiles.Floor.Id)newTile.getId()").add("(Tiles.Floor)newTile");
      if layout.containsKey(newTile.getX()) == false {
        layout.put(newTile.getX(), new HashMap<Integer,Tiles\>Floor>());
      }
      layout.get(newTile.getX()).put(newTile.getY(),"(Tiles.Floor)newTile");
    }
    else if "newTile.getId() instanceof Tiles.Terrain.Id" {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile.getId()",new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add("(Tiles.Terrain)newTile");
    }
    if \parent != null {
      \parent.add(newTile);
    }
    return tiles.add(newTile);
  }
  void changeFloorLocation(Integer oldX, Integer oldY, Integer newX, Integer newY){
    if layout.containsKey(newX) == false {
      layout.put(newX,new HashMap<Integer, Tiles\>Floor>());
    }
    layout.get(newX).put(newY, layout.get(oldX).remove(oldY));
  }
  void changeTerrain(Tiles\>Terrain oldTile, Tiles\>Terrain newTile){
    if oldTile != null {
      if terrainMap.containsKey(oldTile.getId()) {
        terrainMap.get("(Tiles.Terrain.Id)oldTile".getId()).remove(oldTile);
      }
    }
    if newTile != null {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile".getId(), new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add(newTile);
    }
  }
  Boolean remove(Entity entity){
    return entities.remove(entity);
  }
  Boolean remove(Tile oldTile){
    for Tile neighbour: oldTile.getNeighbours() {
      neighbour.resetNeighbour(oldTile);
    }
    oldTile.setArea(null);
    tileMap.get(oldTile.getId()).remove(oldTile);
    if "oldTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.remove(oldTile);
    }
    else if "oldTile.getId() instanceof Tiles.Floor.Id" {
      floorMap.get(oldTile.getId()).remove("(Tiles.Floor)oldTile");
      if layout.containsKey(oldTile.getX()) {
        layout.get(oldTile.getX()).remove(oldTile.getY());
      }
    }
    else if "oldTile.getId() instanceof Tiles.Terrain.Id" {
      terrainMap.get(oldTile.getId()).remove("(Tiles.Terrain)oldTile");
    }
    return tiles.remove(oldTile);
  }
  boolean has(Predicate<Tile> criteria){
    return tiles.parallelStream().anyMatch(criteria);
  }
  Tiles->Floor getUnexploredPoint(Entity explorer){
    return entryPoints.stream()
      .filter(
        \tile\->( \tile.getSister() == null || \tile.getSister().getArea() == null || explorer.hasExplored(\tile.getSister().getArea()) == false ))
      .filter(\tile\->\tile.hasOccupant(explorer) == false)
      .findAny().orElse(null);
  }
  Entity->List collectEntities(Predicate<Entity> predicate){
    return 
      entities.stream()
        .filter(predicate)
        .collect(
           Collector.of(
              "Entity.List::new", 
              "Entity.List::add",
              ("left, right") -> "{ left.addAll(right); return left; }")); 
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range){
    return \collectEntities((\entity)->\entity.getLocation().getDistanceTo(position) <= range);
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range, Predicate<Entity> criteria){
    return 
      entities.stream()
        .filter(criteria)
        .filter((\entity)->\entity.getLocation().getDistanceTo(position) <= range)
        .collect(
           \Collector.of(
              "Entity.List::new", 
              "Entity.List::add",
              ("left, right") -> "{ left.addAll(right); return left; }"));
  }
  Entity getClosestEntity(Environment->Position position, Predicate<Entity> criteria){
    return entities.stream().filter(criteria).sorted(new Entity->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tiles->EntryPoint getClosestEntryPoint(Environment->Position position){
    return entryPoints.stream().sorted(new Tile->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tiles->Terrain getClosestTile(Environment->Position position, Tiles->Terrain->Id terrainId){
    if terrainMap.containsKey(terrainId) == false {
      return null;
    }
    return terrainMap.get(terrainId).stream().sorted(new Tile->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tile getClosestTile(Environment->Position position, Tile->Id tileId){
    if tileMap.containsKey(tileId) == false {
      return null;
    }
    return tileMap.get(tileId).stream().sorted(new Tile->Comparators->Distance->Ascending(position)).findFirst().orElse(null);
  }
  Tile getClosestTile(Environment->Position position, Predicate<Tile> criteria){
    for Integer distance < furthestDistanceToArea {
      ArrayList<Tile> tiles = new ArrayList<Tile>();
      \getAllTiles(distance,tiles);
      Tile result = tiles.parallelStream().filter(criteria).sorted(new Tile->Comparators->Distance->Ascending->Complex(position)).findFirst().orElse(null);
      if result != null {
        return result;
      }
    }
    return null;
  }
  void getAllTiles(int distance,ArrayList<Tile> collector){
    if distance == 0 {
      collector.addAll(tiles);
    }
    else {
      if areaDistances.containsKey(distance) {
        for Area area: areaDistances.get(distance) {
          collector.addAll(area.tiles);
        }
      }
    }
  }
  
  Boolean isWithin(Environment->Position otherPosition){
    return otherPosition.getX() >= 0 && otherPosition.getX() < "width" && otherPosition.getY() >= 0 && otherPosition.getY() < "height";
  }
  Tiles->EntryPoint getEntryPointToward(Area area){
    if sisterAreas.containsKey(area) {
      return sisterAreas.get(area);
    }
    else {
      for Tiles\>EntryPoint entryPoint: entryPoints {
        if entryPoint.getSister() != null && entryPoint.getSister().getArea() == area {
          sisterAreas.put(area,entryPoint);
          return entryPoint;
        }
        else if entryPoint.getSister() != null && entryPoint.getSister().getArea() != null {
          Set<Area> investigated = new HashSet<Area>();
          if entryPoint.getSister().getArea().canGetToAreaFrom(area,entryPoint.getSister(),investigated) {
            investigated.add(this);
            sisterAreas.put(area,entryPoint);
            return entryPoint;
          }
        }
      }
    }
    return null;
  }
  Boolean canGetToAreaFrom(Area findArea,Tiles->EntryPoint previousEntryPoint, Set<Area> investigated){
    if this == findArea {
      return true;
    }
    if investigated.add(this) {
      return entryPoints.stream()
        .filter((\entryPoint)->\entryPoint!=previousEntryPoint)
        .filter((\entryPoint)->\entryPoint.getSister()!=null)
        .filter((\entryPoint)->\entryPoint.getSister().getArea()!=null)
        .anyMatch((\entryPoint)->\entryPoint.getSister().getArea().canGetToAreaFrom(findArea,\entryPoint.getSister(),investigated));
    }
    else {
      return false;
    }
  }
  ArrayList<Tiles\>Floor> getAbsolutePathBetweenEntryPoints(Integer startPoint, Integer endPoint){
    if entryToEntryPaths.containsKey(startPoint) {
      if entryToEntryPaths.get(startPoint).containsKey(endPoint) {
        return entryToEntryPaths.get(startPoint).get(endPoint);
      }
    }
    else {
      entryToEntryPaths.put(startPoint, new HashMap<Integer, ArrayList<Tiles\>Floor>>());
    }
    Tiles->Floor endTile = entryPoints.get(endPoint);
    Tiles->Floor tile = entryPoints.get(startPoint);
    Tiles->Floor->Path path = new Tiles->Floor->Path(null,tile,endTile);
    Tiles->Floor->Path->Ways ways = new Tiles->Floor->Path->Ways();
    ways.add(path);
    Set<Tiles\>Floor> investigated = new HashSet<Tiles\>Floor>();
    investigated.add(null);
    investigated.add(tile);
    ArrayList<Tiles\>Floor\>Path> tried = new ArrayList<Tiles\>Floor\>Path>(); 
    while path.getTile() != endTile && ways.isEmpty() == false {
      path = ways.pollFirst();
      tried.add(path);
      for Tiles->Floor neighbour: path.getTile().getNeighbours() {
        if investigated.add(neighbour) {
          ways.add(new Tiles->Floor->Path(path,neighbour,endTile));
        }
      }
    }
    if path.getTile() == endTile {
      entryToEntryPaths.get(startPoint).put(endPoint, path);
      if entryToEntryPaths.containsKey(endPoint) == false {
        entryToEntryPaths.put(endPoint, new HashMap<Integer, ArrayList<Tiles\>Floor>>());
      }
      entryToEntryPaths.get(endPoint).put(startPoint, path.reverse());
      return path;
    }
    else {
      System.err.println('' "Could not make path!" '');
      for Tiles->Floor->Path trie: tried {
        System.out.println(path);
      }
      return null;
    }
  }
  void clearAbsolutePathBetweenEntryPoints(Integer startPoint, Integer endPoint){
    if entryToEntryPaths.containsKey(startPoint) {
      if entryToEntryPaths.get(startPoint).containsKey(endPoint) {
        entryToEntryPaths.get(startPoint).remove(endPoint);
      } 
    }
    if entryToEntryPaths.containsKey(endPoint) {
      if entryToEntryPaths.get(startPoint).containsKey(startPoint) {
        entryToEntryPaths.get(endPoint).remove(startPoint);
      } 
    }
  }
  
  interface TileGenerator //{
    void generateAt(int x, int y, Area acceptor){}
  }
  class FloorChoice // {
    TileGenerator generator = null;
    int x = 0;
    int y = 0;
    void setGenerator(TileGenerator newGenerator){
      generator = newGenerator;
    }
    @Area generate(Area newArea,FloorChoice choice){
      choice.generator.generateAt(choice.x,choice.y,newArea);
      return newArea;
    } 
  }
  class TerrainChoice //TileGenerator {
    Tiles->Floor->Factory floorFactory = null;
    Tiles->Terrain->Factory terrainFactory = new NullTerrainFactory();
    
    void generateAt(int x, int y, Area acceptor){
      Tiles->Floor newFloorTile = floorFactory.create(x,y,acceptor.getParent());
      newFloorTile.setTerrain(terrainFactory.create(newFloorTile));
      acceptor.add(newFloorTile);
    }

    class NullTerrainFactory // Tiles->Terrain->Factory {
      Tiles->Terrain create(Tiles->Floor parentFloorTile){
        return null;
      }
      Tile create() {
		return null;
	  }
    }
  }
}
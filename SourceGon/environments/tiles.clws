class 'packageName'.environments EntryPoints {
  Drawables dwbs = null;
}
class 'packageName'.environments Tiles {
  Drawables dwbs = null;
  @Tile create(String tileName){
    return null;
  }
  class Floor / Tile     /{
    class Id / Tile->Id / {
    }
    interface Factory / Tile->Factory / {
      Tiles->Floor create(Integer x, Integer y, Environment parent){}
      Tiles->Floor create(){}
    }
    ~Tiles->Terrain terrain = null;
    ~Entity occupant = null;
    
    Boolean load(){
      if terrain != null {
        terrain.load();
      }
      if occupant != null {
        occupant.load();
      }
      return true;
    }
    Boolean tick(Double millisSinceLastFrame){
      if terrain != null {
        terrain.tick(millisSinceLastFrame);
      }
      if occupant != null {
        occupant.tick(millisSinceLastFrame);
      }
      return true;
    }
    Entity->Event accept(Entity newOccupant){
      newOccupant.getLocation().setTile(this);
      occupant = newOccupant;
      return \super.accept(newOccupant);
    }
    void setTerrain(Tiles->Terrain newTerrain){
      terrain = newTerrain;
      if terrain != null {
        terrain.setFloorTile(this);
      }
    }
    Boolean hasOccupant(){
      return occupant != null;
    }
    boolean hasObstruction(){
      return occupant != null || ( terrain != null &&! terrain.isPassable(0,0));
    }
    
    Boolean hasOccupant(Entity otherEntity){
      return occupant == otherEntity;
    }
    Boolean isPassable(Integer directionX, Integer directionY){
      if occupant != null {
        return false;
      }
      else if terrain != null &&! terrain.isPassable(directionX, directionY) {
        return false;
      }
       else {
        return true;
      }
    }
    class Way // {
      ~Integer currentIndex = 1;
      ArrayList<Tiles\>Floor> path = null;
      boolean step(Entity host){
        if currentIndex < path.size() {
          host.getLocation().stepUsingWay(host.getWalkingSpeed(), host.getLocation().getDirectionOf(path.get("currentIndex++")),this);
          return true;
        }
        else {
          return false;
        }
      }
      void fail(){
        "--currentIndex";
      }
    }
    class Path // Comparable<Path> {
      ~int distanceToDestination = 0;
      ~Tiles->Floor tile = null;
      ~Tiles->Floor parent = null;
      Path *(Path parentPath, Tiles->Floor nextTile, Tiles->Floor destination){
        distanceToDestination = Math.abs(destination.getX()\-nextTile.getX())\+Math.abs(destination.getY()\-nextTile.getY());
        if parentPath != null {
          parent = parentPath;
          if nextTile.isPassable(parentPath.tile) == false {
            distanceToDestination \+= 5000;
            if nextTile.hasObstruction() == false {
              distanceToDestination \+= 5000;
            }
          }
        }
        tile = nextTile;
      }
      List<Tiles\>Floor> collect(){
        List<Tiles\>Floor> result = "parent!=null?parent.collect():new ArrayList<Tiles.Floor>()";
        result.add(tile);
        return result;
      }
      List<Tiles\>Floor> collectReverse(){
        List<Tiles\>Floor> result = new ArrayList<Tiles\>Floor>();
        \collectReverse(result);
        return result;
      }
      void collectReverse(List<Tiles\>Floor> result){
        result.add(tile);
        if parent!= null {
          parent.collectReverse(result);
        }
      }
      boolean equals(Object otherObject){
        Path otherPath = (Path)otherObject;
        return "otherPath.distanceToDestination == distanceToDestination && otherPath.parent == parent && otherPath.tile == tile ? parent!=null ? parent.equals(otherObject.parent) : true : false";
      }
      int compareTo(Path otherPath) {
        if distanceToDestination==otherPath.distanceToDestination {
		  if tile.getX()==otherPath.tile.getX()&&tile.getY()==otherPath.tile.getY() {
			return 0;
		  }
		  else if(tile.getX()==otherPath.tile.getX()){
			return tile.getY()-otherPath.tile.getY();
		  }
		  else {
			return tile.getX()-otherPath.tile.getX();
		  }
		}
		else {
		  return distanceToDestination-otherPath.distanceToDestination;
		}
      }
      String toString(){
	    StringBuilder builder = new StringBuilder();
	    builder.append('' "*******\\n" '');
	    \toString(builder);
	    return builder.toString();
      }
      void toString(StringBuilder builder){
	    builder.append('' "[" '');
		builder.append(tile.getX());
		builder.append('' "," '');
		builder.append(tile.getY());
		builder.append('' "]" '');
		if parent!= null {
		  \toString(builder);
		}
      }
      class Ways / TreeSet<Path> / {
        Tiles->Floor endTile;
        void extends(Tiles->Floor->Path toExtend, Tiles->Floor toAdd){
          \add(new Tiles->Floor->Path(toExtend,toAdd,endTile));
        }
      }
    }
  }
  class Terrain /  Tile    /{
    class Id   / Tile->Id / {
    }
    interface Factory / Tile->Factory /  {
      Tiles->Terrain create(Tiles->Floor parentFloor){}
      Tiles->Terrain create(){}
    }
    ~Tiles->Floor floorTile = null;
    void setFloorTile(Tiles->Floor newFloorTile){
      floorTile = newFloorTile;
      \setX(floorTile.getX());
      \setY(floorTile.getY());
    }
    Boolean isPassable(Integer x, Integer y){
      return false;
    }
    Entity->Event accept(Entity newOccupant){
      return floorTile.accept(newOccupant);
    }
    class Corpse / Tiles->Terrain / {
    }
  }
  class MonsterDen / Tiles->Terrain     / {
    class Id      / Tiles->Terrain->Id / {
    }
    ~Integer hp = 100;
    ~Integer maxHp = hp;
    Boolean isDead(){
      return hp <= 0;
    }
    Boolean isPassable(Integer x, Integer y){
      return false;
    }
    Entity->Event accept(Entity newOccupant){
      return "floorTile".accept(newOccupant);
    }
  }
  class Chest / Tiles->Terrain     /{
    class Id / Tiles->Terrain->Id / {
    }
    Boolean isPassable(Integer x, Integer y){
      return false;
    }
    Entity->Event accept(Entity newOccupant){
      return "floorTile".accept(newOccupant);
    }
  }
  class EntryPoint / Tiles->Floor     / {
    class Id      / Tiles->Floor->Id / {
    }
    ~Tiles->EntryPoint sister = null;
    ~Environment sisterGenerator = null;
    Entity->Event accept(Entity newOccupant){
      if sister == null {
        
        Area newArea = sisterGenerator.getAreaGenerator().generate();
        if newArea != null {
		  newArea.load();
          sisterGenerator.add(newArea);
          newArea.join(this);
        }
      }
      sister.take(newOccupant);
      return new Entity->Event->MovedToNewArea(\area, sister.getArea());
    }
    void setArea(Area newArea){
      super.setArea(newArea);
      sisterGenerator = \area.getParent();
    }
    Entity->Event take(Entity newOccupant){
      newOccupant.getLocation().setArea(\area);
      newOccupant.explore(\area);
      return \super.accept(newOccupant);
    }
    Boolean hasOccupant(){
      return \occupant != null || ( sister != null && sister.occupant != null);
    }
    Boolean hasOccupant(Entity candidate){
      return \occupant == candidate || ( sister != null && sister.occupant == candidate);
    }
    Integer getDistanceToUnexploredPaths(Entity explorer){
      return \getDistanceToUnexploredPaths(explorer, new HashSet<EntryPoint>(),0);
    }
    Integer getDistanceToUnexploredPaths(Entity explorer,Set<EntryPoint> investigated, Integer distance){
      if investigated.add(this) {
        if explorer.hasExplored(\area) {
          Integer minimum = Integer.MAX_VALUE;
          for Tile entryPoint: sister.getArea().getEntryPoints() {
            Integer sisterDistance = "((EntryPoint)entryPoint)".getDistanceToUnexploredPaths(explorer,investigated,distance\+1);
            if sisterDistance < minimum {
              minimum = sisterDistance;
            }
          }
          return minimum;
        }
        else {
          return distance;
        }
      }
      else {
        return Integer.MAX_VALUE;
      }
    }
  }
> ~Integer costIndex = 0;
> void declaration(%T declarationToken, String mapName, List<String> floorTiles){
    if declarationToken->"floor_declaration" != null {
      declarationToken->"floor_declaration" : element : tile_definition {
        floorTiles.add(\definition(element,mapName,Tiles->Floor,Tiles));
        \definition(element,mapName,Tiles->EntryPoint,EntryPoints);
      }
    }
    else if declarationToken->"terrain_declaration" != null {
      declarationToken->"terrain_declaration" : element : tile_definition {
        \definition(element,mapName,Tiles->Terrain,Tiles);
      }
    }
    else if declarationToken->"dens_declaration" != null {
      declarationToken->"dens_declaration" : element : tile_definition {
        \definition(element,mapName,Tiles->MonsterDen,Tiles);
      }
    }
    else if declarationToken->"chests_declaration" != null {
      declarationToken->"chests_declaration" : element : tile_definition {
        \definition(element,mapName,Tiles->Chest,Tiles);
      }
    }
  }
> Statement getSelector(String mapName, %T tileIdChoice){
    Statement selector = new Statement ();
    Parameters options = new Parameters ("||");
    selector.add(|new Criteria.Destination()|);
    selector.add(|"{public boolean test(Tile candidate){return "+`options`+";}}"|);
    StringBuilder tileName = new StringBuilder();
    tileIdChoice : complete : tileName {
      complete : part : namePart {
        tileName.append('part');
      }
      if 'tileName'.equals("Entry") {
        options.add(|("candidate instanceof Tiles.EntryPoint" && ((Tiles->\EntryPoint)\candidate).\getSister().getParent().getName().equals('' 'mapName' ''))|);
      }
      else {
        options.add(|"candidate".getId() == Tiles->'mapName'->'tileName'.id|);
      }
    }
    return selector;
  }
> String definition(%T declarationToken, String mapName, Class tileExtendsClass, Class collectionClass){
    String tileName = ^declarationToken->"tileName";
    collectionClass->'mapName' += class tileName / tileExtendsClass / {
        @Tile->Id id = new tileExtendsClass->Id();
        Tile->Id getId(){
          return id;
        }
        List<Treasury\>Cost> getCosts(){
          List<Treasury\>Cost> costs = new ArrayList<Treasury\>Cost>();
        }
        void generate(){
        }
        Boolean load(){
          super.load();
        }
        Boolean tick(Double millisSinceLastFrame){
          super.tick(millisSinceLastFrame);
        }
      }
    if tileExtendsClass == Tiles->Floor || tileExtendsClass == Tiles->EntryPoint {
      if declarationToken->"IMPASSABLE" != null {
        collectionClass->'mapName'->'tileName' += Boolean isPassable(Integer directionX, Integer directionY){
          if "terrain" != null {
            return "terrain".isPassable(directionX,directionY);
          }
          else {
            return false;
          }
        }
      }
    }
    else {
      if declarationToken->"PASSABLE" != null {
        collectionClass->'mapName'->'tileName' += Boolean isPassable(Integer directionX, Integer directionY){
          return true;
        }
      }
    }
    if declarationToken->"imageId" != null {
      collectionClass->'mapName'->'tileName' += ~Gui->Drawable drawable = null;
      Body stateChangeBody = new Body ();
      String imageName = 'declarationToken->"imageName"';
      String imageClassName = ^declarationToken->"imageName";  
      StringBuilder newState = new StringBuilder();
      ~String underscore = "";
      declarationToken : element : imageId {
        newState.append(underscore);
        newState.append('element');
        underscore = "_";
      }
      if declarationToken->"width" != null {
        newState.append("_0");
      }
      String drawableSuperType;
      if tileExtendsClass == Tiles->Floor || tileExtendsClass == Tiles->EntryPoint {
        drawableSuperType = "isosquare";
      }
      else {
        drawableSuperType = "square";
      }
      if Gui.Image.multiElementImages.containsKey(imageClassName) && Gui.Image.multiElementImages.get(imageClassName).contains('newState') {
        stateChangeBody.add(|"drawable" = Images->'imageName'."getAs"+'^newState'(Drawables->'drawableSuperType');|);
      }
      else { 
      	stateChangeBody.add(|Images->'imageClassName'->States imageStates = Images->'imageName'.asStates();|);
        stateChangeBody.add(|\imageStates.'newState'();|);
        stateChangeBody.add(|"drawable" = Drawables->'drawableSuperType'.image("imageStates");|);
          
      }
      Float factor = 6f;
      Float xFactor = factor*1.85f;
      Float yFactor = factor*3.85f;
      if tileExtendsClass == Tiles->Floor || tileExtendsClass == Tiles->EntryPoint {
        stateChangeBody.add(|
          "drawable".setVisualX("(float)(getX()+getY())/"+'xFactor'+"f");
          "drawable".setVisualY("(float)(getY()-getX())/"+'yFactor'+"f");|);
        collectionClass->'mapName'->'tileName' += void display(){
		    \getDrawable().display(Renderer.botLayer);
		    if "terrain" != null {
		      "terrain".display();
		    }
		    if "occupant" != null {
		      "occupant".display();
		    }
		  }
		collectionClass->'mapName'->'tileName' += void undisplay(){
		    \getDrawable().undisplay(Renderer.botLayer);
		    if "terrain" != null {
		      "terrain".undisplay();
		    }
		    if "occupant" != null {
		      "occupant".undisplay();
		    }
		  }
      }
      else {
        stateChangeBody.add(|
          if "floorTile" != null {
            drawable.setVisualX(\floorTile.getDrawable().getVisualX());
            drawable.setVisualY(\floorTile.getDrawable().getVisualY()\+0.025f);
          }
          else {
            "drawable".setVisualX("(float)(getX()+getY())/"+'xFactor'+"f");
            "drawable".setVisualY("(float)(getY()-getX())/"+'yFactor'+"f");
          }|);
        collectionClass->'mapName'->'tileName' += void setFloorTile(Tiles->Floor newFloorTile){
            if "drawable"!=null {
			  "drawable".setVisualX(\newFloorTile.getDrawable().getVisualX());
			  "drawable".setVisualY(\newFloorTile.getDrawable().getVisualY());
	        }
		    \super.setFloorTile(\newFloorTile);
          }
        collectionClass->'mapName'->'tileName' += void display(){
		    \getDrawable().display(Renderer.midLayer);
		  }
		collectionClass->'mapName'->'tileName' += void undisplay(){
		    \getDrawable().undisplay(Renderer.midLayer);
		  }
      }
      stateChangeBody.add(|"drawable".setVisualWidth("(float)getWidth()/"+'factor'+"f");|);
      stateChangeBody.add(|"drawable".setVisualHeight("(float)getHeight()/"+'factor'+"f");|);
      collectionClass->'mapName'->'tileName' += Gui->Drawable getDrawable(){
        if "drawable" ==  null `stateChangeBody`
        return "drawable";
      }
    }
    Tiles->*"create".prependToBody({
      if "tileName".equals('' 'tileName' '') {
        return new Tiles->'mapName'->'tileName'(); 
      }
    });
    if tileExtendsClass == Tiles->Floor || tileExtendsClass == Tiles->EntryPoint {
      collectionClass->'mapName'->'tileName' += class Factory /Object/ Tiles->Floor->Factory {
        Tiles->Floor create(Integer x, Integer y, Environment parent){
          return new collectionClass->'mapName'->'tileName'(x,y,parent);
        }
        Tiles->Floor create(){
          return new collectionClass->'mapName'->'tileName'();
        }
      }
      if tileExtendsClass == Tiles->EntryPoint {
        collectionClass->'mapName'->'tileName' += class JoinGenerator /Object/ Area->TileGenerator {
          EntryPointJoinable toJoin = null;
          void generateAt(int x, int y, Area acceptor){
            Tiles->EntryPoint newEntryPoint = new collectionClass->'mapName'->'tileName'(x,y,acceptor.getParent());
            acceptor.add(newEntryPoint);
            if newEntryPoint.getSister() == null || newEntryPoint.getSister().getArea() == null {
              toJoin.join(newEntryPoint);
            }
          }
          void setInnerFloor(Area->FloorChoice choice){}
          void setLeftSideFloor(Area->FloorChoice choice){}
          void setUpSideFloor(Area->FloorChoice choice){}
          void setRightSideFloor(Area->FloorChoice choice){}
          void setDownSideFloor(Area->FloorChoice choice){}
          void setRelativeFloor(Area->FloorChoice choice, int index, int startX, int startY){}
        }
      }
    }
    else {
      collectionClass->'mapName'->'tileName' += class Factory /Object/ Tiles->Terrain->Factory {
        Tiles->Terrain create(Tiles->Floor parentTile){
          Tiles->Terrain newTile = new collectionClass->'mapName'->'tileName'();
          newTile.setFloorTile(parentTile);
          return newTile;
        }
        Tiles->Terrain create(){
          return new collectionClass->'mapName'->'tileName'();
        }
      }
      ~Integer parentCount = 0;
      Body parentSwitchBodyOne = new Body ();
      Body parentSwitchBodyTwo = new Body ();
      declarationToken : floorParent : floorParentName{
        Integer parentCountValue = parentCount;
        parentSwitchBodyOne.add(|case 'parentCountValue' { return new Tiles->'mapName'->'floorParent'(\x,\y,\parent); }|);
        parentSwitchBodyTwo.add(|case 'parentCountValue' { return new Tiles->'mapName'->'floorParent'(); }|);
        parentCount \+= 1;
      }
      if parentCount > 1 {
        Integer parentCountValue = parentCount;
        collectionClass->'mapName'->'tileName' += class FloorFactory /Object/ Tiles->Floor->Factory {
          Tiles->Floor create(Integer x, Integer y, Environment parent){
            switch Range.getRandom(0,'parentCountValue') `parentSwitchBodyOne`
            return null;
          }
          Tiles->Floor create(){
            switch Range.getRandom(0,'parentCountValue') `parentSwitchBodyTwo`
            return null;
          }
        }
      }
      else {
        declarationToken : floorParent : floorParentName {
          collectionClass->'mapName'->'tileName' += class FloorFactory /Object/ Tiles->Floor->Factory {
            Tiles->Floor create(Integer x, Integer y, Environment parent){
              return new Tiles->'mapName'->'floorParent'(x,y,parent);
            }
            Tiles->Floor create(){
              return new Tiles->'mapName'->'floorParent'();
            }
          }
        }
      }
    }
    collectionClass->'mapName'->'tileName' += class Placer // Menu->Placable {
      void place(Area area, Integer placeX, Integer placeY){
        area.add(new collectionClass->'mapName'->'tileName'(placeX,placeY,area.getParent()));
      }
    }
	declarationToken : element : tile_rate {
	  element : atom : tile_cost {
	    collectionClass->'mapName'->'tileName'->*"getCosts".appendToBody({"costs".add(`\getTileCost(atom,collectionClass,mapName,tileName)`);});
	  }
    }
	collectionClass->'mapName'->'tileName'->*"getCosts".appendToBody({return "costs";});
    if declarationToken->"entity" != null {
	  ~Integer entityPlusNumber = 0;
      Body switchBody = new Body ();
      collectionClass->'mapName'->'tileName' += ~Integer numberOfMonsters = "0";
      collectionClass->'mapName'->'tileName' += ~Integer maxNumberOfMonsters = "0";
      declarationToken : element : entity {
        element : quanta : PLUS {
          entityPlusNumber \+= 1;
        }
      }
      Integer plusNumber = entityPlusNumber;
      ~Integer numberOfMonsters = 0;
      declarationToken : element : entity {
        numberOfMonsters \+= 1; 
      }
      collectionClass->'mapName'->'tileName'->*"load".appendToBody({
        "maxNumberOfMonsters" = Range.getRandom(0,'plusNumber');
        });
      collectionClass->'mapName'->'tileName'->*"tick".prependToBody({
        while "numberOfMonsters" < "maxNumberOfMonsters" {
          \generateMonster();
        }
        });
      Integer numberOfMonstersValue = numberOfMonsters;
      collectionClass->'mapName'->'tileName' += void generateMonster(){
        switch  Range.getRandom(0,'numberOfMonstersValue') `switchBody`
        "++numberOfMonsters";}
      
      ~Integer monsterInc = 0;
      declarationToken : element : entity {            
        Class entityFactory = Entities.declaration(element->"entity_declaration");
        String newEntityName = "newEntity"+'element->"entity_declaration"->"entityName"';
        
        if element->"MINUS" != null {
          collectionClass->'mapName'->'tileName'->*"load".prependToBody(|
            if 'newEntityName'.getLocation().moveToAround(\getFloorTile()) {
              'newEntityName'.setSpawn(\getFloorTile());
              'newEntityName'.add(new Tile->Listener->Die(\getFloorTile()));
            }|);
          collectionClass->'mapName'->'tileName'->*"load".prependToBody(|
            Entity 'newEntityName' = new entityFactory().create();|);
        }
        else {
          Integer monsterId = monsterInc;
          collectionClass->'mapName'->'tileName' += ~Entity->Factory 'element->"entity_declaration"->"entityName"'+"Factory" = new entityFactory();
          switchBody.add(|
            case 'monsterId' {
              Entity 'newEntityName' = 'element->"entity_declaration"->"entityName"'+"Factory".create();
              if 'newEntityName'.getLocation().moveToAround(\getFloorTile()) {
                'newEntityName'.setSpawn(\getFloorTile());
                'newEntityName'.add(new Tile->Listener->Die(\getFloorTile()));
              }
            }|);
        }
        monsterInc \+= 1;
      } 
    }
    collectionClass->'mapName'->'tileName'->*"load".appendToBody(|return true;|);
    collectionClass->'mapName'->'tileName'->*"tick".appendToBody(|return true;|);
    return tileName;
  }

> Statement getTileCost(%T tileCostToken,Class collectionClass, String mapName, String tileName){
    String costName = "Cost" \+ costIndex;
    costIndex \+= 1;
    if tileCostToken->"FREE" != null {
      collectionClass->'mapName'->'tileName' += class costName / Treasury->Cost / {
        Treasury->Reward getReward() {
          return new collectionClass->'mapName'->'tileName'->'costName'->Reward(); 
        }
        Boolean isFree(){
          return true;
        }
      }
      collectionClass->'mapName'->'tileName'->'costName' += class Reward / Treasury->Reward / {
        Boolean isPlacable(){
          return true;
        }
        Menu->Placable getPlacable(){
          return new collectionClass->'mapName'->'tileName'->\Placer();
        }
      }
      return |new collectionClass->'mapName'->'tileName'->'costName'()|;
    }
    else {
      String paymentType = Treasury.getTypeName(tileCostToken->"tile_payment_type");
      if tileCostToken->"payment" != null {
        collectionClass->'mapName'->'tileName' += class costName / Treasury->Cost / {
          Integer getAmount(){
            return 'tileCostToken->"payment"';
          }
          Treasury->PaymentType->Id getType(){
            return Treasury->PaymentTypes->'paymentType'.id;
          }
          Treasury->Reward getReward() {
            return new collectionClass->'mapName'->'tileName'->'costName'->Reward(); 
          }
        }
      }
      else {
        collectionClass->'mapName'->'tileName' += class costName / Treasury->Cost / {
          Treasury->PaymentType->Id getType(){
            return Treasury->PaymentTypes->'paymentType'.id;
          }
          Treasury->Reward getReward() {
            return new collectionClass->'mapName'->'tileName'->'costName'->Reward(); 
          }
        }
      }
      collectionClass->'mapName'->'tileName'->'costName' += class Reward / Treasury->Reward / {
        Boolean isPlacable(){
          return true;
        }
        Menu->Placable getPlacable(){
          return new collectionClass->'mapName'->'tileName'->\Placer();
        }
      }
      return |new collectionClass->'mapName'->'tileName'->'costName'()|;
    }
  }

}
class 'packageName'.environments  Tile   Environment->Position   Loaddable Tickable Environment->Areaable  {
  class Id // {
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Tile> {
        Environment->Position origin = null;
        \int compare(Tile tile1, Tile tile2){
          double distance1 = origin.getDistanceTo(tile1);
          double distance2 = origin.getDistanceTo(tile2);
          if distance1 == distance2 {
            if tile1 == tile2 {
              return 0;
            }
            else {
              return -1;
            }
          }
          else {
            if distance1 > distance2 {
              return 1;
            }
            else {
              return -1;
            }
          }
        }
        class Complex // Comparator<Tile> {
          Environment->Position origin = null;
          \int compare(Tile tile1, Tile tile2){
            int distance1 = 0;
            int distance2 = 0;
            Area originArea = null;
            if "origin instanceof Environment.Areaable" {
              originArea = ((Environment->Areaable)origin).\getArea();
            }
            if originArea!= null && originArea != tile1.getArea() {
              distance1 = (int)(double) tile1.getArea().getSisterAreas().get(originArea).getDistanceTo(tile1);
            }
            else {
              distance1 = (int)(double) origin.getDistanceTo(tile1);
            }
            if originArea != null && originArea != tile2.getArea() {
              distance1 = (int)(double) tile2.getArea().getSisterAreas().get(originArea).getDistanceTo(tile2);
            }
            else {
              distance2 = (int)(double) origin.getDistanceTo(tile2);
            }
            if distance1 == distance2 {
              if tile1 == tile2 {
                return 0;
              }
              else {
                return -1;
              }
            }
            else {
              return distance1 \- distance2;
            }
          }
        }
      }
      class Descending // Comparator<Tile> {
        Environment->Position origin = null;
        \int compare(Tile tile1, Tile tile2){
          return "(int)(float)(origin.getDistanceTo(tile2) - origin.getDistanceTo(tile1))";
        }
      }
    }
  }
  interface Factory // {
    Tile create(){}
  }
  class Listener // {
    class Die   / Events->Die->Listener /{
      Tiles->Floor host = null;
      Boolean listen(Events->Die event){
        return true;
      }
    }
  }
  ~Integer width = 1;
  ~Integer height = 1;
  ~Area area = null;
  ~Tiles->Floor rightNeighbour = null;
  ~Tiles->Floor upNeighbour = null;
  ~Tiles->Floor leftNeighbour = null;
  ~Tiles->Floor downNeighbour = null;
  
  Tile->Id getId(){
    return null;
  }
  void resetNeighbour(Tile oldTile){
    if upNeighbour == oldTile {
      upNeighbour = null;
    }
    else if downNeighbour == oldTile {
      downNeighbour = null;
    }
    else if leftNeighbour == oldTile {
      leftNeighbour = null;
    }
    else if rightNeighbour == oldTile {
      rightNeighbour = null;
    }
  }
  ArrayList<Tiles\>Floor> getNeighbours(){
    ArrayList<Tiles\>Floor> neighbours = new ArrayList<Tiles\>Floor>();
    if \getNeighbour(Direction.right)!= null {
      neighbours.add(rightNeighbour);
    }
    if \getNeighbour(Direction.left)!= null {
      neighbours.add(leftNeighbour);
    }
    if \getNeighbour(Direction.up)!= null {
      neighbours.add(upNeighbour);
    }
    if \getNeighbour(Direction.down)!= null {
      neighbours.add(downNeighbour);
    }
    return neighbours;
  }
  Tiles->Floor getNeighbour(Direction direction){
    if area == null {
      return null;
    }
    if direction == Direction.right {
      if rightNeighbour == null {
        rightNeighbour = area.getTile(\getX()\+1,\getY());
      }
      return rightNeighbour;
    }
    else if direction == Direction.left {
      if leftNeighbour == null {
        leftNeighbour = area.getTile(\getX()\-1,\getY());
      }
      return leftNeighbour;
    }
    else if direction == Direction.up {
      if upNeighbour == null {
        upNeighbour = area.getTile(\getX(),\getY()\+1);
      }
      return upNeighbour;
    }
    else if direction == Direction.down {
      if downNeighbour == null {
        downNeighbour = area.getTile(\getX(),\getY()\-1);
      }
      return downNeighbour;
    }
    else {
	  return null;
    }
  }
  Boolean isPassable(Integer directionX, Integer directionY){
    return true;
  }
  Boolean isPassable(Tile previousTile){
    return \isPassable(previousTile.getX()\-\getX(),previousTile.getY()\-\getY());
  }
  Boolean isWithin(Environment->Position otherPosition){
    return \super.isWithin(otherPosition, width, height);
  }
  Gui->Drawable getDrawable(){
    return null;
  }
  void generate(){
  }
  Boolean load(){
    return true;
  }
  Boolean tick(Double millisSinceLastFrame){
    return true;
  }
  void display(){
  }
  void undisplay(){
  }
  Entity->Event accept(Entity newOccupant){
    Environment->Location location = newOccupant.getLocation();
    location.setX(\getX());
    location.setY(\getY());
    return null;
  }
  Association get(Association->Id id, Association->Factory factory){
    return "associations".get(id,factory);
  }
  String toString(){
	return '' "(" '' \+ \getX() \+ '' "," '' \+ \ getY() \+ '' ")" '';
  }
> void setup(%Pass data){
    \createIdMap(Association->Id,Association);
    \createIdMap(Tile->Id, Tile);
    \createIdMap(Tiles->Floor->Id, Tiles->Floor);
    \createIdMap(Tiles->Terrain->Id, Tiles->Terrain);
    Tile += ~'"com.rem.qstnr.misc.maps.IdMap"'->\_Association associations;
  }
}
interface 'packageName'.interfaces EntryPointJoinable {
  Boolean join(Tiles->EntryPoint entryPoint){}
}
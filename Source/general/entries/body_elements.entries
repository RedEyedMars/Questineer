uses Class Arrays
property body_element
	var parentContext as context
	var tab = 0
	var importList = []
	
	setParentContext takes newParent as context
		set parentContext = newParent

entry body_lines uses body_element
	var values as ListEntry
	
	constructor takes iContext as context
		set parentContext = iContext
		set values = {}
		values setDelimiter:"";
	constructor takes iValues as ListEntry
		set values = {}
		values setDelimiter:"";
		each e as Entry in iValues
			this addLine
				e
	constructor takes iValues as ListEntry, iContext as context
		set parentContext = iContext
		set values = {}
		values setDelimiter:"";
		each e as Entry in iValues
			this addLine
				e
	addLine takes newLine as body_element
		values+=newLine
	addLine takes newLine as body_statement
		values+=
			body_line:newLine parentContext;
	addLine takes newEntry as Entry
		var ec as Class
			newEntry getClass
		var interfaces as List<Class>
			static Arrays asList
				ec getInterfaces
		each i as Class in interfaces
			var ecn
				i getSimpleName
			if ecn is "IBodyElement"
				values add
					newEntry
				return
					"done"
			else
				if ecn is "IBodyStatement"
					values+=
						body_line:newEntry parentContext;
					return
						"done"
		values+=
			body_line:body_exact:newEntry; parentContext;
		return
			"done"
	addAll takes importer as body_lines
		var oValues as ListEntry
			importer getValues
		each oe as Entry in oValues
			var be as body_element = oe
			be setParentContext
				parentContext
			values+=be
	size as Integer
		return
			values size
	get takes index as Integer
		return as body_element
			values get
				index
	
	setParentContext takes newParent as context
		each e as Entry in values
			var be as body_element = e
			be setParentContext
				newParent
		set parentContext = newParent
	output
			|values| if values is not null
		each e as Entry in values
			var be as body_element = e
			importList+=
				be getImportList
entry body_line uses body_element
	var value as body_statement
	constructor takes iEntry as Entry
		set value as body_statement = iEntry
	constructor takes iValue as body_statement
		set value = iValue
	constructor takes iValue as body_statement, iContext as context
		set parentContext = iContext
		set value = iValue
	constructor takes iValue as Entry, iContext as context
		set parentContext = iContext
		set value as body_statement = iValue
	output
			(tab |value|) if value is not null
			+
			\";" if value is not null
		set tab
			parentContext getTab
		set tab = tab + 1
		importList+=
			value getImportList
entry body_return uses body_element
	var value as body_statement
	constructor takes iEntry as Entry
		set value = body_exact:iEntry;
	constructor takes iValue as body_statement
		set value = iValue
	constructor takes iValue as body_statement, iContext as context
		set parentContext = iContext
		set value = iValue
	constructor takes iValue as Entry, iContext as context
		set parentContext = iContext
		set value = body_exact:iValue;
	output
			(tab general returnCall{value}) if value is not null
			+
			\";" if value is not null
		set tab
			parentContext getTab
		set tab = tab + 1
		importList+=
			value getImportList

entry body_conditional uses body_element
	var name
	var header as body_statement
	var body as body_lines
	
	constructor takes iName, iBody as body_lines, iContext as context
		set name = iName
		set body = iBody
		set parentContext = iContext
	constructor takes iName, iHeader as body_statement, iBody as body_lines, iContext as context
		set name = iName
		set header = iHeader
		set body = iBody
		set parentContext = iContext
	constructor takes iName, iHeader as body_statement, iBody as body_lines
		set name = iName
		set header = iHeader
		set body = iBody
	constructor takes iName, iBody as ListEntry, iContext as context
		set name = iName
		set body = body_lines:iBody namelessContext:iContext;;
		set parentContext = iContext
	constructor takes iName, iHeader as body_statement, iBody as ListEntry, iContext as context
		set name = iName
		set header = iHeader
		set body = body_lines:iBody namelessContext:iContext;;
		set parentContext = iContext
	constructor takes iName, iHeader as body_statement, iBody as ListEntry
		set name = iName
		set header = iHeader
		set body = body_lines:iBody;
	
	setParentContext takes newParent as context
		body setParentContext
			newParent
		set parentContext = newParent
	output
			(tab general conditionalWithHeader {\name header body}) if header is not null
			(tab general conditionalWithoutHeader {\name body } ) if header is null
			+
			(tab \"}") if name is not null
		set tab
			parentContext getTab
		set tab = tab + 1
		var delimiterBuilder
			new StringBuilder
		if header is not null
			importList+=
				header getImportList
		var values as ListEntry
			body getValues
		each e as Entry in values
			var be as body_element = e
			importList+=
				be getImportList

property body_statement
	var importList = []
	hasEnd
		return
			true
entry body_dec_var uses body_statement
	var variable as variable
	var assignment as body_statement
	constructor takes iVariable as variable
		set variable = iVariable
		set assignment
			variable getAssignment
	constructor takes iVariable as Entry
		set variable as variable = iVariable
		var vType as class
		set assignment
			variable getAssignment
	constructor takes iVariable as variable, iAssignment as body_statement
		set variable = iVariable
		set assignment = iAssignment
	constructor takes iVariable as Entry, iAssignment as Entry
		set variable as variable = iVariable
		set assignment as body_statement = iAssignment
	
	output
			{variable->SHOW_COMPLETE_TYPE} if assignment is null
			general operator{variable->SHOW_COMPLETE_TYPE \"=" assignment} if assignment is not null
		var vType as class
			variable getType
		importList+=
			vType getImportList
		if assignment is not null	
			importList+=
				assignment getImportList

entry body_operator uses body_statement
	var left as body_statement
	var operator
	var right as body_statement
	constructor takes iLeft as body_statement,iOperator, iRight as body_statement
		set left = iLeft
		set operator = iOperator
		set right = iRight
	constructor takes iLeft as body_statement,iOperator
		set left = iLeft
		set operator = iOperator
	constructor takes iLeft as body_statement
		set left = iLeft
	constructor takes iLeft as Entry,iOperator, iRight as Entry
		set left = body_exact:iLeft;
		set operator = iOperator
		set right = body_exact:iRight;
	constructor takes iLeft as Entry,iOperator
		set left as body_statement = iLeft
		set operator = iOperator
	constructor takes iLeft as Entry
		set left = body_exact:iLeft;
	setRight takes newRight as body_statement
		set right = newRight
	setRight takes newRight as Entry
		set right = body_exact:newRight;
	
	
	output
			general exact{left} if right is null
			general operator{left \operator right} otherwise
		importList+=
			left getImportList
		if right is not null
			importList+=
				right getImportList
entry body_new_obj uses body_statement
	var type as class
	var parameters as ListEntry
	constructor takes iClass as class
		set type  = iClass
		set parameters = {}
	constructor takes iClass as class, iParameters as ListEntry
		set type  = iClass
		set parameters = iParameters
	
	output
			general newObjectCall { type->COMPLETE_NAME parameters } if parameters is not null
		importList+=
			type getImportPackage
		each e as Entry in parameters
			var be as body_statement = e
			importList+=
				be getImportList


entry body_met_cal uses body_statement
	var subject as body_statement
	entry methodName = null
	var parameters as ListEntry
	constructor takes iMethodName as Entry
		set methodName  = iMethodName
		set parameters = {}
	constructor takes iMethodName as Entry, iParameters as ListEntry
		set methodName  = iMethodName
		set parameters = iParameters
	constructor takes iSubject as body_statement, iMethodName as Entry, iParameters as ListEntry
		set subject = iSubject
		set methodName  = iMethodName
		set parameters = iParameters
	constructor takes iSubject as Entry, iMethodName as Entry, iParameters as ListEntry
		set subject = body_exact:iSubject;
		set methodName  = iMethodName
		set parameters = iParameters
	
	output
			general subjectlessMethodCall { methodName parameters } if subject is null
			general methodCall { subject methodName parameters } if subject is not null
		if subject is not null
			importList+=
				subject getImportList
		each e as Entry in parameters
			var be as body_statement = e
			importList+=
				be getImportList

entry body_exact uses body_statement
	entry value = null
	constructor takes iEntry as Entry
		set value = iEntry
	
	output
			value if value is not null
entry body_entry uses body_statement
	var value as body_statement = null
	constructor takes iValue as body_statement
		set value = iValue
	constructor takes iValue as Entry
		set value as body_statement = iValue
	setValue takes newValue as body_statement
		set value = newValue
	hasEnd as Boolean
		if value is null
			return
				false
		return
			value hasEnd
	output
			|value| if value is not null
		if value is not null
			importList+=
				value getImportList
entry body_negate uses body_statement
	var value as body_statement = null
	constructor takes iValue as body_statement
		set value = iValue
	constructor takes iValue as Entry
		set value as body_statement = iValue
	
	output
			general negate{value} if value is not null
		importList+=
			value getImportList
entry body_braced uses body_statement
	var value as body_statement = null
	constructor takes iValue as body_statement
		set value = iValue
	constructor takes iValue as Entry
		set value as body_statement = iValue
	
	output
			general braced{value} if value is not null
		importList+=
			value getImportList
entry body_static uses body_statement
	var type as class = null
	var value as Entry
	constructor takes iClass as class, iValue as Entry 
		set value = iValue
		set type = iClass
	
	output
			general asPackageName{type->COMPLETE_NAME value} if value is not null
		importList+=
			type getImportPackage

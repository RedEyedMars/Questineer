entry class uses context
	constant NAME
		0
	constant NAME_WITH_IMPORTS
		1
	constant COMPLETE_NAME
		2
	constant COMPLETE
		3
	constant INTERFACE
		4
	
	var name
	var mode = NAME
	entry importPackage = null
	entry importList "" = []
	entry nameWithTemps = null
	entry templateParameters = null
	entry parentClasses = null
	entry parentClass = null
	entry completeName "." = {}
	entry variableList "" = {}
	entry methodList "" = {}
	entry constructorBody = null
	entry constructorParameters = {}
	entry constructorAssignments "" = {}
	entry subClassList "" = {}
	var defaultAssignment = body_entry:null;
	var defaultEnder = body_entry:null;
	
	var subClasses
		new HashMap<String,class>
	var methodBodies
		new HashMap<String,body_lines>
	
	entry surroundClass = {}
	var isInited = false
	
	constructor takes iName
		set name = iName
		set importPackage = import:"java.lang" name;
		completeName += \name	
	constructor takes iClone as class
		this copy:iClone;
	constructor takes iPackageName, iName, iTemplateParameters as ListEntry
		this init:iPackageName iName iTemplateParameters null null {}{}{};
	constructor takes iPackageName, iName as class, iParentClass as class, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iSubClasses as ListEntry
		var sName
			iName getName
		this init:iPackageName sName null iParentClass iInterfaces iVariables iMethods iSubClasses;
	constructor takes iPackageName, iName, iParentClass as class, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iSubClasses as ListEntry
		this init:iPackageName iName null iParentClass iInterfaces iVariables iMethods iSubClasses;
	
	init takes iPackageName, iName, iTemplateParameters as ListEntry, iParentClass as class, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iSubClasses as ListEntry
		var self as class
			this getSelf
		importList setDelimiter:"";
		completeName setDelimiter:".";
		variableList setDelimiter:"";
		methodList setDelimiter:"";
		set constructorBody = body_lines:{} self;
		constructorAssignments setDelimiter:"";
		subClassList setDelimiter:"";
		set isInited = true
		set name = iName
		set importPackage = import:iPackageName name;
		completeName clear
		completeName += \name
		if iTemplateParameters is not null and iTemplateParameters is not empty
			set templateParameters = iTemplateParameters
		set parentClasses = {}
		defaultAssignment setValue
			body_new_obj:self {};
		if iParentClass is not null or iInterfaces is not null
			parentClasses setDelimiter:" ";
			if iParentClass is not null
				var pccn as Entry
					iParentClass get
						"COMPLETE_NAME"
				set parentClass = iParentClass 
				parentClasses+=general extends{pccn}
				this setDefaultEnder
					iParentClass getDefaultEnder
				importList+=
					iParentClass getImportPackage
				importList+=
					iParentClass getImportList
			if iInterfaces is not null and iInterfaces is not empty
				entry interfaces = {}
				parentClasses+=general implements{interfaces}
				each ent as Entry in iInterfaces
					var i as class = ent
					interfaces+=
						i get
							"COMPLETE_NAME"
					importList+=
						i getImportPackage
					importList+=
						i getImportList
		each ent as Entry in iVariables
			var v as variable = ent
			this addVariable
				v
		each ent as Entry in iMethods
			var m as method = ent
			this addMethod
				m
		each ent as Entry in iSubClasses
			var sc as class = ent
			this addSubClass
				sc
		var selfVariable
			variable:"this" self;
		selfVariable setIsHidden
			true
		this addVariable
			selfVariable
	copy takes iClone as class
		set name
			iClone getName
		set completeName
			iClone getCompleteName
		if importPackage is null
			set importPackage = import:"java.lang" name;
		importPackage setSuperPackage
			iClone getImportPackage
		set surroundClass
			iClone getSurroundClass
		if isInited is false
			this setDefaultAssignment
				iClone getDefaultAssignment
			set defaultEnder
				iClone getDefaultEnder
			set variables
				iClone getVariables
			set methods
				iClone getMethods
			set methodHeaders
				iClone getMethodHeaders
			set parentClasses
				iClone getParentClasses
			set parentClass
				iClone getParentClass
			set importList
				iClone getImportList
			set variableList
				iClone getVariableList
			set methodList
				iClone getMethodList
			set constructorBody
				iClone getConstructorBody
			set constructorParameters
				iClone getConstructorParameters
			set constructorAssignments
				iClone getConstructorAssignments
			set subClassList
				iClone getSubClassList
			set subClasses
				iClone getSubClasses
			set templateParameters
				iClone getTemplateParameters
			set isInited = true
	
	addVariable takes v as variable
		var self as class
			this getSelf
		var vName
			v getName
		var vType as class
			v getType
		variables put
			vName
			v
		if v does not getIsHidden
			var declarationVariable as variable
				v->SHOW_COMPLETE_TYPE->DECLARATION
			declarationVariable setAccessIfNot
				static variable PUBLIC
				static variable PROTECTED
			variableList += body_line:body_dec_var:declarationVariable; self;
			importList+=
				vType getImportPackage
			if v does not isStatic
				if v does not isFinal
					constructorParameters += v->AS_PARAMETER->SHOW_COMPLETE_TYPE
					constructorAssignments +=
						body_line:body_operator:v->SIMPLE "=" v->AS_PARAMETER; self;
			var getMethodName
				general buildString
					"get"
					^vName
			this addMethod
				method:getMethodName vType {} {general returnCall{\vName}};
	addMethod takes m as method
		var methodName
			m getName
		if methods does not containsKey methodName
			var self as class
				this getSelf
			methodHeaders put
				methodName
				m getHeader
			entry methodBody = body_lines:{} self;
			m setParent
				self
			methodBodies put
				methodName
				methodBody
			var methodType as class
				m getType
			var methodParameters as ListEntry
				m getParameters
			importList+=
				methodType getImportPackage
			each param as Entry in methodParameters
				var p as variable = param
				var pType as class
					p getType
				importList+=
					pType getImportPackage
			var realMethod
				 method:methodName methodType methodParameters methodBody;
			realMethod setMode
				m getMode
			methodList +=
				body_lines:{body_exact:realMethod;} namelessContext:self;;
			realMethod setParent
				self
		var methodBody as body_lines
			methodBodies get
				methodName
		methodBody addAll
			m getBody
	addSubClass takes sc as class
		var className
			sc getFullName
		if subClasses does not containsKey className
			subClasses put
				className
				sc
			importList += 
				sc getImportList
			var completeClass as class
				sc get
					"COMPLETE"
			var self as class
				this getSelf
			subClassList += body_lines:{body_exact:completeClass;} self;		
			sc setSuperClass
				this getSelf
	addSubInterface takes sc as class
		var className
			sc getFullName
		if subClasses does not containsKey className
			subClasses put
				className
				sc
			importList += 
				sc getImportList
			var completeClass as class
				sc get
					"INTERFACE"
			var self as class
				this getSelf
			subClassList += body_lines:{body_exact:completeClass;} self;		
			sc setSuperClass
				this getSelf
			sc setDefaultAssignment
				body_exact:\"null";
	addImport takes packageName, className
		importList+=import:packageName className;
		
	setSuperClass takes sc as class
		surroundClass clear
		surroundClass += sc
		importPackage setSuperPackage
			sc getImportPackage
		completeName clear
		completeName +=
			sc getCompleteName
		completeName +=	name
		var self as class
			this getSelf
		general init
			self
	setDefaultAssignment takes newAssignment as body_statement
		defaultAssignment setValue
			newAssignment
	setDefaultEnder takes newAssignment as body_statement
		defaultEnder setValue
			newAssignment
	addToConstructor takes be as body_element
		var self as class
			this getSelf
		be setParentContext
			self
		constructorBody addLine
			be
	addToConstructor takes be as body_statement
		constructorBody addLine
			be
	
	getJustCompleteName
		var nameBuilder
			new StringBuilder
		completeName get
			nameBuilder
		return
			'nameBuilder
	getFullName
		var nameBuilder
			new StringBuilder
		completeName get
			nameBuilder
		if templateParameters is not null and templateParameters is not empty
			nameBuilder append
				"<"
			templateParameters get
				nameBuilder 
			nameBuilder append
				">" 
		return
			'nameBuilder
	setMode takes newMode as Integer
		set mode = newMode
	deleteImportPackage
		importPackage setName
			""
	get takes option
		if option is "INTERFACE"
			this setDefaultAssignment
				body_exact:\"null";
		var self as class
			this getSelf
		var ret = class:self;
		if option is "WITHOUT_IMPORT"
			ret deleteImportPackage
			return
				ret
		if option is "NAME"
			ret setMode:NAME;
			return
				ret
		if option is "NAME_WITH_IMPORTS"
			ret setMode:NAME_WITH_IMPORTS;
			return
				ret
		if option is "COMPLETE_NAME"
			if mode is NAME_WITH_IMPORTS
				ret setMode:NAME_WITH_IMPORTS;
			else
				ret setMode:COMPLETE_NAME;
			return
				ret
		if option is "COMPLETE"
			ret setMode:COMPLETE;
			return
				ret
		if option is "INTERFACE"
			ret setMode:INTERFACE;
			return
				ret
		return
			ret
	output
			\name if mode is NAME
			general asPackageName {importPackage->PLAIN \name} if mode is NAME_WITH_IMPORTS
			completeName if mode is COMPLETE_NAME
			general declareInterface			{ importPackage->AS_PACKAGE importList \name methodList } if mode is INTERFACE and surroundClass is empty
			general declareSubInterface			{ \name methodList } if mode is INTERFACE and surroundClass is not empty
			general declareCustomWithDefault    { importPackage->AS_PACKAGE importList nameWithTemps parentClasses variableList \name constructorBody \name constructorParameters constructorAssignments constructorBody methodList subClassList } if mode is COMPLETE and surroundClass is     empty and constructorParameters is not empty
			general declareCustomSubWithDefault {				               		   nameWithTemps parentClasses variableList \name constructorBody \name constructorParameters constructorAssignments constructorBody methodList subClassList } if mode is COMPLETE and surroundClass is not empty and constructorParameters is not empty
			general declareCustom               { importPackage->AS_PACKAGE importList nameWithTemps parentClasses variableList \name constructorBody                                                                    methodList subClassList } if mode is COMPLETE and surroundClass is     empty and constructorParameters is empty
			general declareCustomSub            {                                      nameWithTemps parentClasses variableList \name constructorBody                                                                    methodList subClassList } if mode is COMPLETE and surroundClass is not empty and constructorParameters is empty
			+
			general templateParameters{templateParameters} if templateParameters is not null and templateParameters is not empty and mode is NAME
			general templateParameters{templateParameters} if templateParameters is not null and templateParameters is not empty and mode is NAME_WITH_IMPORTS
			general templateParameters{templateParameters} if templateParameters is not null and templateParameters is not empty and mode is COMPLETE_NAME
		if templateParameters is not null and templateParameters is not empty
			set nameWithTemps as Entry
				general nameWithTemplateParameters{\name templateParameters}
		else
			set nameWithTemps as Entry = \name
events
	elements from "events.elements"
	
	var directory
	var packageName
	var variableDefs
		new HashMap<String,ListEntry>
	var eventNameSet
		new HashSet<String>
	var methodHeaders = {}
	var methodParameters = {}
	var superEventsClass as class
	var superEventClass as class
	aux setup takes data as ParseContext
		set packageName
			general getPackageName
		set directory
			new File
				general getDirectory
				"events"
		directory mkdirs
		set superEventsClass
			general init:class:"events" "Events" null null {} {} {};;
		set superEventClass
			general init:class:"events" "Event" null null {} {} {};;
		events addFile
			directory
			"Event.java"
			superEventClass->COMPLETE
		events addFile
			directory
			"Events.java"
			superEventsClass->COMPLETE
	
	generate eventDeclaration
		var eventName
			'eventDeclaration->eventName
		eventNameSet+=eventName
		entry variables = {}
		eventDeclaration parameter to element
			element type_name to atom
				entry typeName = generate general typeName:;
				variables+=variable:'element->name 'typeName;
		var eventClass
			class:"events" ^eventName superEventClass null variables {} {} ;
		superEventsClass addSubClass
			eventClass
		general init
			eventClass
		var methodHeaderName
				events buildString
				"on"
				^eventName
		var parameterType
			events buildString
				"Events."
				^eventName
		entry header = variable:methodHeaderName "void";
		header setMode
			static variable WITH_TYPE
		methodHeaders+=header
		entry parameter = variable:"event" parameterType;
		methodParameters+=
			{parameter->SHOW_TYPE}
		return
			null
	
	aux getEventContext takes eName, inputClass as class
		var eventContext
			namelessContext:inputClass;
		var eventClassName
			events buildString
				"Events."
				^eName
		eventContext addVariable
			variable:"event" eventClassName;
		return
			eventContext
	aux addEventMethod takes eName, inputClass as class, body as ListEntry
		var eventName
			events buildString
				"on"
				^eName
		var eventParameter
			events buildString
				"Events."
				^eName
		var inputParentClass as class
			inputClass getParentClass
		if inputParentClass is null
			inputClass addMethod
				method:eventName "void" {variable:"event" eventParameter;} body;
		else
			var inputSuperMethods as HashMap<String,variable>
				inputParentClass getMethodHeaders
			if inputSuperMethods does containsKey eventName
				inputClass addMethod
					method:eventName "void" {variable:"event" eventParameter;} {
						body_met_cal:body_exact:\"super"; \eventName {body_exact:\"event";};
						body};
			else
				inputClass addMethod
					method:eventName "void" {variable:"event" eventParameter;} body;
	
	aux addEventMethods takes inputClass as class, nameDefs as ListEntry, bodyDefs as ListEntry
		var numberOfNames
			nameDefs size
		each eventName in eventNameSet
			var setBody = false
			each i in 0..numberOfNames
				if 'nameDefs->i is eventName
					events addEventMethod
						eventName
						inputClass
						bodyDefs get:i; as ListEntry
					set setBody = true
			if setBody is false
				events addEventMethod:eventName inputClass {};
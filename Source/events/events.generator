events
	elements from "events.elements"
	
	var directory
	var packageName
	var variableDefs
		new HashMap<String,ListEntry>
	var methodHeaders = {}
	var methodParameters = {}
	aux setup takes data as ParseContext
		set packageName
			general getPackageName
		set directory
			new File
				general getDirectory
				"events"
		directory mkdirs
	aux generate takes data as ParseContext
		entry imports "" = {}
		entry eventClasses "" = {}
		events addFile
			directory
			"Event.java"
			general createType:"events" {} "Event" null null {} {} {} {}; as ElementEntry		
		events addFile
			directory
			"Events.java"
			declareEventsClass { \packageName imports eventClasses }
		general createType:"events" {} "Events" null null {} {} {} {};
		var eventClass as vtype
			general getType
				"Event"
		var pList as ParseList
			data getList
				"event_names"
		var nParser as NameParser
			pList getNamesParser
		var sElements as Set<String>
			nParser getElements
		
		variableDefs put
			"gained"
			{variable:"host" "Entity"; variable:"trait" "Trait";}
		variableDefs put
			"lost"
			{variable:"host" "Entity"; variable:"trait" "Trait";}
		variableDefs put
			"equip"
			{variable:"host" "Entity"; variable:"item" "Item";}
		variableDefs put
			"unequip"
			{variable:"host" "Entity"; variable:"item" "Item";}
		variableDefs put
			"change_item"
			{variable:"host" "Entity"; variable:"item" "Item";}
		variableDefs put
			"pre_attack"
			{variable:"attacker" "Entity"; variable:"defender" "Entity";}
		variableDefs put
			"post_attack"
			{variable:"attacker" "Entity"; variable:"defender" "Entity";}
		variableDefs put
			"tick"
			{variable:"host" "Entity";}
		each eventName in sElements
			var variables as ListEntry
				variableDefs get
					eventName
			eventClasses add
				events generateEvent:null eventName variables eventClass imports; as ElementEntry
			var methodHeaderName
				events buildString
					"on"
					^eventName
			var parameterType
				events buildString
					"Events."
					^eventName
			entry header = variable:methodHeaderName "void";
			header setMode
				static variable WITH_TYPE
			methodHeaders+=header
			entry parameter = variable:"event" parameterType;
			parameter setMode
				static variable WITH_TYPE
			methodParameters+=
				{parameter}
	
	generate event takes eventName, variables as ListEntry, eventClass, imports as ListEntry
		return
			general createType:null imports ^eventName "Events" {eventClass} variables {} {} {} ;
	
	
	aux getEventContext takes eName, inputClass as vtype
		var eventContext
			namelessContext:inputClass;
		var eventClassName
			events buildString
				"Events."
				^eName
		eventContext addVariable
			variable:"event" eventClassName;
		return
			eventContext
	aux getEventMethod takes eName, inputClass as vtype, body as ListEntry
		var eventName
			traits buildString
				"on"
				^eName
		inputClass addMethod
			variable:eName "void";
		var tabs as Integer
			inputClass getTab
		entry ret "" = {(tabs-1 eventMethod {\^eName \^eName body})}
		ret+=(tabs-1 \"}")
		return
			ret
	
	aux getMethodBodies takes nameDefs as ListEntry, bodyDefs as ListEntry
		var numberOfNames
			nameDefs size
		entry bodies "" = {}
		each header as Entry in methodHeaders
			var h as variable = header
			var headerName
				h getName
			var setBody = false
			each i in 0..numberOfNames
				if 'nameDefs->i is headerName
					bodies+=bodyDefs->i
					set setBody = true
			if setBody is false
				bodies+={}
		return
			bodies
import "mods/affinities/affinity.generator"
import "mods/conditions/condition.generator"
import "mods/traits/trait.generator"
import "skills/attacks/attack.generator"
import "items/items.generator"
entities
	elements from "entity.elements"
	
	var packageName
	var directory
	var miscDirectory
	var superEntityClass as class
	var multiModifierClass as class
	aux setup takes data as ParseContext
		set packageName
			general getPackageName
		set directory
			new File
				general getDirectory
				"entities"
		set miscDirectory
			new File
				general getDirectory
				"entities/misc"
		directory mkdirs
		miscDirectory mkdirs
	aux generate takes data as ParseContext
		var itemDamageHiddenVariable
			variable:"itemDamage" "Float";
		set superEntityClass
			general init:class:"entities" "Entity" null {general->Source} {
				itemDamageHiddenVariable->HIDDEN
				variable:"weightHeld" "Float" "0f";} {} {} ;;
		superEntityClass addImport
			"events"
			"Events"
		superEntityClass addImport
			"java.util"
			"Arrays"
		superEntityClass addImport
			"misc"
			"Int"
		events addEventMethods
			superEntityClass
			{\"hit"}
			{{onHitBody{}}}
		entities addGainLoss:"condition" "conditions" "Condition" "Conditions.Id" superEntityClass;
		entities addGainLoss:"attack" "attacks" "Attack" "Attacks.Id" superEntityClass;
		entities addGainLoss:"trait" "traits" "Trait" "Traits.Id" superEntityClass;
		entities addGainLoss:"affinity" "affinities" "Affinity" "Affinities.Id" superEntityClass;
		entities addFile
			directory
			"Entity.java"
			superEntityClass->COMPLETE
		var modifierClass as class
			class:"entities" "Modifier" null null {} {
				method:"use" "Float" {variable:"inputEntity" "Entity";};
				method:"decrease" "void" {variable:"inputEntity" "Entity";variable:"newValue" "Float";} ;} {};
		superEntityClass addSubInterface
			modifierClass
		var multiListClass as class
			general init:class: "java.util" "ArrayList" {modifierClass};;
		set multiModifierClass
			class:"entities" "MultiModifier" multiListClass {modifierClass} {} {
				method:"MultiModifier" ""{variable:"...mods" "Entity.Modifier";} {multiConstructorBody{}};
				method:"use" "Float" {variable:"inputEntity" "Entity";} {multiUseBody{}};
				method:"decrease" "void" {variable:"inputEntity" "Entity";variable:"newValue" "Float";} {multiDecreaseBody{}};}{};
		superEntityClass addSubClass
			multiModifierClass
		general createList:general->Item;
		general createListMap:general->Source general->Int;
		superEntityClass addVariable:variable:"equippedItems" "List.Item";;
		superEntityClass addMethod:method:"getItemDamage" "Float" {} {itemDamageBody{}};;
		superEntityClass addMethod:method:"getItemDefense" "Float" {} {itemDefenseBody{}};;
		superEntityClass addMethod:method:"canEquip" "Boolean" {variable:"item" "Item";} {canEquipBody{}};;
		superEntityClass addMethod:method:"equip" "void" {variable:"item" "Item";} {equipBody{}};;
		superEntityClass addMethod:method:"unequip" "void" {variable:"item" "Item";} {unequipBody{}};;
		var statNames as Set<String>
			data getListElements
				"hero_stats"
		var superStatClass
			class:"entities" "Stat" null null {}{
				method:"getValue" "Integer" {};
				method:"setValue" "void" {variable:"newValue" "Integer";};
				method:"impose" "Boolean" {variable:"amount" "Integer"; variable:"source" "Source";};
				method:"release" "void" {variable:"source" "Source";};
				method:"getName" "String" {}; }{};
		superEntityClass addSubInterface
			superStatClass
		entry allStatList = {}
		each stat in statNames
			var vName
				stat toLowerCase
			var statModifierClass as class
				class:"entities" "Modifier" null {modifierClass} {variable:"percent" "Float";}{
					method:"use" "Float" {variable:"inputEntity" "Entity";} {statModifierUseBody{\vName}};
					method:"decrease" "void" {variable:"inputEntity" "Entity"; variable:"amount" "Float";} {statModifierDecreaseBody{\vName}};}{}; 
			var statClass as class
				class:"entities" stat null {superStatClass} {variable:"value" "Integer";variable:"history" "List.Map.Source._Int";}{
					method:"setValue" "void" {variable:"newValue" "Integer";} {general semicoloned{\"value = newValue"}};
					method:"impose" "Boolean" {variable:"amount" "Integer"; variable:"source" "Source";} {
						body_conditional:"synchronized" body_exact:\"this"; body_lines:{
							body_met_cal:body_exact:\"history"; \"add" {
								body_exact:\"source";
								body_new_obj:general->Int {body_exact:\"amount";};};
							body_operator:body_exact:\"value"; "+=" body_exact:\"amount";;
							body_return:body_operator:body_exact:\"value"; ">" body_exact:\"0";;; };; };
					method:"release" "void" {variable:"source" "Source";} {statReleaseBody{}};
					method:"getName" "String" {} {general returnCall{``stat``}};} {statModifierClass};
			superEntityClass addSubClass
				statClass
			superEntityClass addVariable
				variable:vName statClass;
			allStatList+=\vName
			statClass setDefaultEnder
				body_exact:\"getValue";
		var allStatSizeNum as Integer
			allStatList size
		superEntityClass addMethod
			method:"getRandomStat" "Entity.Stat" {} {randomStatBody{allStatList \'allStatSizeNum}};
	generate range
		if range->extra is not null
			entry parameters = {generate singleRange:;}
			range extra to element
				parameters+= 
					entities generateSingleRange:range;
			return
				body_new_obj:multiModifierClass parameters;
		else
			return
				generate singleRange:;
	generate singleRange
		if singleRange->hero_stats is not null
			var statClassName
				entities buildString
					"Entity."
					\'singleRange->hero_stats
					".Modifier"
			if singleRange->percent is not null
				var leftPercent
					entities buildString
						general percentify:'singleRange->left;
						"f"
				var rightPercent
					entities buildString
						general percentify:'singleRange->right;
						"f"
				return
					body_new_obj:general->statClassName {
						body_met_cal:body_new_obj:general->Range {
							body_exact:\leftPercent;
							body_exact:\rightPercent;}; \"getRandom" {};};
			else
				var leftPercent2
					entities buildString
						'singleRange->left
						"f"
				var rightPercent2
					entities buildString
						'singleRange->right
						"f"
				return
					body_new_obj:general->statClassName {
						body_met_cal:body_new_obj:general->Range {
							body_exact: \leftPercent2;
							body_exact: \rightPercent2;}; \"getRandom" {};};
		else
			var gen_range as body_statement
				generate general range :;
			return
				body_met_cal:gen_range \"getModifier" {};
	
	generate imposition takes forGainBody as Boolean, subject as body_statement
		var count = 0
		imposition PLUS to quanta
			set count = count + 1
		imposition MINUS to quanta
			set count = count - 1
		imposition amount to quanta
			var amount as Integer
				static Integer parseInt
					'quanta
			set count = count + amount
		var statGetMethod
			entities statGetMethod
				^imposition->hero_stats
		var getStatName
			body_met_cal: subject \statGetMethod {};
		if forGainBody is true 
			return
				body_met_cal:getStatName \"impose" {
					body_exact:\'count;
					body_exact:\"this";};
		else
			return
				body_met_cal:getStatName \"release" {
					body_exact:\"this";};
	aux addGainLoss takes obj, listName, type, idType, inputClass as class
		inputClass addMethod
			method:"has" "Boolean" {variable:"findId" idType;} {hasMethod{\type \obj \listName \obj}};
		inputClass addMethod
			method:"gain" "void" {variable:obj type; variable:"source" "Source";} {gainMethod{\listName \obj}};
		inputClass addMethod
			method:"lose" "void" {variable:"removeId" idType; variable:"source" "Source";} {loseMethod{\type \type \obj \listName \obj \obj \type \listName}};
		var mapClass as class
			general createListMap:general->Source general->type;	
		inputClass addVariable:variable:listName mapClass;;
	aux statGetMethod takes statName
		set statName
			statName toLowerCase
		return
			entities buildString
				"get"
				^statName
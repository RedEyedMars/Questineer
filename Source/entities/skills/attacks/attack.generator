attacks
	elements from "attack.elements"
	
	var packageName
	var directory
	var superAttackClass as class
	var superAttacksClass as class
	var idVariable as variable
	aux setup takes data as ParseContext
		set packageName
			general getPackageName
		set directory
			new File
				general getDirectory
				"entities/skills/attacks"
		directory mkdirs
	aux generate takes data as ParseContext
		var idClass as class
			class:"entities.skills.attacks" "Id" null null {}{}{};
		set idVariable
			variable:"id" idClass;
		var damageClass as class
			general init:class:"entities.skills.attacks" "Damage" null null {variable:"value" "Float" "0f";variable:"modifier" "Float" "1f";variable:"hit" "Boolean" "false";}{
			method:"setValue" "void" {variable:"newValue" "Float";} {general semicoloned{\"value = newValue"}};
			method:"setModifier" "void" {variable:"newModifier" "Float";} {general semicoloned{\"modifier = newModifier"}};
			method:"setHit" "void" {variable:"newHit" "Boolean";} {general semicoloned{\"hit = newHit"}};
			method:"getTotal" "Float" {} {general returnCall{\"value*modifier"}};}{};;
		
		set superAttacksClass
			general init:class:"entities.skills.attacks" "Attacks" null null {}{}{idClass};;
		superAttacksClass addImport
			"misc"
			"Range"
		set superAttackClass
			general init:class:"entities.skills.attacks" "Attack" general->Skill {general->Source} {}{
				method:"attack" "void" {variable:"attacker" "Entity"; variable:"defender" "Entity";} {attackAttackBody{}};
				method:"getDamage" "Attack.Damage" {variable:"attacker" "Entity";variable:"defender" "Entity";} {general returnCall{\"null"}};
				method:"getId" "Attacks.Id" {} {general returnCall{\"null"}};}{ damageClass };;
		superAttackClass addImport:"events" "Events";
		attacks addFile
			directory
			"Attacks.java"
			superAttacksClass->COMPLETE
		attacks addFile
			directory
			"Attack.java"
			superAttackClass->COMPLETE
	
	generate attackDeclaration
		var attackName
			^attackDeclaration->attackName
		var attackClass
			class:"entities.skills.attacks" attackName superAttackClass null {
				idVariable->PUBLIC->STATIC_FINAL}{}{};
		superAttacksClass addSubClass
			attackClass
		attackClass decrementTab
			1
		entry description "+" = {}
		attackClass addMethod
			method:"getName" "String" {}{general returnCall{``attackName``}};
		attackClass addMethod
			method:"getDescription" "String" {}{general returnCall{description}};
		var damageContext
			namelessContext: attackClass;
		damageContext addVariable
			variable:"attacker" "Entity";
		damageContext addVariable
			variable:"defender" "Entity";
		damageContext addVariable
			variable:"damage" "Attack.Damage";
		damageContext incrementTab
			3
		entry damageBody "" = {body_line:body_dec_var:variable:"damage" "Attack.Damage";;damageContext;}
		var damageIfName = "if" 
		attackDeclaration to quark
			description
				description+=``'quark``
			cooldown
				attackClass addToConstructor
					body_operator:body_exact:\"cost"; "=" generate entities range:;;
			range
				attackClass addToConstructor
					body_operator:body_exact:\"range"; "=" generate entities range:;;
			damage
				quark to energy
					by_stat
						var statRange as body_statement = generate entities range:;
						damageBody += body_met_cal:body_exact:\"damage"; \"setValue" {
							body_operator:body_met_cal:statRange \"use" {body_exact:\"attacker";}; "*" body_met_cal:body_exact:\"attacker"; \"getItemDamage" {};;};
					body_element
						damageBody += generate general bodyElement:damageContext;
			miss
				var setMiss
					body_line:body_met_cal:body_exact:\"damage"; \"setHit" {body_exact:\"false";};;
				quark option to energy
					var chance as body_statement
					var bool as body_statement
					energy to quanta
						has_chance
							set chance as body_statement = generate general chance:;
						boolean_statement
							set bool as body_statement = generate general boolean_statement:damageContext;
					if bool is not null
						damageBody +=
							body_conditional:damageIfName bool {
								body_conditional: "if" chance {setMiss} namelessContext:namelessContext:damageContext;;;} namelessContext:damageContext;;
					else
						damageBody +=
							body_conditional:damageIfName chance {setMiss} namelessContext:damageContext;;
					set damageIfName = "else if"
		damageBody+=
			body_return:body_exact:\"damage";;
		attackClass addMethod
			method:"getDamage" "Attack.Damage" {
				variable:"attacker" "Entity"; variable:"defender" "Entity";} damageBody;
		return
			null
	
	aux id takes attackName
		set attackName
			traits buildString
				"Attacks."
				attackName
		return
			body_static:general->attackName \"id";
conditions
	elements from "condition.elements"
	
	var directory
	var conditionMap
		new HashMap<String, Set<String>>
	var packageName
	var superConditionClass as class
	var superConditionsClass as class
	var idClass as class
	var createConditionBody = {}
	aux setup takes data as ParseContext
		set packageName
			general getPackageName
		set directory
			new File
				general getDirectory
				"entities/mods/conditions"
		directory mkdirs
		createConditionBody setDelimiter
			""
	aux generate takes data as ParseContext
		var createConditionMethod
			method:"createCondition" "Condition" {variable:"conditionName" "String";} {createConditionBody general returnCall{\"null"}};
		set idClass as class
			class:"entities.mods.conditions" "Id" null null {}{}{};
		set superConditionsClass
			general init:class:"entities.mods.conditions" "Conditions" null null {}{createConditionMethod->STATIC_COMPLETE}{idClass};;
		set superConditionClass
			general init:class:"entities.mods.conditions" "Condition" null {general->Source} {
				variable:"name" "String";variable:"description" "String";}{}{};;
		events addEventMethods
			superConditionClass
			{}
			{}
		superConditionClass addMethod
			method:"getId" idClass {} {general returnCall{\"null"}};
		conditions addFile
			directory
			"Condition.java"
			superConditionClass->COMPLETE
		
		conditions addFile
			directory
			"Conditions.java"
			superConditionsClass->COMPLETE
	
	generate condition
		var conditionName
			^condition->conditionName
		var conditionDescription
			'condition->description
		var idVariable
			variable:"id" "Conditions.Id";
		var conditionClass
			class:"entities.mods.conditions" conditionName superConditionClass	{general->Source} {
				idVariable->PUBLIC->STATIC_FINAL
				variable:"name" "String"; variable:"description" "String";}
				{}
				{};
		superConditionsClass addSubClass
			conditionClass
		entry requirementsBody "" = {}
		entry gainBody "" = {}
		entry lossBody "" = {}
		entry tickBody "" = {}
		var eventHost
			body_met_cal:body_exact:\"event"; \"getHost" {};
		var candidate
			body_exact:\"candidate";
		condition requirement to energy
			var requireHeader as body_statement
				generate general requirement:candidate false;
			requirementsBody+=
				body_conditional:"if" requireHeader {
								body_return:body_exact:\"false";;};
		
		condition imposition to energy
			gainBody+=generate entities imposition:true eventHost;
			lossBody+=generate entities imposition:false eventHost;
		var gainContext as context
			events getEventContext:"gain" conditionClass;
		var lossContext as context
			events getEventContext:"lose" conditionClass;
		var tickContext as context
			events getEventContext:"tick" conditionClass;			
		condition acquisition to energy
			gainBody+=generate general acquisition:true eventHost gainContext;
			lossBody+=generate general acquisition:false eventHost lossContext;
		condition accumulation to element
			element imposition to atom
				tickBody+=generate entities imposition:true eventHost;
			element acquisition to atom
				tickBody+=generate general acquisition:true eventHost tickContext;
		var loseThisStatement
			body_met_cal:eventHost \"lose" {body_exact:\"id"; body_exact:\"this";};
		var ifName = "if"
		condition to_lose to energy
			energy chance_pair to quanta
				var chanceHeader as body_statement
				quanta has_chance to woah
					set chanceHeader as body_statement = generate general chance:;
				if quanta->boolean_statement is null
					tickBody+=
						body_conditional:ifName chanceHeader {loseThisStatement} tickContext;
					set ifName = "if"
				else
					var booleanHeader as body_statement
					quanta boolean_statement to woah
						set booleanHeader as body_statement = generate general boolean_statement:tickContext;
					tickBody+=
						body_conditional:ifName booleanHeader {
							body_conditional:"if" chanceHeader {loseThisStatement} tickContext;} tickContext; 
					set ifName = "else if"
		requirementsBody+=
			body_return:body_exact:\"true";;
		condition event to element
			var eventContext as context
				events getEventContext
					'element->event_names
					conditionClass
			entry eventBody "" = {}
			if 'element->event_names is "gain"
				set eventBody = gainBody
			else
				if 'element->event_names is "loss"
					set eventBody = lossBody
				else
					if 'element->event_names is "tick"
						set eventBody = tickBody
			element body_element to atom
				eventBody+=generate general bodyElement:eventContext;
			if 'element->event_names is not "gain" and 'element->event_names is not "loss" and 'element->event_names is not "tick"
				var eventMethodName
					conditions buildString
						"on"
						^element->event_names
				var eventParameter
					conditions buildString
						"Events."
						^element->event_names
				conditionClass addMethod
					method:eventMethodName "void" {variable:"event" eventParameter;} eventBody;
		conditionClass addMethod
			method:"onGain" "void" {variable:"event" "Events.Gain";}gainBody;
		conditionClass addMethod	
			method:"onLoss" "void" {variable:"event" "Events.Loss";}lossBody;
		conditionClass addMethod	
			method:"onTick" "void" {variable:"event" "Events.Tick";}tickBody;
		conditionClass addMethod
			method:"hasRequirements" "Boolean" {variable:"candidate" "Entity";} requirementsBody; 
		createConditionBody += createListIf { ``'condition->conditionName`` \conditionName}
		return
			null
	
	aux id takes conditionName
		set conditionName
			conditions buildString
				"Conditions."
				conditionName
		return
			body_static:general->conditionName \"id";
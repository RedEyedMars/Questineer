
import renderer

import images




> int INT_SIZE = 4;
> String finalImageStatesClassName = "final Gui.Image.States";

enum  'packageName'.gui.images.ImageStates {
  void DEFAULT;
  void ASCEND;
}
class 'packageName'.gui.images.Images {
  class Flipped  {
  }
  Images (){
  }
}
class 'packageName'.gui.images.Colours {}
class 'packageName'.gui.images.Drawables {}
class 'packageName'.gui.images.ImageLoader {
> Map<%Class , %Parameters > animationCreationParameters = new HashMap< %Class , %Parameters >();
> Map<%Class , %Arguments > animationCreationArguments = new HashMap< %Class , %Arguments >();
  FloatBuffer placeHolder = null;
  void load(){
  }
> void declaration(%T input, %Class enclosingClass){
    String animationTypeName = %Helper.camelize('input->animationTypeName');
    if enclosingClass == Gui.Image.AnimationType {
      enclosingClass += @class 'animationTypeName' <  Gui.Renderable{
        void animate(){ }
        void render(){
          animationRender();
        }
        int getTexture(){
          return getImageTexture();
        }
      }
    }
    else {
      enclosingClass += @class 'animationTypeName' <  Gui.Renderable{
        void animate(){ }
        void render(){
          animationRender();
        }
        int getTexture(){
          return getImageTexture();
        }
      }
    }
    %Parameters parameters = new %Parameters ();
    %Arguments arguments = new %Arguments ();
    input : variable : animation_type_variable_declaration {
      variable : element : animation_variable_value {
        arguments.add(|'variable->variableName'|);
        element : value : INTEGER {
          enclosingClass.'animationTypeName' += int 'variable->variableName' = 'value';
          parameters.add(int 'variable->variableName' = 'value';);
        }
        element : value : FLOAT {
          enclosingClass.'animationTypeName' += Float 'variable->variableName' = 'value+"f"';
          parameters.add(int 'variable->variableName' = 'value';);
        }
        element : value : quote {
          enclosingClass.'animationTypeName' += String 'variable->variableName' = ''value'';
          parameters.add(int 'variable->variableName' = 'value';);
        }
      }
    }
    ($enclosingClass.'animationTypeName').addDefaultConstructor(parameters.asVariableList());
    animationCreationParameters.put($`enclosingClass`.'animationTypeName' , parameters);
    animationCreationArguments.put($`enclosingClass`.'animationTypeName' , arguments);
    %Class creationClass = $`enclosingClass`.'animationTypeName';
    String creationName = "";
    %Parameters previousParameters = %Parameters ();
    %Arguments previousArguments =  %Arguments ();
    String previousCreationName = null;
    while creationClass.getEnclosingClass() != Gui.Image.AnimationType {
      creationName = creationClass.getName().evaluate()+ creationName;
      String createMethodName = "create"+'creationName';
      %Class upperClass = creationClass.getEnclosingClass();
      %Parameters realParameters = %Parameters ();
      realParameters.add(animationCreationParameters.get(creationClass));
      realParameters.add(previousParameters);
      %Call creation = %Call();
      creation.add(|new `creationClass`(`animationCreationArguments.get(creationClass)`)|);
      if previousCreationName != null {
        String currentPreviousCreationName = previousCreationName;
        %Arguments currentPreviousArguements = %Arguments();
        currentPreviousArguements.add(previousArguments);
        creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
      }
      previousCreationName = createMethodName;
      upperClass += `enclosingClass`.'animationTypeName' 'createMethodName' `realParameters` {
          return `creation`;
        }
      previousParameters.add(animationCreationParameters.get(creationClass));
      previousArguments.add(animationCreationArguments.get(creationClass));
      creationClass = upperClass;
    }
    creationName = creationClass.getName().evaluate()+ creationName;
    String createMethodName = "create"+'creationName';
    %Parameters realParameters = %Parameters ();
    realParameters.add(animationCreationParameters.get(creationClass));
    realParameters.add(previousParameters);
    %Call creation = %Call ();
    creation.add(|new `creationClass`(`animationCreationArguments.get(creationClass)`)|);
    if previousCreationName != null {
      String currentPreviousCreationName = previousCreationName;
      %Arguments currentPreviousArguements = %Arguments();
      currentPreviousArguements.add(previousArguments);
      creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
    }
    Gui.Image.AnimationType += `enclosingClass`.'animationTypeName' 'createMethodName' `realParameters` {
      return `creation`;
    }
    %Parameters imageAnimationParameters = %Parameters ();
    imageAnimationParameters.add( int animationX = 0; );
    imageAnimationParameters.add( int animationY = 0; );
    %Arguments imageAnimationArguments = %Arguments();
    imageAnimationArguments.add( |\animationX| );
    imageAnimationArguments.add( |\animationY| );
    String currentPreviousCreationName = "create"+creationName;
    %Arguments currentPreviousArguements = %Arguments ();
    currentPreviousArguements.add(animationCreationArguments.get(creationClass));
    if previousCreationName != null {
      imageAnimationParameters.add(animationCreationParameters.get(creationClass));
      imageAnimationParameters.add(previousParameters);
      currentPreviousArguements.add(previousArguments);
      Gui.Image += `enclosingClass`.'animationTypeName' 'createMethodName' `imageAnimationParameters` {
        Gui.Image.AnimationType base = new Gui.Image.AnimationType(`imageAnimationArguments`);
        return base.'currentPreviousCreationName'(`currentPreviousArguements`);
      }
    }
    else {
      imageAnimationParameters.add(animationCreationParameters.get(creationClass));
      Gui.Image += `enclosingClass`.'animationTypeName' 'createMethodName' `imageAnimationParameters` {
        Gui.Image.AnimationType base = new Gui.Image.AnimationType(`imageAnimationArguments`);
        return base.'currentPreviousCreationName'(`currentPreviousArguements`);
      }
    }
    input : element : animation_type_element {
      element : atom : animation_type_declaration {
        ImageLoader.declaration(atom,$`enclosingClass`.'animationTypeName');
      }
      element : atom : statement {
        %Operator statement = %Operator ().operatorlessIfSingle();
        statement.add(|'atom->variableName'|);
        statement.operator('atom->animation_type_operator');
        atom : quark : animation_type_value {
          statement.add(|'quark'|);
        }
        : animation_type_arithmetic_operator {
          statement.operator('quark'.trim());
        }
        
        if atom->animation_type_condition != null {
          %Header header = new %Header ();
          atom->animation_type_condition : quark : animation_type_boolean {
            %Operator headerElement = %Operator().operatorlessIfSingle();
            headerElement = headerElement.add(|'quark->leftName'|);
            headerElement = headerElement.operator('quark->animation_type_boolean_operator');
            quark : energy : animation_type_value {
              energy : quanta : INTEGER {
                headerElement = headerElement.add(|'quanta'|);
              }
              : FLOAT {
                headerElement = headerElement.add(|'quanta+"f"'|);
              }
              : NAME {
                headerElement = headerElement.add(|'quanta'|);
              }
              : frameName {
                headerElement = headerElement.add(|\frames.'%Helper.asGetMethod(quanta)'()|);
              }
              
            }
            : animation_type_arithmetic_operator {
              headerElement = headerElement.operator('energy'.trim());
            }
            header.call(headerElement);
          }
          : animation_type_continuation_operator {
            if 'quark'.contains("&") {
              header.separator("&&");
            }
            else if 'quark'.contains("|") {
              header.separator("||");
            }
          }
          header.forgetFirst();
          enclosingClass.'animationTypeName'::animate() += {if `header` {`statement`;}}
        }
        else {
          enclosingClass.'animationTypeName'::animate() += {`statement`;}
        }
      }
    }
  }
> Set<String> declaredImageLoaders = new HashSet<String>();
> Set<String> declaredLoadingImages = new HashSet<String>();
> void declareImageLoader(String imageName, String imageFileName, int imageWidth, int imageHeight){
    StringBuilder imageLoaderName = new StringBuilder();
    int lastIndexOfDot = imageFileName.lastIndexOf(".");
    if lastIndexOfDot > -1 {
      imageLoaderName.append(imageFileName.substring(0,lastIndexOfDot).replace("/","_").replace("\\","_").replace(".","_"));
    }
    else {
      imageLoaderName.append(imageFileName.replace("/","_").replace("\\","_").replace(".","_"));
    }
    imageLoaderName.append("DataLoader");
    if declaredLoadingImages.add('imageLoaderName') == false {
      ImageLoader::load() += {
        'imageLoaderName'.attachTextures(Images.'imageName',Images.Flipped.'imageName');
      }
      return;
    }
    
    String imageLoaderClassName = "ImageData"+imageWidth+"x"+imageHeight+"Loader";
    ImageLoader::load() -= {
        'imageLoaderName'.start();
      }
    ImageLoader::load() -= {'imageLoaderClassName' 'imageLoaderName' = new 'imageLoaderClassName'('' 'imageFileName' '');}
    ImageLoader::load() += {
        'imageLoaderName'.attachTextures(Images.'imageName',Images.Flipped.'imageName');
      }
    if declaredImageLoaders.add(imageLoaderClassName) == false {
      return;
    }
    int totalSize = imageWidth * imageHeight;
    int totalByteSize = imageWidth * imageHeight * 4;
    ImageLoader += class 'imageLoaderClassName'  Thread  {
      String fileName = null;
      ByteBuffer pixelBuffer = null;
      ByteBuffer flippedPixelBuffer = null;
      Boolean failed = false;
      'imageLoaderClassName'(String initialFileName){
        super();
        this.fileName = initialFileName;
      }
      void run(){
        BufferedImage bufferedImage = null;
    	try { bufferedImage = ImageIO.read(new File(fileName));	}
    	print catch * { failed = true;  return;	}
        int[] pixels = new int['totalSize'];
        PixelGrabber pixelGrabber = new PixelGrabber(bufferedImage, 0, 0, 'imageWidth', 'imageHeight', pixels, 0, 'imageWidth');
        try { pixelGrabber.grabPixels(); }
        catch * { System.err.println(''"Pixel Grabbing interrupted!"''); failed = true; return; }
        
        byte[] bytes = new byte['totalByteSize'];
        byte[] flippedBytes = new byte['totalByteSize'];
        int p = 0;
        int r = 0;
        int g = 0;
        int b = 0;
        int a = 0;
        int i = 0;
        int j = 0;
        int k = 0;
        for int y < 'imageHeight' {
          for int x < 'imageWidth' {
            i = ('imageWidth' * y) + x;
            j = i * 4;
            k = 4*('imageWidth'*(y+1)-x-1) ;
            p = pixels[i]; 
            a = (p >> 24) & 0xFF; r = (p >> 16) & 0xFF;  g = (p >> 8) & 0xFF; b = (p >> 0) & 0xFF;
            bytes[j+0] = (byte)r;  bytes[j+1] = (byte)g;  bytes[j+2] = (byte)b; bytes[j+3] = (byte)a;
            flippedBytes[k+0] = (byte)r;  
            flippedBytes[k+1] = (byte)g; 
            flippedBytes[k+2] = (byte)b; 
            flippedBytes[k+3] = (byte)a;
          }
        }
        pixelBuffer = ByteBuffer.allocateDirect('totalByteSize').order(ByteOrder.nativeOrder());
        pixelBuffer.put(bytes).flip();
        flippedPixelBuffer = ByteBuffer.allocateDirect('totalByteSize').order(ByteOrder.nativeOrder());
        flippedPixelBuffer.put(flippedBytes).flip();
      }
      void attachTextures(Gui.Image imageObject, Gui.Image flippedImageObject){
        try {
          super.join();
        }
        print catch Interrupted {}
        if failed == true {
    	  imageObject.setTexture(0);
          return;
		}
    	
    	imageObject.setTexture(getTextureFromPixelBuffer(pixelBuffer));
    	if flippedImageObject != null {
    	  flippedImageObject.setTexture(getTextureFromPixelBuffer(flippedPixelBuffer));  
    	}
      }
      @int getTextureFromPixelBuffer(ByteBuffer pixels){
        
        int texture = 0;
        IntBuffer textureHandle = ByteBuffer.allocateDirect('INT_SIZE').order(ByteOrder.nativeOrder()).asIntBuffer();
        GL11.glGenTextures(textureHandle);
        texture = textureHandle.get(0);
        GL11.glPushAttrib(GL11.GL_TEXTURE_BIT);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
        GL11.glTexImage2D(GL11.GL_TEXTURE_2D,
          0, 						
          GL11.GL_RGBA8,			
          'imageWidth', 'imageHeight', 					
          0,						
          GL11.GL_RGBA, 			
          GL11.GL_UNSIGNED_BYTE,	
          pixels);
        GL11.glPopAttrib();
		GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
    	int result = GLU.gluBuild2DMipmaps(GL11.GL_TEXTURE_2D, GL11.GL_RGBA8,
    		'imageWidth', 'imageHeight',
    		GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, pixels);
    	if result != 0 {
    	  System.err.println(''"GLApp.makeTextureMipMap(): Error occured while building mip map, result="'' + result + ''" error="'' + GLU.gluErrorString(result) );
    	}
    	GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
    	GL11.glTexEnvf(GL11.GL_TEXTURE_ENV, GL11.GL_TEXTURE_ENV_MODE, GL11.GL_MODULATE);
    	return texture;
      }
    }
  }
}

> String floatBufferArray = "FloatBuffer[][]";
class 'packageName'.gui.Gui {
  FloatBuffer placeHolder = null;
  @Boolean isRunning = true;
  ImageLoader imageLoader = null;
  InputHandler inputHandler = null;
  @Game game = null;
  @Renderer renderer = null;
  Gui (){
  }
  void load(){
    initializeDisplay();
    renderer = new Renderer();
    renderer.load(\displayMode);
    inputHandler = new InputHandler();
    inputHandler.load(\displayMode);
    imageLoader = new ImageLoader();
    imageLoader.load();
    game = new Game();
    game.load();
  }
  interface Renderable  {
    int getTexture()?
    void render()?
    void animate()?
  }
  interface Statable  {
    Gui.Image.States asStates()?
    Gui.Drawable asStates(Gui.Drawable drawable)?
  }

  class Image <  Renderable {
    String imageFileName = null;
    Gui.Image.Dimensions pixels = null;
    Gui.Image.Dimensions frames = null;
    int texture = -1;
    FloatBuffer[][] textureBuffer = null;
    int getImageTexture(){
      return texture;
    }
    void animate(){}
    void render(){
      GL11.glTexCoordPointer(2, 0, textureBuffer[0][0]);
    }
    class Dimensions  {
      int width = -1;
      int height = -1;
    }
    Gui.Image.Crop getCrop(int frameX, int frameY){
      return new Gui.Image.Crop(frameX, frameY);
    }
    @class Crop < Renderable {
      int frameX = 0;
      int frameY = 0;
      Crop (int frameX, int frameY){
        this.frameX = frameX;
        this.frameY = frameY;
      }
      void animate(){}
      void render(){
        GL11.glTexCoordPointer(2, 0, textureBuffer[frameX][frameY]);
      }
      int getTexture(){
        return getImageTexture();
      }
    }
    class States <  Renderable Statable {
      Gui.Renderable current = null;
      ImageStates id = ImageStates.DEFAULT;
      ImageStates state = ImageStates.DEFAULT;
      void animate(){
        current.animate();
      }      
      void render(){
        current.render();
      }
      int getTexture(){
        return current.getTexture();
      }
      void changeState(ImageStates newState){
      }
      Gui.Image.States asStates(){
        return this;
      }
      Gui.Drawable asStates(Gui.Drawable drawable){
        return drawable.image(this);
      }
    }
    @class AnimationType  < Renderable {
      int x = 0;
      int y = 0;
      AnimationType(int x, int y){
        this.x = x;
        this.y = y;
      }
      void animate(){ }      
      void render(){
        GL11.glTexCoordPointer(2, 0, textureBuffer[x][y]);
      }
      void animationRender(){
        GL11.glTexCoordPointer(2, 0, textureBuffer[x][y]);
      }
      int getTexture(){
        return getImageTexture();
      }
      void tick(Double millisSinceLastFrame){
        animate();
        setFrameX(x);
        setFrameY(y);
      }
      void setFrameX(int newX){ this.x = newX; }
      void setFrameY(int newY){ this.y = newY; }
    }
>@  Map<String, Set<String>> multiElementImages = new HashMap<String, Set<String>>();
>   Map<String,Integer> imageWidths = new HashMap<String,Integer>();
>   Map<String,Integer> imageHeights = new HashMap<String,Integer>();
>   Map<String,Set<String>> declaredTextureBuffers = new HashMap<String,Set<String>>();
>   Map<String,Set<String>> animationStateFirstSet = new HashMap<String,Set<String>>();
>   Set<String> animationStatesByImage = new HashSet<String>();
>   Set<String> animationStates = new HashSet<String>();
>   Map<String, %Body > animationStateAscendBodies = new HashMap<String, %Body >();
>   Map<String, %Body > animationStateChangeSwitches = new HashMap<String, %Body >();
>   Map<String,Map<String, %Body >> animationStateChangeBodies = new HashMap<String,Map<String, %Body >>();
>   Map<String,Map<String, %Body >> animationStateChangeCases = new HashMap<String,Map<String, %Body >>();
>   Map<String, Map<String, Set<String>>> allStatesWithinState = new HashMap<String, Map<String, Set<String>>>();
>   Map<String, Map<String, Set<String>>> allIdsWithinState = new HashMap<String, Map<String, Set<String>>>();
>   Map<String,Map<String, %Call >> firstOrDefaultFlipMethods = new HashMap<String,Map<String, %Call >>();
>   Map<String,Map<String, %Call >> firstOrDefaultStateVariables = new HashMap<String,Map<String, %Call >>();
>   void declaration(%T input){
      try {
        String imageName = 'input->imageName';
        String imageClassName = %Helper.camelize('input->imageName');
        String imageFileName = "../Resource/gui/images/"+'input->imageFile'+'input->image_type';
        BufferedImage bimg = ImageIO.read(new File(imageFileName));
        int pWidth = bimg.getWidth();
        int pHeight = bimg.getHeight();
        imageWidths.put(imageClassName,Integer.parseInt('input->frameWidth'));
        imageHeights.put(imageClassName,Integer.parseInt('input->frameHeight'));
        Images += @Images.'imageClassName' 'imageName' = new Images.'imageClassName'();
        Images.Flipped += @Images.'imageClassName' 'imageName' = new Images.'imageClassName'();
        Images += class 'imageClassName'  Gui.Image :  Gui.Statable {
            'imageClassName' (){
              imageFileName = '' 'imageFileName' '';
              pixels = new Gui.Image.Dimensions('pWidth','pHeight');
              frames = new Gui.Image.Dimensions('input->frameWidth', 'input->frameHeight');
            }
          }
        if declaredTextureBuffers.containsKey('input->frameWidth')==false || declaredTextureBuffers.get('input->frameWidth').contains('input->frameHeight')==false {
          declareTextureBuffer('input->frameWidth','input->frameHeight');
        }
        String textureBufferMethodLoaderClassName = "TextureBuffer"+'input->frameWidth'+"x"+'input->frameHeight'+"Loader";
        ImageLoader.'textureBufferMethodLoaderClassName'::run() += {
            Images.'imageName'.setTextureBuffer(textureBuffer);
            Images.Flipped.'imageName'.setTextureBuffer(textureBuffer);
          }
        String imageLoaderClassName = "ImageData"+pWidth+"x"+pHeight+"Loader";
        ImageLoader.declareImageLoader(imageName,imageFileName,pWidth,pHeight);
        Images.'imageClassName' += class States  Gui.Image.States  {
          States (){
          }
          void changeState(ImageStates newState){
          }
        }
        Images.'imageClassName' += Images.'imageClassName'.States asStates() { return new Images.'imageClassName'.States(); }
        Images.'imageClassName' += Gui.Drawable asStates(Gui.Drawable drawable) { return drawable.image(new Images.'imageClassName'.States()); }
        Images.'imageClassName'.States += Images.'imageClassName'.States asStates() {
          Images.'imageClassName'.States result = new Images.'imageClassName'.States();
          result.setCurrent(\current);
          result.setState(\state);
          return result;
        }
        Images.'imageClassName'.States += Gui.Drawable asStates(Gui.Drawable drawable) {
          Images.'imageClassName'.States result = new Images.'imageClassName'.States();
          result.setCurrent(\current);
          result.setState(\state);
          return drawable.image(result);
        }
        
        Images.'imageClassName' += Gui.Drawable asDrawable(Gui.Drawable drawable) { return drawable.image(this); }
        Boolean isFirst = true;
        
        if input->animation_state == null {
          Images.'imageClassName'.States += Gui.Renderable defaultState = Images.'imageName';
          Images.'imageClassName'.States::*() += {setCurrent(\defaultState);}
        }
        animationStateFirstSet.put(imageClassName,new HashSet<String>());
        animationStateChangeBodies.put(imageClassName, new HashMap<String, %Body >());
        animationStateChangeCases.put(imageClassName, new HashMap<String, %Body >());
        allStatesWithinState.put(imageClassName, new HashMap<String, Set<String>>());
        allIdsWithinState.put(imageClassName, new HashMap<String, Set<String>>());
        firstOrDefaultFlipMethods.put(imageClassName, new HashMap<String, %Call >());
        firstOrDefaultStateVariables.put(imageClassName, new HashMap<String, %Call >());
        firstOrDefaultFlipMethods.get(imageClassName).put("", new %Call ());
        firstOrDefaultStateVariables.get(imageClassName).put("", new %Call ());
        %Body stateAscendBody = %Body ();
        animationStateAscendBodies.put(imageClassName,stateAscendBody);
        %Body stateSwitchBody = %Body ();
        animationStateChangeSwitches.put(imageClassName,stateSwitchBody);
        %Body defaultStateBody = %Body ();
        animationStateChangeBodies.get(imageClassName).put("",defaultStateBody);
        Images.'imageClassName'.States::changeState(ImageStates) += {
            if \newState == ImageStates.'"ASCEND"' {
              switch \state `stateAscendBody`
              return;
            }
            switch \state `stateSwitchBody`
          }
        animationStateChangeSwitches.get(imageClassName).add(|
              case \DEFAULT {
                switch \newState `defaultStateBody`
                return;
              }|);
        allStatesWithinState.get(imageClassName).put("",new HashSet<String>());
        allIdsWithinState.get(imageClassName).put("",new HashSet<String>());
        input : atom : animation_state {
          getAnimationStateDeclaration(atom,imageName,imageClassName,"");
        }
        addAllStateChangesToState(imageClassName,"", new HashSet<String>());
      }
      print catch  IO {}
    }
>   void addAllStateChangesToState(String imageClassName,String currentStateName, Set<String> allStateList){
      for String childStateName : allStatesWithinState.get(imageClassName).get(currentStateName) {
        allStateList.add(childStateName);
      }
      for String childStateName : allStatesWithinState.get(imageClassName).get(currentStateName) {
        Set<String> childStateList = new HashSet<String>();
        childStateList.addAll(allStateList);
        if allStatesWithinState.get(imageClassName).containsKey(childStateName) {
          addAllStateChangesToState(imageClassName,childStateName,childStateList);
        }
        else {
          %Body currentSwitchBody = %Body ();
          animationStateChangeBodies.get(imageClassName).put(childStateName,currentSwitchBody);
          animationStateChangeSwitches.get(imageClassName).add(|
              case 'childStateName' {
                switch \newState `currentSwitchBody`
                return;
              }
            |);
          for String allChildStateName : allStateList {
            if allChildStateName.equals(childStateName) == false {
              animationStateChangeBodies.get(imageClassName).get(childStateName).add(
                animationStateChangeCases.get(imageClassName).get(allChildStateName));
            }
          }
        }
      }
      for String childStateName : allStateList {
        animationStateChangeBodies.get(imageClassName).get(currentStateName).add(
          animationStateChangeCases.get(imageClassName).get(childStateName));
      }
    }
>   void getAnimationStateDeclaration(%T declaration, String imageName, String imageClassName, String parentStateName){
      declaration : atom
        : parentState {
          String currentStateName;
          if parentStateName.equals(""){
            currentStateName = 'atom->animationId';
          }
          else {
            currentStateName = parentStateName+"_"+'atom->animationId';
          }
          allStatesWithinState.get(imageClassName).get(parentStateName).add(currentStateName);
          allIdsWithinState.get(imageClassName).get(parentStateName).add('atom->animationId');
          allStatesWithinState.get(imageClassName).put(currentStateName,new HashSet<String>());
          allIdsWithinState.get(imageClassName).put(currentStateName,new HashSet<String>());
          %Body currentSwitchBody = %Body ();
          animationStateChangeBodies.get(imageClassName).put(currentStateName,currentSwitchBody);
          animationStateChangeSwitches.get(imageClassName).add(|
              case 'currentStateName' {
                switch \newState `currentSwitchBody`
                return;
              }
            |);
          %Call firstOrDefaultVariable = %Call ();
          firstOrDefaultStateVariables.get(imageClassName).put(currentStateName,firstOrDefaultVariable);
          %Call firstOrDefaultMethod = %Call ();
          firstOrDefaultFlipMethods.get(imageClassName).put(currentStateName,firstOrDefaultMethod);
          if parentStateName.equals("") {
            declareFlipMethod(animationStatesByImage.add(imageClassName), imageClassName, 'atom->animationId', currentStateName, currentStateName, firstOrDefaultStateVariables.get(imageClassName).get(currentStateName));
          }
          else {
            declareFlipMethod(animationStatesByImage.add(imageClassName), imageClassName, 'atom->animationId', currentStateName, parentStateName, firstOrDefaultStateVariables.get(imageClassName).get(currentStateName));
          }
          
          atom : quark : animation_state {
            getAnimationStateDeclaration(quark,imageName,imageClassName,currentStateName);
          }
          if animationStates.add(currentStateName) {
            ImageStates += void 'currentStateName';
            Gui.Image.States += 'finalImageStatesClassName' 'currentStateName'(){
              changeState(ImageStates.'currentStateName');
              return this;
            }
          }
          if animationStates.add('atom->animationId') {
            String animationIdName = 'atom->animationId'; 
            ImageStates += void 'animationIdName';
            Gui.Image.States += 'finalImageStatesClassName' 'atom->animationId'(){
              changeState(ImageStates.'animationIdName');
              return this;
            }
          }
        }
        : finalState {
          Boolean isFirst = animationStatesByImage.add(imageClassName);
          String creationMethod = "create"+'atom->animationTypeName';
          String currentStateName;
          if parentStateName.equals("") {
            currentStateName = 'atom->animationId';
          }
          else {
            currentStateName = parentStateName + "_"+'atom->animationId';
          }
          declareFinalAnimationState(atom, isFirst, imageClassName, imageName, parentStateName, currentStateName, 'atom->animationId', creationMethod, false);
          if atom->flipAnimationId != null {
            if parentStateName.equals("") {
              currentStateName = 'atom->flipAnimationId';
            }
            else {
              currentStateName = parentStateName + "_"+'atom->flipAnimationId';
            }
            declareFinalAnimationState(atom, false, imageClassName, imageName, parentStateName, currentStateName, 'atom->flipAnimationId', creationMethod, true);
          }
        }
    }
>   void declareFinalAnimationState(%T atom, boolean isFirstValue, String imageClassName, String imageName, String parentStateName, String currentStateName, String currentAnimationId, String creationMethod, boolean isFlipped){
      FlipMethodReturn flipMethodParameters = getFlipMethodParameters(atom,isFlipped,imageClassName);
      List< %Arguments > arguments = flipMethodParameters.getArguments();
      int yLayerSize = flipMethodParameters.getYLayerSize();
      boolean isFirst = isFirstValue;
      if arguments.size() == 1{
        if animationStates.add(currentAnimationId) {
          ImageStates += void 'currentAnimationId';
          Gui.Image.States += 'finalImageStatesClassName' 'currentAnimationId'(){
              changeState(ImageStates.'currentAnimationId');
              return this;
            }
        }
        if animationStates.add(currentStateName) {
          ImageStates += void 'currentStateName';
          Gui.Image.States += 'finalImageStatesClassName' 'currentStateName'(){
              changeState(ImageStates.'currentStateName');
              return this;
            }
        }
        allStatesWithinState.get(imageClassName).get(parentStateName).add(currentStateName);
        allIdsWithinState.get(imageClassName).get(parentStateName).add(currentAnimationId);
      }
      else if arguments.size() > 1{
        for int i < arguments.size() {
          String realCurrentId = 'currentAnimationId'+"_"+i;
          String realCurrentState = 'currentAnimationId'+"_"+i;
          if animationStates.add(realCurrentId) {
            ImageStates += void 'realCurrentId';
            Gui.Image.States += 'finalImageStatesClassName' 'realCurrentId'(){
                changeState(ImageStates.'realCurrentId');
                return this;
              }
          }
          if animationStates.add(realCurrentState) {
            ImageStates += void 'realCurrentState';
            Gui.Image.States += 'finalImageStatesClassName' 'realCurrentState'(){
                changeState(ImageStates.'realCurrentState');
                return this;
              }
          }
          allStatesWithinState.get(imageClassName).get(parentStateName).add(currentStateName+"_"+i);
          allIdsWithinState.get(imageClassName).get(parentStateName).add(currentAnimationId+"_"+i);
        }
        
      }
      if arguments.size() == 1{
        if isFlipped {
          Images.'imageClassName'.States += Gui.Renderable 'currentStateName+"State"' = Images.Flipped.'imageName'..'creationMethod'(`arguments.get(0)`);
        }
        else {
          Images.'imageClassName'.States += Gui.Renderable 'currentStateName+"State"' = Images.'imageName'..'creationMethod'(`arguments.get(0)`);
        }
        if animationStateFirstSet.get(imageClassName).add(parentStateName) {
          firstOrDefaultFlipMethods.get(imageClassName).get(parentStateName).add(|'"change_to_"+currentStateName'();|);
          firstOrDefaultStateVariables.get(imageClassName).get(parentStateName).add(|'currentStateName+"State"'|);
        }
        declareFlipMethod(isFirst, imageClassName, 'currentAnimationId', currentStateName, parentStateName, |'currentStateName+"State"'|);
      }
      else if arguments.size() > 1{
        int realIndex = 0;
        for %Arguments args: arguments {
          int indexValue = realIndex;
          if animationStateFirstSet.get(imageClassName).add(parentStateName) {
            firstOrDefaultFlipMethods.get(imageClassName).get(parentStateName).add(|'"change_to_"+currentStateName+"_"+realIndex'();|);
            firstOrDefaultStateVariables.get(imageClassName).get(parentStateName).add(|'currentStateName+"State_"+indexValue'|);
          }
          if isFlipped {
            Images.'imageClassName'.States += Gui.Renderable 'currentStateName+"State_"+indexValue' = Images.Flipped.'imageName'..'creationMethod'(`args`);
          }
          else {
            Images.'imageClassName'.States += Gui.Renderable 'currentStateName+"State_"+indexValue' = Images.'imageName'..'creationMethod'(`args`);
          }
          
          flipMethodParameters.getYLayers().get(realIndex / flipMethodParameters.getYLayerSize()).add(|'currentStateName+"State_"+indexValue'|); 
          declareFlipMethod(isFirst, imageClassName, 'currentAnimationId'+"_"+realIndex, currentStateName+"_"+realIndex, parentStateName, |'currentStateName+"State_"+indexValue'|);
          realIndex += 1;
          isFirst = false;
        }
        int xLayerSize = arguments.size()/yLayerSize;
        %Arguments stateRenderablesAsImageArray = %Arguments ();
        %Arguments currentLayer = %Arguments ();
        for int indexValue < arguments.size() {
          currentLayer.add(|\drawable.image(\states.'currentStateName+"State_"+indexValue')|);
          if indexValue%%xLayerSize == xLayerSize-1 {
            %Arguments currentLayerValue = currentLayer;
            stateRenderablesAsImageArray.add(|new Gui.Drawable(`currentLayerValue`)[]|);
            currentLayer = %Arguments ();
          }
        }
        Images.'imageClassName' += Gui.Drawable '"getAs"+ %Helper.camelize(currentStateName)'(Gui.Drawable drawable){
            Images.'imageClassName'.States states = new Images.'imageClassName'.States();
            return new Gui.Drawable.Multi.Image(new Gui.Drawable(`stateRenderablesAsImageArray`)[][]);
          }
        if multiElementImages.containsKey(imageClassName) == false {
          multiElementImages.put(imageClassName, new HashSet<String>());
        }
        multiElementImages.get(imageClassName).add(currentStateName);
      }
    }
>   FlipMethodReturn getFlipMethodParameters(%T atom, boolean isFlipped, String imageClassName){
      FlipMethodReturn result = new FlipMethodReturn();
      result.getArguments().add( %Arguments () );
      %Arguments multipleArguments = %Arguments ();
      %Arguments xArgumentLayer = %Arguments();
      atom : element : animation_variable_value {
        getFlipMethodParameter(element,isFlipped,imageClassName,result,multipleArguments,xArgumentLayer);
      }
      multipleArguments.add(|new Gui.Renderable(`xArgumentLayer`)[][]|);
      return result;
    }
>   void getFlipMethodParameter(%T element, Boolean isFlipped, String imageClassName, FlipMethodReturn result, %Arguments multipleArguments, %Arguments xArgumentLayer){
      element : value : range {
        List< %Arguments > oldArguments = result.getArguments();
        result.setArguments(new ArrayList<%Arguments >());
        int lowerBound = Integer.parseInt('value->lowerBound');
        int upperBound = Integer.parseInt('value->upperBound');
        for %Arguments args: oldArguments {
          if result.getIndex() == 1 {
            result.setYLayerSize(upperBound-lowerBound + 1);
          }
          for int i <= upperBound-lowerBound {
            %Arguments newArg = new %Arguments ();
            newArg.add(args);
            int index = i+lowerBound;
            newArg.add(|'index'|);
            result.getArguments().add(newArg);
            if result.getIndex() == 0 {
              %Arguments yArgumentLayer = new %Arguments ();
              result.getYLayers().add(yArgumentLayer);
              xArgumentLayer.add(|new Gui.Renderable(`yArgumentLayer`)[]|);
            }
          }
        }
        result.incrementIndex();
      }
      : unflippedValue {
        if isFlipped == false {
          getFlipMethodParameter(value,isFlipped,imageClassName,result,multipleArguments,xArgumentLayer);
          result.incrementIndex();
        }
      }
      : flippedValue {
        if isFlipped == true {
          getFlipMethodParameter(value,isFlipped,imageClassName,result,multipleArguments,xArgumentLayer);
          result.incrementIndex();
        }
      }
      : animation_type_coordinate_variable {
        if value->highX != null {
          if isFlipped {
            int lowX  = imageWidths.get(imageClassName)-1-Integer.parseInt('value->highX');
            int highX = imageWidths.get(imageClassName)-1-Integer.parseInt('value->lowX');
            for %Arguments args: result.getArguments() {
              args.add(|'lowX'|);
              args.add(|'value->highY'|);
              args.add(|'highX'|);
              args.add(|'value->lowY'|);
            }
          }
          else {
            for %Arguments args: result.getArguments() {
              args.add(|'value->lowX'|);
              args.add(|'value->lowY'|);
              args.add(|'value->highX'|);
              args.add(|'value->highY'|);
            }
          }
        }
        else {
        
          if isFlipped {
            int lowX  = imageWidths.get(imageClassName)-1-Integer.parseInt('value->lowX');
            for %Arguments args: result.getArguments() {
              args.add(|'lowX'|);
              args.add(|'value->lowY'|);
            }
          }
          else {
            for %Arguments args: result.getArguments() {
              args.add(|'value->lowX'|);
              args.add(|'value->lowY'|);
            }
          }
        }
        if result.getIndex() == 0 {
          %Arguments yArgumentLayer = new %Arguments ();
          result.getYLayers().add(yArgumentLayer);
          xArgumentLayer.add(|new Gui.Renderable(`yArgumentLayer`)[]|);
          result.setYLayerSize(1) ;
        }
        else if result.getIndex() == 1 {
          result.setYLayerSize(1) ;
        }
        result.incrementIndex();
        result.incrementIndex();
        if value->highX != null {
          result.incrementIndex();
          result.incrementIndex();
        }
      }
      : INTEGER {
        for %Arguments args: result.getArguments() {
          args.add(|'value'|);
        }
        if result.getIndex() == 0 {
          %Arguments yArgumentLayer = new %Arguments ();
          result.getYLayers().add(yArgumentLayer);
          xArgumentLayer.add(|new Gui.Renderable(`yArgumentLayer`)[]|);
        }
        else if result.getIndex() == 1 {
          result.setYLayerSize(1) ;
        }
        result.incrementIndex();
      }
      : FLOAT {
        for %Arguments args: result.getArguments() {
          args.add(|'value'|);
        }
        result.incrementIndex();
      }
      : quote {
        for %Arguments args: result.getArguments() {
          args.add(|'' 'value' ''|);
        }
        result.incrementIndex();
      }
    }
>   void declareFlipMethod(Boolean isFirst, String imageClassName, String singleStateName, String currentStateName, String parentStateName, %Output currentStateVariable){
      %Call firstOrDefaultMethod =   firstOrDefaultFlipMethods.get(imageClassName).get(currentStateName);
      if parentStateName.equals("") {
        Images.'imageClassName'.States += void '"change_to_"+currentStateName'(){
          setCurrent(`currentStateVariable`);
          \id = ImageStates.'singleStateName';
          \state = ImageStates.'currentStateName';
        }
        animationStateAscendBodies.get(imageClassName).add(|
          case 'currentStateName' {
            `firstOrDefaultMethod`;
            return;}|);
      }
      else {
        Images.'imageClassName'.States += void '"change_to_"+currentStateName'(){
            setCurrent(`currentStateVariable`);
            \id = ImageStates.'singleStateName';
            \state = ImageStates.'currentStateName';
          }
        animationStateAscendBodies.get(imageClassName).add(|
          case 'currentStateName' {
            '"change_to_"+parentStateName'();
            return;}|);
      }
      if isFirst {
        Images.'imageClassName'.States::*() += {'"change_to_"+currentStateName'();} 
      }
      if currentStateName.equals(singleStateName) {
        animationStateChangeCases.get(imageClassName).put(currentStateName, |
          case 'singleStateName' {
            '"change_to_"+currentStateName'();
            return;}|);
      }
      else {
        animationStateChangeCases.get(imageClassName).put(currentStateName, |
          case 'currentStateName' {
            '"change_to_"+currentStateName'();
            return;
          }
          case 'singleStateName' {
            '"change_to_"+currentStateName'();
            return;}|);
      }
    }
>   void declareTextureBuffer(String frameWidth, String frameHeight){
      Float width = Float.parseFloat(frameWidth);
      Float height = Float.parseFloat(frameHeight);
      int widthI = Integer.parseInt(frameWidth);
      int heightI = Integer.parseInt(frameHeight);
	  Float xFactor = 0.00f/width;
	  Float yFactor = 0.00f/height;
      String textureBufferMethodLoaderClassName = "TextureBuffer"+'frameWidth'+"x"+'frameHeight'+"Loader";
      String textureBufferMethodLoaderName = "loadTextureBuffer"+'frameWidth'+"x"+'frameHeight'+"Loader";
      String textureBufferName = "textureBuffer"+'frameWidth'+"x"+'frameHeight';
	  if declaredTextureBuffers.isEmpty() {
	    ImageLoader += Map<Integer,Map<Integer,'floatBufferArray'>> textureBuffers = new HashMap<Integer,Map<Integer,'floatBufferArray'>>();
      }
      ImageLoader::load() -= {
	      'textureBufferMethodLoaderName'.start();
        }
      ImageLoader::load() += {
          try {
	        'textureBufferMethodLoaderName'.join();
	      }
	      print catch Interrupted {} 
        }
      ImageLoader += Thread 'textureBufferMethodLoaderName' = new ImageLoader.'textureBufferMethodLoaderClassName'();
      ImageLoader += @class 'textureBufferMethodLoaderClassName'  Thread  {
        void run(){
	      FloatBuffer[][] textureBuffer = new FloatBuffer['frameWidth']['frameHeight'];
	      ByteBuffer byteBuffer = null;
        }
      }
      for int x < widthI {
	    for int y < heightI {
		  String currentTextureBuffer = "textureBuffer["+x+"]["+y+"]";
		  StringBuilder floatArrayValues = new StringBuilder();
		  floatArrayValues.append("new float[]{");
		  floatArrayValues.append(x/width+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y/height+1/height-yFactor);
		  floatArrayValues.append("f,");
	      floatArrayValues.append(x/width+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y/height+yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x/width+1/width-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y/height+1/height-yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x/width+1/width-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y/height+yFactor);
		  floatArrayValues.append("f}"); 
		  ImageLoader.'textureBufferMethodLoaderClassName'::run() += {
		      \byteBuffer = ByteBuffer.allocateDirect(2*4*4);
              \byteBuffer.order(ByteOrder.nativeOrder());
		      'currentTextureBuffer' = \byteBuffer.asFloatBuffer();
		      'currentTextureBuffer'.put('floatArrayValues');
              'currentTextureBuffer'.position(0);
            }
  	    }
      }
      if declaredTextureBuffers.containsKey(frameWidth)==false {
        declaredTextureBuffers.put(frameWidth, new HashSet<String>());
        #ImageLoader.'textureBufferMethodLoaderClassName'::run() += {
            synchronized "textureBuffers" {
              "textureBuffers".put('widthI', new HashMap<Integer,'floatBufferArray'>);
            }
          }#
      }
      declaredTextureBuffers.get(frameWidth).add(frameHeight);
	  #ImageLoader.'textureBufferMethodLoaderClassName'::run() += {
          synchronized "textureBuffers" {
	        \textureBuffers.get('widthI').put('heightI', \textureBuffer);
	      }
        }#
    }
  }
  class Colour  {
    Float getRedF(){ return null; }
    Float getGreenF(){ return null; }
    Float getBlueF(){ return null; }
    Integer getRedI(){ return null; }
    Integer getGreenI(){ return null; }
    Integer getBlueI(){ return null; }
    Float[] asFloatArray(){return null;}
    int[] asintArray(){return null;}
    int getTexture(){
      return 0;
    }
    void render(){}
    void endRender(){}
>   void declaration(%T input){
      String colourName = %Helper.camelize('input->colourName');
      Colours += class 'colourName'  Gui.Colour  {
      }
      input : element : asInt {
        int redInt = Integer.parseInt('element->red');
        int greenInt = Integer.parseInt('element->green');
        int blueInt = Integer.parseInt('element->blue');
        Float redFloat = Float.parseFloat('element->red')/256f;
        Float greenFloat = Float.parseFloat('element->green')/256f;
        Float blueFloat = Float.parseFloat('element->blue')/256f;
        
        Colours.'colourName' += Float[] asFloatArray(){return new Float('redFloat+"f"','greenFloat+"f"','blueFloat+"f"')[];}
        Colours.'colourName' += int[] asIntArray() {return new int('redInt','greenInt','blueInt')[]; }
        
        Colours.'colourName' += Integer getRedI(){return 'redInt';}
        Colours.'colourName' += Integer getGreenI() {return 'greenInt';}
        Colours.'colourName' += Integer getBlueI(){return 'blueInt';}
        Colours.'colourName' += Float getRedF() {return 'redFloat+"f"';}
        Colours.'colourName' += Float getGreenF() {return 'greenFloat+"f"';}
        Colours.'colourName' += Float getBlueF(){return 'blueFloat+"f"';}
        Colours.'colourName' += void render(){
          GL11.glDisable(GL11.GL_TEXTURE_2D);
		  GL11.glDisable(GL11.GL_LIGHTING);
		  GL11.glColor3f('redFloat+"f"', 'greenFloat+"f"', 'blueFloat+"f"');
		  GL11.glBegin(GL11.GL_TRIANGLE_STRIPS);
		}
		Colours.'colourName' += void endRender(){
		  GL11.glEnd();
		  GL11.glEnable(GL11.GL_TEXTURE_2D);
		  GL11.glEnable(GL11.GL_LIGHTING);
		}
      }
      : asFloat {
        Float redFloat = Float.parseFloat('element->red');
        Float greenFloat = Float.parseFloat('element->green');
        Float blueFloat = Float.parseFloat('element->blue');
        
        Float redIntValue = redFloat*256f;
        Float greenIntValue = greenFloat*256f;
        Float blueIntValue = blueFloat*256f;
        int redInt = redIntValue.intValue();
        int greenInt = greenIntValue.intValue();
        int blueInt = blueIntValue.intValue();
        
        Colours.'colourName' += Float[] asFloatArray(){return new Float('redFloat+"f"','greenFloat+"f"','blueFloat+"f"')[];}
        Colours.'colourName' += int[] asIntArray() {return new int('redInt','greenInt','blueInt')[]; }
        
        Colours.'colourName' += Integer getRedI(){return 'redInt';}
        Colours.'colourName' += Integer getGreenI() {return 'greenInt';}
        Colours.'colourName' += Integer getBlueI(){return 'blueInt';}
        Colours.'colourName' += Float getRedF() {return 'redFloat+"f"';}
        Colours.'colourName' += Float getGreenF() {return 'greenFloat+"f"';}
        Colours.'colourName' += Float getBlueF(){return 'blueFloat+"f"';}
      }
    }
  }
  class Drawable  {
    enum Predefined {
      class Drawables {}
    }
    FloatBuffer vertexBuffer = null;
    List<Gui.Drawable.ChangeListener> changeListeners = null;
    float visualX = 0f;
    float visualY = 0f;
    float visualWidth = 1f;
    float visualHeight = 1f;
    float visualRotationPointX = 0f;
    float visualRotationPointY = 0f;
    float visualAngle = 0f;
    float angle = 0f;
    
    Renderer.Layer displayLayer = null;
    void display(){
      if displayLayer == null {
        displayLayer = Renderer.botLayer;
        displayLayer.add(this);
      }
    }
    void undisplay(){
      if displayLayer == null {
        Renderer.botLayer.remove(this);
      }
      else {
        displayLayer.remove(this);
        displayLayer = null;
      }
    }
    void display(Renderer.Layer layer){
      if displayLayer == null {
        displayLayer = layer;
        displayLayer.add(this);
      }
      else if displayLayer != layer {
        displayLayer.remove(this);
        displayLayer = layer;
        displayLayer.add(this);
      }
    }
    void undisplay(Renderer.Layer layer){
      if displayLayer != null {
        displayLayer.remove(this);
      }
      if layer != null {
        layer.remove(this);
      }
      displayLayer = null;
    }
    void render(){
      
		GL11.glPushMatrix();
		GL11.glTranslatef(visualX, visualY, 0.0f);
		if visualAngle != 0f{
			GL11.glTranslatef(visualRotationPointX, visualRotationPointY, 0.0f);
			GL11.glRotatef(visualAngle, 0, 0, 1);	
			GL11.glTranslatef(-1f*visualRotationPointX, -1f*visualRotationPointY, 0.0f);
		}
		GL11.glScalef(visualWidth, visualHeight, 1f);
		GL11.glVertexPointer(3, 0, vertexBuffer);
    }
    void animate(){
    }
    void load(){
    }
    int getTexture(){
      return 0;
    }
    Gui.Drawable image(Gui.Renderable image){
      return null;
    }
    Gui.Drawable colour(Gui.Colour colour){
      return null;
    }
    void add(Gui.Drawable.ChangeListener changeListener){
      if changeListeners == null {
        changeListeners = new ArrayList<Gui.Drawable.ChangeListener>();
      }
      changeListeners.add(changeListener);
    }
    class ChangeListener  {
      void setVisualX(Float newX){
      }
      void setVisualY(Float newY){
      }
      void setVisualWidth(Float newWidth){
      }
      void setVisualHeight(Float newHeight){
      }
      void setAngle(Float newAngle){
      }
    }
    class Multi  {
      class Image Drawable {
        Gui.Drawable[][] images = null;
        void setVisualX(Float newVisualX){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualX(newVisualX+j*visualWidth);
            }
          }
        }
        void setVisualY(Float newVisualY){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualY(newVisualY+i*visualHeight);
            }
          }
        }
        void setVisualWidth(Float newVisualWidth){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualWidth(newVisualWidth);
            }
          }
        }
        void setVisualHeight(Float newVisualHeight){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualHeight(newVisualHeight);
            }
          }
        }
        void setVisualRotationPointX(Float newVisualRotationPointX){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualRotationPointX(newVisualRotationPointX);
            }
          }
        }
        void setVisualRotationPointY(Float newVisualRotationPointY){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualRotationPointY(newVisualRotationPointY);
            }
          }
        }
        void setVisualAngle(Float newVisualAngle){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setVisualAngle(newVisualAngle);
            }
          }
        }
        void setAngle(Float newAngle){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].setAngle(newAngle);
            }
          }
        }
        void display(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].display();
            }
          }
        }
        void undisplay(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].undisplay();
            }
          }
        }
        void display(Renderer.Layer layer){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].display(layer);
            }
          }
        }
        void undisplay(Renderer.Layer layer){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].undisplay(layer);
            }
          }
        }
        void render(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].render();
            }
          }
        }
        void animate(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].animate();
            }
          }
        }
        void load(){
          for int i < images.length {
            for int j < images[i].length {
              images[i][j].load();
            }
          }
        }
        int getTexture(){
          return images[0][0].getTexture();
        }
      }
    }
>   void setup(){
      Gui.Drawable::setVisualX(float) += {
          if changeListeners != null {
            for Gui.Drawable.ChangeListener changeListener : changeListeners {
              changeListener.setVisualX(\newVisualX);
            }
          }
        }
      Gui.Drawable::setVisualY(float) += {
        if changeListeners != null {
          for Gui.Drawable.ChangeListener changeListener : changeListeners {
            changeListener.setVisualY(\newVisualY);
          }
        }}
      Gui.Drawable::setVisualWidth(float) += {
          if changeListeners != null {
            for Gui.Drawable.ChangeListener changeListener : changeListeners {
              changeListener.setVisualWidth(\newVisualWidth);
            }
          }
        }
      Gui.Drawable::setVisualHeight(float) += {
          if changeListeners != null {
            for Gui.Drawable.ChangeListener changeListener : changeListeners {
              changeListener.setVisualHeight(\newVisualHeight);
            }
          }
        }
      Gui.Drawable::setAngle(float) += {
          if changeListeners != null {
            for Gui.Drawable.ChangeListener changeListener : changeListeners {
              changeListener.setAngle(\newAngle);
            }
          }
        }
      Gui.Drawable::setAngle(float) -= {
          \visualAngle = (float)(180.0*\newAngle / Math.PI); 
        }
    }
>   void declaration(%T input){
      String drawableName = 'input->drawableName';
      String drawableClassName = %Helper.camelize('input->drawableName');
      Drawables += class 'drawableClassName'  Gui.Drawable  {
        void load(){
        }
        Drawables.'drawableClassName' image(Gui.Renderable image){
          Drawables.'drawableClassName' newImage = new Drawables.'drawableClassName'.Image(image);
          newImage.setVertexBuffer(\vertexBuffer);
          return newImage;
        }
        Drawables.'drawableClassName' colour(Gui.Colour colour){
          Drawables.'drawableClassName' newColour = new Drawables.'drawableClassName'.Colour(colour);
          newColour.setVertexBuffer(\vertexBuffer);
          return newColour;
        }
      }
      Drawables += @Drawables.'drawableClassName' 'drawableName' = new Drawables.'drawableClassName'();  
      ImageLoader::load() -= { Drawables.'drawableName'.load(); }
            
      StringBuilder vertexArray = new StringBuilder();
      Float gridWidth = -1f;
      Float gridHeight = -1f;
      Boolean buildingWidth = true;
      input : element : drawable_grid_element {
        if element->endLine != null {
          gridHeight += 1f;
          buildingWidth = false;
        }
        else if buildingWidth {
          gridWidth += 1f;
        }
      }
      Float gridX = 0f;
      Float gridY = 0f;
      Float gridAHeight = gridHeight - 1;
      int numberOfElements = 0;
      Map<Integer,Float> gridXMap = new HashMap<Integer,Float>();
      Map<Integer,Float> gridYMap = new HashMap<Integer,Float>();
      input : element : drawable_grid_element {
        if element->point != null {
          element : atom : point {
            gridXMap.put(Integer.parseInt('atom'), gridX / gridWidth );
            gridYMap.put(Integer.parseInt('atom'), 1f - gridY / gridAHeight );
          }
          ++numberOfElements;
        }
        if element->endLine != null {
          ++gridY;
          gridX = 0f;
        }
        else {
          ++gridX;
        }
      }
      vertexArray.append("float[] vertices = new float[]{");
      String comma = "";
      for int i < numberOfElements {
        vertexArray.append(comma);
        vertexArray.append(gridXMap.get(i+1));
        vertexArray.append("f,");
        vertexArray.append(gridYMap.get(i+1));
        vertexArray.append("f,0f");
        comma = ",";
      }
      vertexArray.append("}");
      int sizeOfByteBuffer = numberOfElements * 4 * 3;
      Drawables.'drawableClassName'::load() += {
          'vertexArray';
		  ByteBuffer byteBuffer = ByteBuffer.allocateDirect('sizeOfByteBuffer');
		  byteBuffer.order(ByteOrder.nativeOrder());
		  \vertexBuffer = byteBuffer.asFloatBuffer();
		  \vertexBuffer.clear();
		  \vertexBuffer.put(\vertices);
		  \vertexBuffer.position(0);
        }
      int numberOfElementsValue = numberOfElements;
      Drawables.'drawableClassName' += class Image  'drawableClassName'  {
        Gui.Renderable image = null;
        void render(){
          image.render();
          super.render();
          GL11.glDrawArrays(GL11.GL_TRIANGLE_STRIP, 0, 'numberOfElementsValue');
		  GL11.glPopMatrix();
        }
        void animate(){
          image.animate();
        }
        int getTexture(){
          return image.getTexture();
        }
      }
      Drawables.'drawableClassName' += class Colour  'drawableClassName'  {
        Gui.Colour colour = null;
        void render(){
          colour.render();
        }
        int getTexture(){
          return colour.getTexture();
        }
      }
      Drawables.'drawableClassName'.Colour::render() += { colour.endRender(); }
    }
>   void multipleDeclaration(%T input){
      String multipleName = 'input->multipleName';
      String multipleClassName = %Helper.camelize('multipleName');
      Drawables += class multipleClassName  Gui.Drawable  {
        void load(){
        }
        void render(){
        }
        void animate(){
        }
        Drawables.'multipleClassName' image(Gui.Renderable image){
        }
      }
      Drawables += @Drawables.'multipleClassName' 'multipleName' = new Drawables.'multipleClassName'(); 
      Drawables.'multipleClassName' += class Image  'multipleClassName'  {
        int imageTexture = -1;
        void render(){
        }
        void animate(){
        }
        int getTexture(){
          return imageTexture;
        }
      }
      int imageIndex = 1;
      %Arguments imageParameters = new %Arguments ();
      imageParameters.add(|\image.getTexture()|);
      input : element : drawable_multiple_element {
        String imageName = "image"+imageIndex;
        String drawableName = 'element->drawableName';
        if element->newStateName != null {
          Drawables.'multipleClassName'::image() += { Gui.Image.States 'imageName' = ((Gui.Statable)image).asStates(); }
          element : atom : newStateName {
            Drawables.'multipleClassName'::image() += { 'imageName'.changeState( Gui.Image.States.'atom' ); }
          }
          imageParameters.add(|Drawables.'drawableName'.image('imageName')|);
        }
        else {
          imageParameters.add(|Drawables.'drawableName'.image(\image)|);
        }
        String changeListenerClassName = %Helper.camelize('imageName') + "ChangeListener";
        Drawables.'multipleClassName'.Image += @class changeListenerClassName : Gui.Drawable.ChangeListener  { 
          void setVisualX(Float newX){
          }
          void setVisualY(Float newY){
          }
          void setVisualWidth(Float newWidth){
          }
          void setVisualHeight(Float newHeight){
          }
          void setAngle(Float newAngle){
          }
        }
        addChangeListener(element->angle,Drawables.'multipleClassName'.Image, imageName, Gui.Drawable.NORMAL, "setAngle");
        addChangeListener(element->position,Drawables.'multipleClassName'.Image,imageName,"setVisualX","setVisualY");
        addChangeListener(element->dimensions,Drawables.'multipleClassName'.Image,imageName,"setVisualWidth","setVisualHeight");
        if element->rotation != null {
          addChangeListener(element->rotation,Drawables.'multipleClassName'.Image,imageName,"setVisualRotationPointX","setVisualRotationPointY");
        }
        
        Drawables.'multipleClassName'.Image += Gui.Drawable 'imageName' = null;
        Drawables.'multipleClassName'.Image::render() += {'imageName'.render();}
        Drawables.'multipleClassName'.Image::animate() += {'imageName'.animate();}
        
        Drawables.'multipleClassName'.Image::*() += {add(new Drawables.'multipleClassName'.Image.'changeListenerClassName'());}
        ++imageIndex;
      }
      Drawables.'multipleClassName'.Image::*() += {
          if changeListeners != null {
            for Gui.Drawable.ChangeListener changeListener : changeListeners {
		      \changeListener.setVisualX(0f);
		      \changeListener.setVisualY(0f);
		      \changeListener.setVisualWidth(1f);
		      \changeListener.setVisualHeight(1f);
		      \changeListener.setAngle(0f);
		    }
		  }
        }
      Drawables.'multipleClassName'::image() += {
          return new Drawables.'multipleClassName'.Image(`imageParameters`);
        }
    }
>   int LEFT_SUPPLEMENTARY = 1;
>   int RIGHT_SUPPLEMENTARY = 2;
>   int NORMAL = 3;
>   %Output getMultipleValue(%T input, int status){
      %Output result = null;
      if input->angle != null {
        if status == LEFT_SUPPLEMENTARY {
          return |Math.cos(getAngle())|;
        }
        else if status == RIGHT_SUPPLEMENTARY {
          return |Math.sin(getAngle())|;
        }
        else if status == NORMAL {
          return |getAngle()|;
        }
      }
      else if input->x != null {
        return |getVisualX()|;
      }
      else if input->y != null {
        return |getVisualY()|;
      }
      else if input->width != null {
        return |getVisualWidth()|;
      }
      else if input->height != null {
        return |getVisualHeight()|;
      }
      else if input->FLOAT != null {
        return |'input->FLOAT+"f"'|;
      }
      else if input->INTEGER != null {
        return |'input->INTEGER'|;
      }
      System.err.println("Drawable.getMultipleValue() could not parse:");
      input.print();
      return null;
    }
        
>   void addChangeListener(%T input, %Class masterClass, String drawableToChange, String leftParameterSetMethod, String rightParameterSetMethod){
      addChangeListener(input->leftParameter,masterClass,drawableToChange, LEFT_SUPPLEMENTARY, leftParameterSetMethod);
      addChangeListener(input->rightParameter,masterClass,drawableToChange, RIGHT_SUPPLEMENTARY, rightParameterSetMethod);
    }
>   void addChangeListener(%T input, %Class masterClass, String drawableToChange, int status, String setMethod){
      String changeListenerClassName = %Helper.camelize('drawableToChange') + "ChangeListener";
      %Operator statement = %Operator ().operatorlessIfSingle();
      Set<String> toChangeMethods = new HashSet<String>();
      input : element : drawable_multiple_value {
        statement.add(getMultipleValue(element,status));
        if element->width != null {
          toChangeMethods.add("setVisualWidth");
        }
        else if element->height != null {
          toChangeMethods.add("setVisualHeight");
        }
        else if element->x != null {
          toChangeMethods.add("setVisualX");
        }
        else if element->y != null {
          toChangeMethods.add("setVisualY");
        }
        else if element->angle != null {
          toChangeMethods.add("setAngle");
        }
      }
      : drawable_arthmetic_operator {
        statement.operator('element');
      }
      input : element : supplementary {
        element : atom : drawable_multiple_value {
          statement.add(getMultipleValue(atom,status));
          if atom->width != null {
            toChangeMethods.add("setVisualWidth");
          }
          else if atom->height != null {
            toChangeMethods.add("setVisualHeight");
          }
          else if atom->x != null {
            toChangeMethods.add("setVisualX");
          }
          else if atom->y != null {
            toChangeMethods.add("setVisualY");
          }
          else if atom->angle != null {
            toChangeMethods.add("setAngle");
          }
        }
        : drawable_arthmetic_operator {
          statement.operator('atom');
        }
      }
      for String changeMethod : toChangeMethods {
        masterClass.'changeListenerClassName'::'changeMethod'() += {
          'drawableToChange'.'setMethod'((float)`statement`);
        }
      }
    }
  }
> void setup(){
    Gui.Drawable.setup();
  }
> void importAny(%T import_any){
	import_any : import_colours : import_colour {
      import_colours : element : colour_declaration {
		Gui.Colour.declaration(element);
	  }
	}
	import_any : import_animation_types : import_animation_type {
	  import_animation_types : element : animation_type_declaration {
		ImageLoader.declaration(element,Gui.Image.AnimationType);
	  }
	}
	import_any : import_images : import_image {
	  import_images : element : image_declaration {
		Gui.Image.declaration(element);
	  }
	}
	import_any : import_draws : import_drawable {
	  import_draws : element : drawable_declaration {
		Gui.Drawable.declaration(element);
	  }
	  import_draws : element : multiple_drawable_declaration {
		Gui.Drawable.multipleDeclaration(element);
	  }
	}
	import_any : import_layers : import_layer {
	  import_layers : element : layer_declaration {
		Renderer.addLayer('element->layerName');
	  }
	}
  }
}

> class 'packageName'.misc.FlipMethodReturn {
  List< %Arguments > arguments = new ArrayList< %Arguments >();
  List< %Arguments > yLayers = new ArrayList< %Arguments >();
  int yLayerSize = 0;
  int index = 0;
  void incrementIndex(){
    index += 1;
  }
  void setArguments(List< %Arguments > newArguments){
    arguments = newArguments;
  }
  void setYLayers(List< %Arguments > newYLayers){
    yLayers = newYLayers;
  }
  void setYLayerSize(int newYLayerSize){
    yLayerSize = newYLayerSize;
  }
}
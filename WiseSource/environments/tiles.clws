class 'packageName'."environments" Tiles {
  @Tile create(String tileName){
    return null;
  }
> ~Integer costIndex = 0;
> String declaration(IToken declarationToken, String mapName, Set<String> underneathTiles, Set<String> backgroundTiles, Set<String> nodeTiles){
    if declarationToken->"underneath" != null{
      declarationToken : element : underneath {
        element : atom : tile_names {
          underneathTiles.add('atom');
        }
      }
      return null;
    }
    else if declarationToken->"background" != null{
      declarationToken : element : background {
        element : atom : tile_names {
          backgroundTiles.add('atom');
        }
      }
      return null;
    }
    else if declarationToken->"paths" != null {
      declarationToken : element : paths {
        element : atom : tile_names {
          nodeTiles.add('atom');
        }
      }
      return null;
    }
    String tileName = ^declarationToken->"tileName";
    Class extendsClass;
    if nodeTiles.contains(tileName) || declarationToken->"crawler" != null{
      extendsClass = Node;
    }
    else {
      extendsClass = Tile;
    }
    Tiles->'mapName' += class 'packageName'."environments" tileName extendsClass {
    }
    Tiles->*"create".prependToBody({
      if "tileName".equals(''tileName'') {
        return new Tiles->'mapName'->'tileName'(); 
      }
    });
    Tiles->'mapName'->'tileName' += class 'packageName'."environments" Factory \Object Tile->Factory {
      Tile create(){
        return new Tiles->'mapName'->'tileName'();
      }
    }
    Tiles->'mapName'->'tileName' += class Placer // Menu->Placable {
      void place(Environment map, Float placeX, Float placeY){
        map.addTile(new Tiles->'mapName'->'tileName'(placeX,placeY,map));
      }
    }
    \createList(Treasury->Cost);
	Tiles->'mapName'->'tileName' += class Generator / Tile->Generator / {
      \CostList getCosts(){
		\CostList costs = new \CostList();
	  }
	  Tile generateTile(Environment parent){
	  }
	}
	Tiles->'mapName'->'tileName' += class Circle / Tiles->'mapName'->'tileName' / {
	  Float radius = 1f;
	  Boolean isWithin(Environment.Position otherPosition) {
		return \super.isWithin(otherPosition,radius,Math.PI*2.0,0.0);
	  }
	  Environment->Position getPoint(Environment parent){
        Float direction = "(float)(Math.PI*2.0*\Math.random())";
        Float pX = "(float)(radius*Math.cos(direction))";
        Float pY = "(float)(radius*Math.sin(direction))";
	    return new Environment->Position(\getX() \+ dX,\getY() \+ dY,parent);
	  }
    }
	declarationToken : element : rate {
	  ~Float rarityValue = -1f;
	  if element->"rarity"->"COMMON" != null {
	    Tiles->'mapName'->'tileName'->Generator += Float getDefaultRate(){ return 100f; }
	    rarityValue = 100f;
	  }
	  else if element->"rarity"->"UNCOMMON" != null  {
	    Tiles->'mapName'->'tileName'->Generator += Float getDefaultRate(){ return 80f; }
	    rarityValue = 80f;
	  }
	  else if element->"rarity"->"RARE" != null  {
	    Tiles->'mapName'->'tileName'->Generator += Float getDefaultRate(){ return 60f; }
	    rarityValue = 60f;
	  }
	  else if element->"rarity"->"EPIC" != null  {
	    Tiles->'mapName'->'tileName'->Generator += Float getDefaultRate(){ return 40f; }
	    rarityValue = 40f;
	  }
	  else if element->"rarity"->"LEGENDARY" != null  {
	    Tiles->'mapName'->'tileName'->Generator += Float getDefaultRate(){ return 20f; }
	    rarityValue = 20f;
	  }
	  element : atom : tile_cost {
	    Tiles->'mapName'->'tileName'->Generator->*"getCosts".appendToBody({"costs".add(`\getTileCost(atom,mapName,tileName)`);});
	  }
    }
	Tiles->'mapName'->'tileName'->Generator->*"getCosts".appendToBody({return "costs";});
    if declarationToken->"crawler" == null {
      Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
        Environment->Position point = parent.getTile(Tiles->'underneathTiles.get(0)'.id).getPoint(parent);
		return new Tiles->'mapName'->'tileName'(point.getX(),point.getY(), parent);
		});
    }
    else {
      declarationToken : element : crawler {
        String directionValue = "direction)";
        String openNodeValue = "(float)(openNode";
        Tiles->'mapName'->'tileName'->Generator += ~List<Tiles\>'mapName'\>'tileName'> openNodes = new ArrayList<Tiles\>'mapName'\>'tileName'>()
        Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
          if openNodes.isEmpty() {
            return null;
          }
          Tiles->'mapName'->'tileName' openNode = Range.select(openNodes);
          Double direction = \Math.PI * 2.0 * \Math.random();
          Double length = `\primeRange(element->"length")`.getRandom();
          Tiles->'mapName'->'tileName' newNode = new Tiles->'mapName'->'tileName'(
            'openNodeValue'.getX() \+ length \* \Math.cos('directionValue'),
            'openNodeValue'.getY() \+ length \* \Math.sin('directionValue'),
            parent);
          newNode.connect(openNode);
          openNodes.add(newNode);
          if openNode.getNodes().size() >= openNode.getBranchLimit() {
            openNodes.remove(openNode);
          }
          Float chance = Range.getRandomFloat();
		});
		~Float currentChance = 0f;
		~Boolean isFirst = true;
		element : atom : branch {
		  atom : quark : branch_element {
		    currentChance \+= Float.parseFloat('quark->"chance"') / 100f;
		    Float chanceValue = currentChance;
		    if isFirst {
		      Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({		        
		        if "chance" < 'chanceValue' {
		          "newNode".setBranchLimit('quark->"amount"');
		        }
		      });
		      isFirst = false;
		    }
		    else {
		      Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({		        
		        else if "chance" < 'chanceValue' {
		          "newNode".setBranchLimit('quark->"amount"');
		        }
		      });
		    }
		  }
		}
        Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
          chance = Range.getRandomFloat();
        });
		isFirst = true;
		currentChance = 0f;
		element : atom : generate_shape {
		  if isFirst {
		    if atom->"OTHERWISE" != null {
		      atom : quark : shape {
        	    Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody(
        	      \getGenerateShape(quark,mapName,tileName));
        	  }
		    }
		    else {
		      currentChance \+= Float.parseFloat('atom->"chance"') / 100f;
		      Float chanceValue = currentChance;
		      Body shapeBody = new Body ();
		      atom : quark : shape {
		        shapeBody.add(\getGenerateShape(quark,mapName,tileName));
		      }
		      Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
		        if "chance" < 'chanceValue' `shapeBody`
		      });
		      isFirst = false;
		    }
		  }
		  else {
		    if atom->"OTHERWISE" != null {
		      Body shapeBody = new Body ();
		      atom : quark : shape {
		        shapeBody.add(\getGenerateShape(quark,mapName,tileName));
		      }
        	  Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
		        else `shapeBody`
		      });
		    }
		    else {
		      currentChance \+= Float.parseFloat('atom->"chance"') / 100f;
		      Float chanceValue = currentChance;
		      Body shapeBody = new Body ();
		      atom : quark : shape {
		        shapeBody.add(\getGenerateShape(quark,mapName,tileName));
		      }
		      Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
		        else if "chance" < 'chanceValue' `shapeBody`
		      });
		    }
		  }
		}
        Tiles->'mapName'->'tileName'->Generator->*"generateTile".appendToBody({
            return "newNode";
          });
      }
    }
    declarationToken : element : entity {            
      Class entityFactory = Entities.declaration(element->"entity_declaration");
      element : quanta : PLUS {
        Tiles->'mapName'->'tileName'->*.prependToBody(|"onTickEntityFactories".add(new entityFactory());|);
      }
      element : quanta : MINUS {
        Tiles->'mapName'->'tileName'->*.prependToBody(|"onLoadEntityFactories".add(new entityFactory());|);
      }
    }
    return tileName;
  }
> Statement getGenerateShape(IToken shapeToken, String mapName, String tileName){
    String shapeTileName = 'shapeToken->"tile_names"';
    String shapeShapeName = 'shapeToken->"shape_type"';
    Parameters parameters = new Parameters ();
    shapeToken : element : LENGTH {
      parameters.add(|"length"|);
    }
    : INTEGER {
      parameters.add(|'element'|);
    }
    : FLOAT {
      parameters.add(|'element'+"f"|);
    }
    return |"parent".addTile(new Tiles->'mapName'->'shapeTileName'->'shapeShapeName'(`parameters`)) ;|;
  }
  
> Statement getTileCost(IToken tileCostToken, String mapName, String tileName){
    String costName = "Cost" \+ costIndex;
    costIndex \+= 1;
    if tileCostToken->"FREE" != null {
      Tiles->'mapName'->'tileName'->Generator += class costName / Treasury->Cost / {
        Treasury->Reward getReward() {
          return new Tiles->'mapName'->'tileName'->Generator->'costName'->Reward(); 
        }
        Boolean isFree(){
          return true;
        }
      }
      Tiles->'mapName'->'tileName'->Generator->'costName' += class Reward / Treasury->Reward / {
        Boolean isPlacable(){
          return true;
        }
        Menu->Placable getPlacable(){
          return new Tiles->'mapName'->'tileName'->\Placer();
        }
      }
      return |new Tiles->'mapName'->'tileName'->Generator->'costName'()|;
    }
    else {
      String paymentType = Treasury.getTypeName(tileCostToken->"paymentType");
      if tileCostToken->"payment" != null {
        Tiles->'mapName'->'tileName'->Generator += class costName / Treasury->Cost / {
          Integer getAmount(){
            return 'tileCostToken->"payment"';
          }
          Treasury->PaymentType->Id getType(){
            return Treasury->PaymentTypes->'paymentType'.id;
          }
          Treasury->Reward getReward() {
            return new Tiles->'mapName'->'tileName'->Generator->'costName'->Reward(); 
          }
        }
      }
      else {
        Tiles->'mapName'->'tileName'->Generator += class costName / Treasury->Cost / {
          Treasury->PaymentType->Id getType(){
            return Treasury->PaymentTypes->'paymentType'.id;
          }
          Treasury->Reward getReward() {
            return new Tiles->'mapName'->'tileName'->Generator->'costName'->Reward(); 
          }
        }
      }
      if tileCostToken->"operator" == null {
        Tiles->'mapName'->'tileName'->Generator->'costName' += class Reward / Treasury->Reward / {
          Boolean isPlacable(){
            return true;
          }
          Menu->Placable getPlacable(){
            return new Tiles->'mapName'->'tileName'->\Placer();
          }
        }
      }
      else {
        Tiles->'mapName'->'tileName'->Generator->'costName' += class Reward / Treasury->Reward / {
          Boolean isPlacable(){
            return true;
          }
          Menu->Placable getPlacable(){
            return new Tiles->'mapName'->'tileName'->Generator->'costName'->Reward->RewardGenerator();
          }
        }
        String rarityValue = 'tileCostToken->"amount"';
        Double radius = Double.parseDouble('tileCostToken->"radius"');
        Double tau = 2 \* \Math.PI;
        Tiles->'mapName'->'tileName'->Generator->'costName'->Reward += class RewardGenerator / Tiles->'mapName'->'tileName'->Generator /{
          Float getDefaultRate(){
            return 'rarityValue+"f"';
          }
		  Tile generateTile(Environment parent){
		    return new Tiles->'mapName'->'tileName'("(float)(x" \+ 'radius' * \Math.'"cos(" + tau' * \Math."random()))" ,
		                      "(float)(y" \+ 'radius' * \Math.'"sin("+tau' * \Math."random()))" , parent);
		  }
        }
      }
      return |new Tiles->'mapName'->'tileName'->Generator->'costName'()|;
    }
  }
}
class 'packageName'."environments" Tile Environment->Position Loaddable Tickable  {
  class Id // {
  }
  
  class Generator // Menu->Placable {
    ~Float x = 0f;
    ~Float y = 0f;
    void place(Environment map, Float placeX, Float placeY){
      map.addGenerator(this);
      x = placeX;
      y = placeY;
    }
    Float getWidth(){
      return 0f;
    }
    Float getHeight(){
      return 0f;
    }
    Float getDefaultRate(){
      return 0f;
    }
    \CostList getCosts(){
	  return null;
    }
	Tile generateTile(Environment parent){
	  return null;
	}
	void generate(Environment parent){
	  if parent.getGenerationRate() * \Math.random() <= \getDefaultRate() {
	    Tile newTile = \generateTile(parent);
	    if newTile != null {
	      parent.addTile(newTile);
	    }
	  }
	}
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Tile> {
        Environment->Position origin = null;
        \int compare(Tile tile1, Tile tile2){
          return "(int)(float)(origin.getDistanceTo(tile1) - origin.getDistanceTo(tile2))";
        }
      }
      class Descending // Comparator<Tile> {
        Environment->Position origin = null;
        \int compare(Tile tile1, Tile tile2){
          return "(int)(float)(origin.getDistanceTo(tile2) - origin.getDistanceTo(tile1))";
        }
      }
    }
  }
  ~Float "width" = 1f;
  ~Float "height" = 1f;
  ~Integer "numberOfAliveGeneratedEntities" = 0;
  ~Integer "limit" = 5;
  ~Boolean isNode = false;
  ~Area area = null;
  
  Tile->Id getId(){
    return null;
  }
  Boolean isNode(){
    return false;
  }
  Boolean isWithin(Environment->Position otherPosition){
    return \super.isWithin(otherPosition, width, height);
  }
  interface 'packageName'."environments" Factory {
    Tile create(){}
  }
  class 'packageName'."environments" Listener {
    class 'packageName'."environments" Die Events->Die->Listener {
      Tile "host";
      void listen(Events->Die "event"){
        "host".decreaseAliveGeneratedEntities();
      }
    }
  }
  Node getClosestNode(){
    if "parent"!=null {
      return "parent".getClosestNode(this);
    }
    else {
      return null;
    }
  }
  void load(){
    
  }
  void tick(Double millisSinceLastFrame){
    if \Math.random() > 0.05 && "numberOfAliveGeneratedEntities" < "limit" {
      Double randomIndex = \Math.random() * "onTickEntityFactories".size();
      Entity newEntity = "onTickEntityFactories".get("(int)(double)randomIndex").create();
      newEntity.setSpawn(this);
      newEntity.getLocation().moveTo(this);
      newEntity.add(new Tile->Listener->Die(this));
      "numberOfAliveGeneratedEntities" \+= 1;
    }
  }
  void decreaseAliveGeneratedEntities(){
    "numberOfAliveGeneratedEntities" \-= 1;
  }
  Association get(Association->Id id, Association->Factory factory){
    return "associations".get(id,factory);
  }
  Environment->Position getPoint(Environment parent){
    return new Environment->Position(width*Range.getRandomFloat(), height*Range.getRandomFloat(), parent);
  }
> void setup(ParseContext data){
    Class entityFactory = Entity->Factory;
    Tile += ~List<entityFactory> "onTickEntityFactories" = new ArrayList<entityFactory>()
    Tile += ~List<entityFactory> "onLoadEntityFactories" = new ArrayList<entityFactory>()
    \createMap(Association->Id,Association);
    Tile += ~\IdMap->\_Association "associations"
  }
}
class 'packageName'."environments" Node Tile{
  
  ~List<Node> nodes = new ArrayList<Node>();
  ~Node home = null;
  ~Integer branchLimit = 0;
  ~Boolean isStop = false;
  Boolean isNode(){
    return true;
  }
  void connect(Node otherNode){
    home = otherNode;
    otherNode.nodes.add(this);
    nodes.add(otherNode);
  }
  Node getUnexploredNode(){
    if nodes.isEmpty() || nodes.size() == 1 {
      return this;
    }
    else {
      Set<Node> visited = new HashSet<Node>();
      visited.add(this);
      for Node node: nodes {
         Node unexploredNode = node.getUnexploredNode(visited);
         if unexploredNode != null {
           return unexploredNode;
         }
      }
      return null;
    }
  }
  Node getUnexploredNode(Set<Node> visited){
    if visited.add(this) {
      if nodes.isEmpty() || nodes.size() == 1 {
        return this;
      }
      else {
        for Node node: nodes {
          Node unexploredNode = node.getUnexploredNode(visited);
          if unexploredNode != null {
            return unexploredNode;
          }
        }
        return null;
      }
    }
    else {
      return null;
    }
  }
  
  Node step(Entity stepper, Node next){
    Float speed = stepper.getWalkingSpeed();
    Double direction = stepper.getLocation().getDirectionTo(next);
    stepper.getLocation().move(\Math.cos(direction) * speed, \Math.sin(direction) * speed);
    if next.isWithin(stepper.getLocation()) {
      if next.isStopper() {
        stepper.rememberIncomingNode(this,next);
      }
      return next;
    }
    else {
      return this;
    }
  }
  void add(Node node){
    nodes.add(node);
    isStop = nodes.size() > 2;
  }
  Boolean isStopper(){
    return isStop;
  }
  Set<Way> getWaysTo(Node goalNode, Map<Node,Set<Node>> stoppers){
    if this == goalNode {
      Way resultWay = new Way();
      resultWay.setGoal(goalNode);
      resultWay.add(this);
      \TreeSet<Way> result = new \TreeSet<Way>();
      result.add(resultWay);
      return result;
    }
    \TreeSet<Way> ways = new \TreeSet<Way>();
    Way firstWay = new Way();
    firstWay.setGoal(goalNode);
    firstWay.add(this);
    ways.add(firstWay);
    ~Integer count = 0;
    \TreeSet<Way> result = new \TreeSet<Way>();
    Set<Node> visited = new HashSet<Node>();
    for Node node: nodes {
      Way resultWay = new Way();
      resultWay.setGoal(goalNode);
      resultWay.add(this);
      node.getWaysTo(goalNode, 50, resultWay, result, visited, stoppers);
    }
    return result;
  }
  void getWaysTo(Node goalNode, Integer depth, Way currentWay, \TreeSet<Way> result, Set<Node> visited, Map<Node,Set<Node>> stoppers){
    if depth>0 && visited.add(this) {
      Way resultWay = new Way(currentWay);
      resultWay.add(this);
      if this == goalNode {
        result.add(resultWay);
      }
      else {
        for Node node: nodes {
          if stoppers.containsKey(this) && stoppers.get(this).contains(node) == false {
            node.getWaysTo(goalNode,depth \- 1, resultWay, result, visited, stoppers);
          }
        }
      }
    }
  }
}
class 'packageName'."environments" Way ArrayList<Node> \Comparable<Way>{
	~class Stepper // {
	  Integer i = 0;
	  Boolean step(Entity stepper){
	    if i >= \size() \- 1 {
	      return false;
	    }
	    else {
	      Node newNode = \get(i).step(stepper,\get(1));
	      if newNode != \get(i) {
	        i \+= 1;
	      }
	      return true;
	    }
	  }
	}
    HashSet<Node> "checkSet";
    Node "goal";
    Double "distanceToGoal" = 0.0;
    Way *(Way "parentWay"){
      "goal" = "parentWay".getGoal();
      for Node "node":"parentWay" {
        \add("node");
      }
      "distanceToGoal" = "goal".getDistanceTo(\get(\size() - 1)); 
    }
    void setGoal(Node "newGoal"){
      "goal" = "newGoal";
    }
    Boolean at(Node "destination"){
      if \isEmpty() {
        return false;
      }
      else {
        if \get(\size() - 1).isStopper() {
          return true;
       }
       return \get(\size() - 1) == "destination";
     }
   }
   \boolean add(Node "newNode"){
      if "checkSet".add("newNode") {
        "distanceToGoal" = "goal".getDistanceTo("newNode"); 
        return \super.add("newNode");
      }
      else {
        return false;
      }
    }
    \int compareTo(Way "otherWay") {
      Double "distance" = "otherWay".getDistanceToGoal() - "distanceToGoal";
      if "(int)(double)distance" == 0 {
        if "otherWay".size() == \size() && "checkSet".containsAll("otherWay".getCheckSet()) {
          return 0;
        }
        else {
          return "otherWay".size() - \size();
        }
      }
      else {
        return "(int)(double)distance";
      }
    }
}
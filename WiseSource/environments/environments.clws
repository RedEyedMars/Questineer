import tiles.clws

class 'packageName'."environments" Environment \Object Loaddable Tickable {
  interface Movable // {
    Entity->Event moveX(Integer x){
    }
    Entity->Event moveY(Integer y){
    }
  }
  String name = null;
  ~Area startArea = null;
  ~Area\>Generator areaGenerator = null;
  ~List<Tile\>Factory> floorTiles = new ArrayList<Tile\>Factory>(); 
  ~List<Area> areas = new ArrayList<Area>();
  ~List<Area> activeAreas = new ArrayList<Area>();
  ~Map<Tile\>Id, List<Tile>> tiles = new HashMap<Tile\>Id, List<Tile>>();
  ~Map<Area\>Id, List<Area>> areaMap = new HashMap<Area\>Id, List<Area>>();
  void add(Area newArea){
    areas.add(newArea);
    if areaMap.containsKey(newArea.getId()) == false {
      areaMap.put(newArea.getId(), new ArrayList<Area>());
    }
    areaMap.get(newArea.getId()).add(newArea);
  }
  Area getArea(Integer index){
    return areas.get(index);
  }
  List<Area> get(Area->Id id){
    return areaMap.get(id);
  }
  \Tile->List getTilesWithin(Environment->Position position, Float range, Tile->Id tileId){
    Tile->List result = new Tile->List();
    for Tile tile: tiles.get(tileId) {
      if position.getDistanceTo(tile) < range {
        result.add(tile);
      }
    }
    return result;
  }
  void add(Entity newEntity){
    startArea.add(newEntity);
  }
  void add(Tile newTile){
    if tiles.containsKey(newTile.getId()) == false {
      tiles.put(newTile.getId(), new ArrayList<Tile>());
    }
    tiles.get(newTile.getId()).add(newTile);
  }
  class 'packageName'."environments" Position {
    Integer x = -10000;
    Integer y = -10000;
    Environment parent = null;
    void setX(Integer newX){
      x = newX;
    }
    void setY(Integer newY){
      y = newY;
    }
    void setParent(Environment newParent){
      parent = newParent;
    }
    Double getDistanceTo(Position otherPosition){
      Integer xDirection = otherPosition.getX() - \getX() ;
      Integer yDirection = otherPosition.getY() - \getY();
      return \Math.sqrt(xDirection \* xDirection \+ yDirection \* yDirection);
    }
    Double getDirectionTo(Position otherPosition){
      Integer xDirection = otherPosition.getX() - \getX() ;
      Integer yDirection = otherPosition.getX() - \getY();
      if xDirection == 0 {
        if yDirection > 0 {
          return \Math.PI / 2.0;
        }
        else if yDirection < 0 {
          return \Math.PI * 3.0 / 2.0;
        }
        else {
          return 0.0;
        }
      }
      else {
        return \Math.atan2(yDirection,xDirection);
      }
    }
    List<Direction> getDirectionsTo(Position otherPosition){
      Integer xDirection = otherPosition.getX() - \getX() ;
      Integer yDirection = otherPosition.getX() - \getY();
      List<Direction> result = new ArrayList<Direction>();
      if xDirection == 0 {
        result.add(Direction.right);
        result.add(Direction.left);
      }
      else {
        if xDirection > 0 {
          result.add(Direction.right);
        }
        else {
          result.add(Direction.left);
        }
      }
      if yDirection == 0 {
        result.add(Direction.up);
        result.add(Direction.down);
      }
      else {
        if yDirection > 0 {
          result.add(Direction.up);
        }
        else {
          result.add(Direction.down);
        }
      }
      return result;
    }
    
    Boolean isWithin(Environment->Position otherPosition, Integer width, Integer height){
      Integer dX = otherPosition.getX() \- x;
      Integer dY = otherPosition.getY() \- y;
      return dX >= 0 && dX <= width && dY >= 0 && dY <= height;
    }
    Boolean isWithin(Environment->Position otherPosition, Float range, Double angleLeft, Double angleRight){
      Integer xDirection = \getX() - otherPosition.getX() ;
      Integer yDirection = \getY() - otherPosition.getY();
      Double radius = \Math.sqrt(\Math.pow(xDirection,2.0)+\Math.pow(yDirection,2.0));
      if xDirection == 0 {
        if yDirection < 0 {
          return radius <= range && angleLeft >= \Math.PI * 3.0 / 2.0 && angleRight <= \Math.PI * 3.0 / 2.0;
        } 
        else if yDirection > 0 {
          return radius <= range && angleLeft >= \Math.PI / 2.0 && angleRight <= \Math.PI / 2.0;
        }
        else {
          return true;
        }
      }
      else {
        Double angle = \Math.atan2(yDirection , xDirection);
        return radius <= range && angleLeft >= angle && angleRight <= angle;
      }
    }
  }
  class 'packageName'."environments" Location Environment->Position Environment->Movable {
    class Event // {
      class Move // Area->Event->Tick {
        Environment->Location actor = null;
        Direction direction = null;
         void tick(Double millisSinceLastFrame){
          Entity->Event event = direction.move(actor);
          if event!=null {
            actor.getHost().addEvent(event);
          }
        }
      }
    }
    Entity host = null;
    ~Float radius = 0.5f;
    ~Float facing = 0f;
    ~Area area = null;
    ~Tile tile = null;
    Boolean isWithin(Environment->Location otherLocation, Float range, Double angleLeft, Double angleRight){
      Float tFacing = otherLocation.getFacing();
      return \super.isWithin(otherLocation, range, angleLeft \+ tFacing, angleRight \+ tFacing);
    }
    Boolean isWithin(Environment->Position otherPosition){
      return \super.isWithin(otherPosition, radius, \Math.PI * 2.0, 0.0);
    }
    Entity->List getEntitiesWithin(Float within){
      return area.getEntitiesWithin(this,within);
    }
    Entity->List getEntitiesWithin(Float within, \EntityCriteria targetCriteria){
      return area.getEntitiesWithin(this,within,targetCriteria);
    }
    Entity getClosestEntity(\EntityCriteria criteria){
      return area.getClosestEntity(this,criteria);
    }
    Area->List getAreasWithTile(Tile->Id tileId, Float range){
      Area->List result = new Area->List();
      for Area area: parent.getAreas() {
        if area.getTileMap().containsKey(tileId) && area.getTileMap().get(tileId).isEmpty() == false {
          result.add(area);
        }
      }
      return result;
    }
    Tile->List getTilesWithin(Float range, Tile->Id id){
      Tile->List result = new Tile->List();
      for Tile tile: area.getTileMap().get(id) {
        if tile.getDistanceTo(this) <= range {
          result.add(tile);
        }
      }
      return result;
    }
    Tile getUnexploredPoint(){
      return area.getUnexploredPoint(host);
    }
    
    void step(Integer speed, Direction direction){
      facing = direction.getFloatValue();
      area.addEvent(speed, new Environment->Location->Event->Move(this,direction));
    }
    Boolean isCloseAsPossibleTo(Tile tile){
      if tile.isPassable(0,0) {
        return \isWithin(tile);
      }
      else {
        List<Direction> directions = \getDirectionsTo(tile);
        for Direction direction: directions {
          Tile neighbour = tile.getNeighbour(direction);
          if \isCloseAsPossibleTo(neighbour) == true {
            return true;
          }
        }
        return false;
      }
    }
    void move(Integer xDirection, Integer yDirection){
      x \+= xDirection;
      y \+= yDirection;
    }
    Entity->Event moveX(Integer xDirection){
      Tiles->Floor nextTile = area.getFloorTile(x\+xDirection,y);
      if nextTile == null {
        return new Entity->Event->FailedToMove(nextTile);
      }
      else if nextTile.isPassable("-xDirection",0) {
        return nextTile.acceptEntity(host);
      }
      else if nextTile.hasOccupant() {
        return new Entity->Event->FailedToMove->TileHasOccupant(nextTile,nextTile.getOccupant());
      }
      else if nextTile.getTerrain()!=null && nextTile.getTerrain().isPassable("-xDirection",0) == false {
        return new Entity->Event->FailedToMove->TerrainImpassable(nextTile,nextTile.getTerrain());
      }
      else {
        return new Entity->Event->FailedToMove(nextTile);
      }
    }
    Entity->Event moveY(Integer yDirection){
      Tiles->Floor nextTile = area.getFloorTile(x,y\+yDirection);
      if nextTile == null {
        return new Entity->Event->FailedToMove(nextTile);
      }
      else if nextTile.isPassable(0,"-yDirection") {
        return nextTile.acceptEntity(host);
      }
      else if nextTile.hasOccupant() {
        return new Entity->Event->FailedToMove->TileHasOccupant(nextTile,nextTile.getOccupant());
      }
      else if nextTile.getTerrain()!=null && nextTile.getTerrain().isPassable(0,"-yDirection") == false {
        return new Entity->Event->FailedToMove->TerrainImpassable(nextTile,nextTile.getTerrain());
      }
      else {
        return new Entity->Event->FailedToMove(nextTile);
      }
    }
    void moveTo(Environment->Position otherPosition){
      x = otherPosition.x;
      y = otherPosition.y;
      parent = otherPosition.getParent();
    }
    void moveTo(Tile otherTile){
      x = otherTile.x;
      y = otherTile.y;
      parent = otherTile.getParent();
      area = otherTile.getArea();
      tile = otherTile;
      otherTile.acceptEntity(host);
    }
    Boolean moveToAround(Tiles->Floor otherTile){
      if otherTile.hasOccupant() {
        Set<Tile> investigated = new HashSet<Tile>();
        Integer extendRadius = 0;
        Boolean moved = false;
        while investigated.size() < otherTile.getArea().getTiles().size() {
          Tiles->Floor investigate = otherTile.getArea().getTile(otherTile.getX()+1,otherTile.getY());
          if investigate != null {
            moved = \moveToAround(investigate, investigated, extendRadius);
          }
          investigate = otherTile.getArea().getTile(otherTile.getX()-1, otherTile.getY());
          if moved == false &&investigate != null {
            moved = \moveToAround(investigate, investigated, extendRadius);
          }
          investigate = otherTile.getArea().getTile(otherTile.getX(), otherTile.getY()+1);
          if moved == false && investigate != null {
            moved = \moveToAround(investigate, investigated, extendRadius);
          }
          investigate = otherTile.getArea().getTile(otherTile.getX(), otherTile.getY()-1);
          if moved == false && investigate != null {
            moved = \moveToAround(investigate, investigated, extendRadius);
          }
          if moved == true {
            return true;
          }
          extendRadius \+= 1;
        }
        return moved;
      }
      else {
        \moveTo(otherTile);
        return true;
      }
    }
    Boolean moveToAround(Tiles->Floor otherTile, Set<Tile> investigated, Integer extendRadius){
      if extendRadius == 0 && investigated.add(otherTile) {
        if otherTile.hasOccupant() == false {
          \moveTo(otherTile);
          return true;
        }
        else {
          return false;
        }
      }
      else {
        Tiles->Floor investigate = otherTile.getArea().getTile(otherTile.getX()+1,otherTile.getY());
        Boolean moved = false;
        if investigate != null {
          moved = \moveToAround(investigate, investigated, extendRadius);
        }
        investigate = otherTile.getArea().getTile(otherTile.getX()-1, otherTile.getY());
        if moved == false &&investigate != null {
          moved = \moveToAround(investigate, investigated, extendRadius\-1);
        }
        investigate = otherTile.getArea().getTile(otherTile.getX(), otherTile.getY()+1);
        if moved == false && investigate != null {
          moved = \moveToAround(investigate, investigated, extendRadius\-1);
        }
        investigate = otherTile.getArea().getTile(otherTile.getX(), otherTile.getY()-1);
        if moved == false && investigate != null {
          moved = \moveToAround(investigate, investigated, extendRadius\-1);
        }
        return moved;
      }
    }
  }
  interface 'packageName'."environments" FactoryHelper {
    void populate(Environment client, Float x, Float y){}
  }
  interface 'packageName'."environments" Factory {
    Environment create(){}
  }
  void load(){
    Area newArea = areaGenerator.generate();
    if startArea == null {
      startArea = newArea;
    }
    newArea.load();
    \add(newArea);
  }
  void tick(Double millisSinceLastFrame){
    for Area activeArea: activeAreas {
      activeArea.tick(millisSinceLastFrame);
    }
  }
> void setup(ParseContext data){
    \createList(Tile);
    \createList(Area);
  }
> void declaration(IToken declarationToken){
    String mapName = 'declarationToken->"map_header"->"mapName"';
    
    Environments += class 'packageName'."environments" mapName Environment {
      void load(){
        super.load();
      }
    }
    Environments->\mapName += class 'packageName'."environments" Factory \Object Environment->Factory {
        Environment create(){
          return new Environments->'mapName'();
        }
      }
    Environments->*"create".prependToBody(|
      if "environmentName".equals(''mapName'') {
        return new Environments->'mapName'();
      }|);
    List<String> underneathTiles = new ArrayList<String>();
    List<String> nodeTiles = new ArrayList<String>();
    List<String> backgroundTiles = new ArrayList<String>();
    
    Tiles += class mapName // {}
    declarationToken : element : map_header {
      element : atom : IMPORT_TILE {
        atom : quark : tile_declaration {
          Tiles.declaration(quark, mapName,underneathTiles);
        }
      }
    }
    for String tileName: underneathTiles {
      Environments->\mapName->*.prependToBody(|floorTiles.add(new Tiles->'mapName'->'tileName'->Factory());|);
    }
    Areas += class mapName / Area / {
    }
    Areas->\mapName += class Generator / Area->Generator / {
      Environment parent = null;
      Area generate(Environment parent){
        Area newArea = new Area();
      }
      Tiles->Floor generateFloor(Integer x, Integer y){
        Tiles->Floor result = null;
      }
      Tiles->EntryPoint generateEntryPoint(Integer x, Integer y){
        Tiles->EntryPoint result = null;
      }
    }
    Areas->\mapName->Generator->*"generate".appendToBody(|
      "parent".add("newArea");
      return "newArea"; |);
    Areas->\mapName->Generator->*"generateFloor".appendToBody(|return "result";|);
    Areas->\mapName->Generator->*"generateEntryPoint".appendToBody(|return "result";|);
    Environments->\mapName->*.prependToBody(|"areaGenerator" = new Areas->'mapName'->Generator(this);|);
    Environments->\mapName->*.prependToBody({
        if name == null {
          name = ''mapName'';
        }
      });
  }
}
class 'packageName'."environments" Areas {
}
class 'packageName'."environments" Area Environment->Position {
  > String tickEventArray = "Area.Event.Tick.Listener[]";
  > String tickEventArrayDeclaration = "new Area.Event.Tick.Listener[256]";
  > String tickEventArrayGetTick = "tickEvents[currentTickPosition++]";
  > String tickEventArrayGetPut = "tickEvents[putIndex]";
  > String tickEventArrayLength = "256";
  class Id // {
  }
  Area->Id getId(){
    return null;
  }
  Environment environment = null;
  ~ArrayList<Tile> tiles = new ArrayList<Tile>();
  ~Map<Integer, Map<Integer, Tiles\>Floor>> layout = new HashMap<Integer, Map<Integer, Tiles\>Floor>>();
  ~ArrayList<Tiles\>EntryPoint> entryPoints = new ArrayList<Tiles\>EntryPoint>();
  ~Map<Tile\>Id, ArrayList<Tile>> tileMap = new HashMap<Tile\>Id, ArrayList<Tile>>();
  ~Map<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>> floorMap = new HashMap<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>>();
  ~Map<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>> terrainMap = new HashMap<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>>();
  ~Entity->List entities = new Entity->List();
  ~Integer width = 0;
  ~Integer height = 0;
  ~Integer currentTickPosition = 0;
  
  ~'tickEventArray' tickEvents = 'tickEventArrayDeclaration'; 
  
  class Event // {
    interface Tick // {
      void tick(Double millisSinceLastFrame){
      }
      class Listener / ArrayList<Area\>Event\>Tick> / {
        void tick(Double millisSinceLastFrame){
          for Area->Event->Tick ticker: \this {
            ticker.tick(millisSinceLastFrame);
          }
          \clear();
        }
      }
    }
  }
  class Generator // {
    Area generate(){
      return null;
    }
  }
  class Generators // {
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area1) - origin.getDistanceTo(area2))";
        }
      }
      class Descending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area2) - origin.getDistanceTo(area1))";
        }
      }
    }
  }
> void setup(ParseContext data){
  }
  Tiles->Floor getFloorTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->Floor getTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tile getTile(Tile->Id findId){
    if tileMap.containsKey(findId) == false || tileMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(tileMap.get(findId));
    }
  }
  Tile getTile(Tiles->Floor->Id findId){
    if floorMap.containsKey(findId) == false || floorMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(floorMap.get(findId));
    }
  }
  Tile getTile(Tiles->Terrain->Id findId){
    if terrainMap.containsKey(findId) == false || terrainMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(terrainMap.get(findId));
    }
  }
  void load(){
    for Integer currentTickPosition < 'tickEventArrayLength' {
      'tickEventArrayGetTick' = new Area->Event->Tick->Listener();
    }
    for Tile tile: tiles {
      tile.load();
    }
  }
  void tick(Double millisSinceLastFrame){
    for Tile tile: tiles {
      tile.tick(millisSinceLastFrame);
    }
    'tickEventArrayGetTick'.tick(millisSinceLastFrame);
    if currentTickPosition >= 'tickEventArrayLength' {
      currentTickPosition = 0;
    }
  }
  void addEvent(Integer offset, Area->Event->Tick event) {
    Integer putIndex = currentTickPosition\+offset;
    if putIndex >= 'tickEventArrayLength' {
      putIndex \-= 'tickEventArrayLength';
    }
    'tickEventArrayGetPut'.add(event);
  }
  Boolean add(Entity entity){
    return entities.add(entity);
  }
  Boolean add(Tile newTile){
    newTile.setArea(this);
    if newTile.getX() \+ newTile.getWidth() > width {
      width = newTile.getX() \+ newTile.getWidth();
    }
    if newTile.getY() \+ newTile.getHeight() > height {
      height = newTile.getY() \+ newTile.getHeight();
    }
    if tileMap.containsKey(newTile.getId()) == false {
      tileMap.put(newTile.getId(), new ArrayList<Tile>());
    }
    tileMap.get(newTile.getId()).add(newTile);
    if "newTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.add("((Tiles.EntryPoint)newTile)");
    }
    else if "newTile.getId() instanceof Tiles.Floor.Id" {
      if floorMap.containsKey(newTile.getId()) == false {
        floorMap.put("(Tiles.Floor.Id)newTile.getId()",new ArrayList<Tiles\>Floor>());
      }
      floorMap.get("(Tiles.EntryPoint.Id)newTile.getId()").add("(Tiles.Floor)newTile");
      if layout.containsKey(newTile.getX()) == false {
        layout.put(newTile.getX(), new HashMap<Integer,Tiles\>Floor>());
      }
      layout.get(newTile.getX()).put(newTile.getY(),"(Tiles.Floor)newTile");
    }
    else if "newTile.getId() instanceof Tiles.Terrain.Id" {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile.getId()",new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add("(Tiles.Terrain)newTile");
    }
    return tiles.add(newTile);
  }
  void changeFloorLocation(Integer oldX, Integer oldY, Integer newX, Integer newY){
    if layout.containsKey(newX) == false {
      layout.put(newX,new HashMap<Integer, Tiles\>Floor>());
    }
    layout.get(newX).put(newY, layout.get(oldX).remove(oldY));
  }
  void changeTerrain(Tiles\>Terrain oldTile, Tiles\>Terrain newTile){
    if oldTile != null {
      if terrainMap.containsKey(oldTile.getId()) {
        terrainMap.get("(Tiles.Terrain.Id)oldTile".getId()).remove(oldTile);
      }
    }
    if newTile != null {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile".getId(), new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add(newTile);
    }
  }
  Boolean remove(Entity entity){
    return entities.remove(entity);
  }
  Boolean remove(Tile oldTile){
    oldTile.setArea(null);
    tileMap.get(oldTile.getId()).remove(oldTile);
    if "oldTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.remove(oldTile);
    }
    else if "oldTile.getId() instanceof Tiles.Floor.Id" {
      floorMap.get(oldTile.getId()).remove("(Tiles.Floor)oldTile");
      if layout.containsKey(oldTile.getX()) {
        layout.get(oldTile.getX()).remove(oldTile.getY());
      }
    }
    else if "oldTile.getId() instanceof Tiles.Terrain.Id" {
      terrainMap.get(oldTile.getId()).remove("(Tiles.Terrain)oldTile");
    }
    return tiles.remove(oldTile);
  }
  Tile getUnexploredPoint(Entity explorer){
    if entryPoints.isEmpty() == false {
      return null;
    }
    else {
      for Tiles\>EntryPoint tile: entryPoints {
        if explorer.hasExplored(tile.getSister().getArea()) == false {
          return tile;
        }
      }
      return null;
    }
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range){
    Entity->List result = new Entity->List();
    for Entity entity: entities {
      if entity.getLocation().getDistanceTo(position) <= range {
        result.add(entity);
      }
    }
    return result;
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range, \EntityCriteria criteria){
    Entity->List result = new Entity->List();
    for Entity entity: entities {
      if entity.getLocation().getDistanceTo(position) <= range && criteria.satisfies(entity) {
        result.add(entity);
      }
    }
    return result;
  }
  Entity getClosestEntity(Environment->Position position, \EntityCriteria criteria){
    Entity candidate = null;
    Double distance = Double.MAX_VALUE;
    for Entity entity: entities {
      Double candidateDistance = entity.getLocation().getDistanceTo(position);
      if candidateDistance < distance && criteria.satisfies(entity) {
        candidate = entity;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestTile(Environment->Position position, Tile->Id tileId){
    if tileMap.containsKey(tileId) == false {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: tileMap.get(tileId) {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestTile(Environment->Position position, Tiles->Terrain->Id terrainId){
    if terrainMap.containsKey(terrainId) == false {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: terrainMap.get(terrainId) {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestEntryPoint(Environment->Position position){
    if entryPoints.isEmpty() {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: entryPoints {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Boolean isWithin(Environment->Position otherPosition){
    return otherPosition.getX() >= 0 && otherPosition.getX() < "width" && otherPosition.getY() >= 0 && otherPosition.getY() < "height";
  }
}
class 'packageName'."environments" Environments {
  @Environment create(String "environmentName"){
    return null;
  }
}
class 'packageName'."environments" Direction {
  Entity->Event move(Environment->Movable movable){
    return null;
  }
  Float getFloatValue(){
    return null;
  }
  @Direction->Right right = new Direction->Right();
  class Right / Direction / {
    Entity->Event move(Environment->Movable movable){
      return movable.moveX(1);
    }
    Float getFloatValue(){
      return 0f;
    }
  }
  @Direction->Left left = new Direction->Left();
  class Left / Direction / {
    Entity->Event move(Environment->Movable movable){
      return movable.moveX(-1);
    }
    Float getFloatValue(){
      return "(float)Math.PI";
    }
  }
  @Direction->Up up = new Direction->Up();
  class Up / Direction / {
    Entity->Event move(Environment->Movable movable){
      return movable.moveY(1);
    }
    Float getFloatValue(){
      return "(float)(Math.PI/2.0)";
    }
  }
  @Direction->Down down = new Direction->Down();
  class Down / Direction / {
    Entity->Event move(Environment->Movable movable){
      return movable.moveY(-1);
    }
    Float getFloatValue(){
      return "(float)(Math.PI*1.5)";
    }
  }
}
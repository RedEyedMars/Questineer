import tiles.clws

class 'packageName'."environments" Environment \Object Loaddable Tickable {
  String name = null;
  ~Map<Integer, Map<Integer,List<Entity>>> "entityZones" = new HashMap<Integer,Map<Integer,List<Entity>>>();
  ~Map<Integer, Map<Integer,List<Tile>>> "tileZones" = new HashMap<Integer,Map<Integer,List<Tile>>>();
  ~List<Tile> "tiles" = new ArrayList<Tile>();
  ~List<Path> "paths" = new ArrayList<Path>();
  List<Tile> getTiles(Environment->Position position){
    if tileZones.containsKey(position.getZoneX())==false {
      tileZones.put(position.getZoneX(), new HashMap<Integer, List<Tile>>());
    }
    if tileZones.get(position.getZoneX()).containsKey(position.getZoneY()) ==  false {
      tileZones.get(position.getZoneX()).put(position.getZoneY(), new ArrayList<Tile>());
    }
    return tileZones.get(position.getZoneX()).get(position.getZoneY());
  }
  Tile getTile(Environment->Position position){
    List<Tile> tiles = \getTiles(position);
    for Tile tile:tiles {
      if tile.isWithin(position) {
        return tile;
      }
    }
    return null;
  }
  Path getClosestPath(Environment->Position position){
    List<Tile> tiles = \getTiles(position);
    Double distance = Double.MAX_VALUE;
    Path potentialPath = null;
    for Tile tile:tiles {
      if tile.isPath() {
        Double potentialDistance = tile.getDistanceTo(position);
        if potentialDistance < distance {
          distance = potentialDistance;
          potentialPath = "(Path)tile";
        }
      }
    }
    return potentialPath;
  }
  void addTile(Tile newTile){
    tiles.add(newTile);
    \getTiles(newTile).add(newTile);
  }
  List<Entity> getZone(Integer "zoneX", Integer "zoneY"){
    if true &&! "entityZones".containsKey("zoneX") {
      "entityZones".put("zoneX", new HashMap<Integer, List<Entity>>());
    }
    if true &&! "entityZones".get("zoneX").containsKey("zoneY") {
      "entityZones".get("zoneX").put("zoneY", new ArrayList<Entity>());
    }
    return "entityZones".get("zoneX").get("zoneY");
  }
  void addEntity(Entity "entity"){
    "entity".getLocation().setParent(this);
    "entity".getLocation().update();
  }
  Entity getClosestEntity(Environment->Position position, \EntityCriteria criteria){
    Entity potentialEntity = null;
    Double potentialDistance = Double.MAX_VALUE;
    for Entity candidate : \getZone(position.getZoneX(),position.getZoneY()) {
      Double distance = position.getDistanceTo(candidate.getLocation());
      if distance < potentialDistance && criteria.satisfies(candidate) {
        potentialEntity = candidate;
        potentialDistance = distance;
      }
    }
    return potentialEntity;
  }
  List<Entity> getEntitiesWithin(Environment->Position "position", Float "within"){
    return \getEntitiesWithin("position","within",2.0*\Math.PI,0.0);
  }
  List<Entity> getEntitiesWithin(Environment->Position "position", Float "within", Double "angleLeft", Double "angleRight"){
    List<Entity> "result" = new ArrayList<Entity>();
    for Entity "candidate" : \getZone("position".getZoneX(),"position".getZoneY()) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight") {
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX()+1,"position".getZoneY()) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX()+1,"position".getZoneY()+1) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX(),"position".getZoneY()+1) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX()-1,"position".getZoneY()+1) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX()-1,"position".getZoneY()) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX()-1,"position".getZoneY()-1) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX(),"position".getZoneY()-1) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    for Entity "candidate" : \getZone("position".getZoneX()+1,"position".getZoneY()-1) {
      if "candidate".getLocation().isWithin("position","within","angleLeft","angleRight"){
        "result".add("candidate");
      }
    }
    return "result";
  }
  class 'packageName'."environments" Position {
    Integer "zoneX" = -1001;
    Integer "zoneY" = -1001;
    Float   "locationX" = 1001f;
    Float   "locationY" = 1001f;
    Environment "parent" = null;
    
    Float getX(){
      return "locationX" \+ "zoneX" * 1000f;
    }
    Float getY(){
      return "locationY" \+ "zoneY" * 1000f;
    }
    void setParent(Environment newParent){
      "parent" = newParent;
    }
    Double getDistanceTo(Position "otherPosition"){
      Float "xDirection" = "otherPosition".getX() - \getX() ;
      Float "yDirection" = "otherPosition".getX() - \getY();
      return \Math.sqrt(\Math.pow("xDirection",2.0)+\Math.pow("yDirection",2.0));
    }
    Double getDirectionTo(Position "otherPosition"){
      Float "xDirection" = "otherPosition".getX() - \getX() ;
      Float "yDirection" = "otherPosition".getX() - \getY();
      if "xDirection" == 0 {
        if "yDirection" > 0 {
          return \Math.PI / 2.0;
        }
        else if "yDirection" < 0 {
          return \Math.PI * 3.0 / 2.0;
        }
        else {
          return 0.0;
        }
      }
      else {
        return \Math.atan2("yDirection","xDirection");
      }
    }
    
    Boolean isWithin(Environment->Position "otherPosition", Float "range", Double "angleLeft", Double "angleRight"){
      Float "xDirection" = \getX() - "otherPosition".getX() ;
      Float "yDirection" = \getY() - "otherPosition".getY();
      Double "radius" = \Math.sqrt(\Math.pow("xDirection",2.0)+\Math.pow("yDirection",2.0));
      if "xDirection" == 0 {
        if "yDirection" < 0 {
          return "radius" <= "range" && "angleLeft" >= \Math.PI * 3.0 / 2.0 && "angleRight" <= \Math.PI * 3.0 / 2.0;
        } 
        else if "yDirection" > 0 {
          return "radius" <= "range" && "angleLeft" >= \Math.PI / 2.0 && "angleRight" <= \Math.PI / 2.0;
        }
        else {
          return true;
        }
      }
      else {
        Double "angle" = \Math.atan2("yDirection" , "xDirection");
        return "radius" <= "range" && "angleLeft" >= "angle" && "angleRight" <= "angle";
      }
    }
  }
  class 'packageName'."environments" Location Environment->Position{
    Entity "host" = null;
    ~Float "facing" = 0f;
    ~Boolean "zonified" = false;
    ~Tile locationTile = null;
    ~Boolean hasChanged = true;
    Boolean isWithin(Environment->Location "otherLocation", Float "range", Double "angleLeft", Double "angleRight"){
      Float "tFacing" = "otherLocation".getFacing();
      return \super.isWithin("otherLocation", "range", "angleLeft" \+ "tFacing", "angleRight" \+ "tFacing");
    }
    List<Entity> getEntitiesWithin(Float "within"){
      return "parent".getEntitiesWithin(this,"within");
    }
    List<Entity> getEntitiesWithin(Float "within", Double "angleLeft", Double "angleRight"){
      return "parent".getEntitiesWithin(this,"within", "angleLeft", "angleRight");
    }
    Entity getClosestEntity(\EntityCriteria criteria){
      if "parent"!=null {
        return "parent".getClosestEntity(this,criteria);
      }
      else {
        return null;
      }
    }
    Path getClosestPath(){
      if "parent"!=null {
        return "parent".getClosestPath(this);
      }
      else {
        return null;
      }
    }
    Tile getTile(){
      if "parent"!=null {
        if hasChanged {
          locationTile = "parent".getTile(this);
        }
        return locationTile;
      }
      else {
        return null;
      }
    }
    void step(Float speed, Environment->Position toward){
      Double direction = \getDirectionTo(toward);
      \move(\Math.cos(direction) * speed, \Math.sin(direction) * speed); 
    }
    void move(Float "xDirection", Float "yDirection"){
      "locationX" \+= "xDirection";
      "locationY" \+= "yDirection";
      hasChanged = true;
      \update();
    }
    void move(Double "xDirection", Double "yDirection"){
      "locationX" \+= "(float)(double)xDirection";
      "locationY" \+= "(float)(double)yDirection";
      hasChanged = true;
      \update();
    }
    void moveTo(Float "xDirection", Float "yDirection"){
      if "zonified" {
        "parent".getZone("zoneX","zoneY").remove("host");
      }
      "zoneX" = "(int)(float)xDirection" / 1000;
      "zoneY" = "(int)(float)yDirection" / 1000;
      "locationX" = "xDirection" - "zoneX" * 1000;
      "locationY" = "yDirection" - "zoneY" * 1000;
      "parent".getZone("zoneX","zoneY").add("host");
      "zonified" = true;
      hasChanged = true;
    }
    void moveTo(Environment->Position "otherPosition"){
      if "zonified" {
        "parent".getZone("zoneX","zoneY").remove("host");
      }
      "zoneX" = "otherPosition"."zoneX";
      "zoneY" = "otherPosition"."zoneY";
      "locationX" = "otherPosition"."locationX";
      "locationY" = "otherPosition"."locationY";
      "parent" = "otherPosition"."parent";
      "parent".getZone("zoneX","zoneY").add("host");
      "zonified" = true;
      hasChanged = true;
    }
    void update(){
      if "locationX" > 1000 {
        if "zonified" {
           "parent".getZone("zoneX","zoneY").remove("host");
        }
        if "locationY" > 1000 {
        
          "locationX" = -1000f;
          "locationY" = -1000f;
          "zoneX" \+= 1;
          "zoneY" \+= 1;
        }
        else if "locationY" < 1000 {
          "locationX" = -1000f;
          "locationY" = 1000f;
          "zoneX" \+= 1;
          "zoneY" \-= 1;
        }
        else {
          "locationX" = -1000f;
          "zoneX" \+= 1;
        }
      }
      else if "locationX" < 1000 {
        if "locationY" > 1000 {
          "locationX" = 1000f;
          "locationY" = -1000f;
          "zoneX" \-= 1;
          "zoneY" \+= 1;
        }
        else if "locationY" < 1000 {
          "locationX" = 1000f;
          "locationY" = 1000f;
          "zoneX" \-= 1;
          "zoneY" \-= 1;
        }
        else {
          "locationX" = 1000f;
          "zoneX" \-= 1;
        }
      }
      else {
        if "locationY" > 1000 {
          if "zonified" {
            "parent".getZone("zoneX","zoneY").remove("host");
          }
          "locationY" = -1000f;
          "zoneY" \+= 1;
        }
        else if "locationY" < 1000 {
          if "zonified" {
            "parent".getZone("zoneX","zoneY").remove("host");
          }
          "locationY" = 1000f;
          "zoneY" \-= 1;
        }
      }
      "parent".getZone("zoneX","zoneY").add("host");
      "zonified" = true;
    }
  }
  interface 'packageName'."environments" FactoryHelper {
    void populate(Environment "client", Integer "zoneX", Integer "zoneY", Float "locationX", Float "locationY"){}
  }
  interface 'packageName'."environments" Factory {
    Environment create(){}
  }
  void load(){
    ~Integer "index" = 0;
    while "index" < "tiles".size() {
      "tiles".get("index").load();
      "index" \+= 1;
    }
    for Integer "xZone" : "entityZones".keySet() {
      for Integer "yZone" : "entityZones".keySet() {
		List<Entity> "entityZone" = "entityZones".get("xZone").get("yZone");
		"index" = 0;
        while "index" < "entityZone".size() {
          "entityZone".get("index").load();
          "index" \+= 1;
        }
      }
    }
  }
  void tick(Double "millisSinceLastFrame"){
    ~Integer "index" = 0;
    while "index" < "tiles".size() {
      "tiles".get("index").tick("millisSinceLastFrame");
      "index" \+= 1;
    }
    for Integer "xZone" : "entityZones".keySet() {
      for Integer "yZone" : "entityZones".keySet() {
		List<Entity> "entityZone" = "entityZones".get("xZone").get("yZone");
		"index" = 0;
        while "index" < "entityZone".size() {
          "entityZone".get("index").tick("millisSinceLastFrame");
          "index" \+= 1;
        }
      }
    }
  }
> void setup(ParseContext data){
    Class factoryHelper = Environment->FactoryHelper;
    Environment += ~List<factoryHelper> "helpers" = new ArrayList<factoryHelper>()
  }
> void declaration(IToken declarationToken){
    String mapName = 'declarationToken->"map_header"->"mapName"';
    
    Environments += class 'packageName'."environments" mapName Environment {
    }
    Environments->\mapName += class 'packageName'."environments" Factory \Object Environment->Factory {
        Environment create(){
          return new Environments->'mapName'();
        }
      }
    Environments->*"create".prependToBody(|
      if "environmentName".equals(''mapName'') {
        return new Environments->'mapName'();
      }|);
    Map<String, String> tileSymbol = new HashMap<String, String>();
    Map<String, String> pathSymbol = new HashMap<String, String>();
    declarationToken : element : map_header {
      element : atom : IMPORT_TILE {
        atom : quark : tile_declaration {
          StringBuilder tileNameBuilder = new StringBuilder();
          IToken tileNameToken = quark->"tileName";
          tileNameToken : energy : NAME {
            tileNameBuilder.append('energy'.trim());
          }
          String tileName = mapName+'tileNameBuilder'; 
          Class extendsClass;
          if quark->"PATH" != null {
            extendsClass = Path;
            pathSymbol.put('quark->"symbolName"',tileName);
          }
          else {
            extendsClass = Tile;
          }
          tileSymbol.put('quark->"symbolName"',tileName);
          Tiles += class 'packageName'."environments" tileName extendsClass {
          }
          Tiles->*"create".prependToBody({
            if "tileName".equals(''tileName'') {
              return new Tiles->\tileName(); 
            }
          });
          Tiles->\tileName += class 'packageName'."environments" Factory \Object Tile->Factory {
              Tile create(){
                return new Tiles->'tileName'();
              }
            }
          quark : energy : entity {            
            Class entityFactory = Entities.declaration(energy->"entity_declaration");
            energy : quanta : PLUS {
              Tiles->'tileName'->*.prependToBody(|"onTickEntityFactories".add(new entityFactory());|);
            }
            energy : quanta : MINUS {
              Tiles->'tileName'->*.prependToBody(|"onLoadEntityFactories".add(new entityFactory());|);
            }
          }
          
        }
      }
    }
    ~Integer mapIndex = 1;
    declarationToken : element : map_declaration {
      String mapElementName;
      if element->"mapElementName" != null {
        StringBuilder mapElementNameBuilder = new StringBuilder();
        element : atom : mapElementName {
          mapElementNameBuilder.append('atom');
        }
        mapElementName = mapElementNameBuilder.toString();
      }
      else {
        mapElementName = mapName + mapIndex;
        mapIndex \+= 1;
      }
      Environments->\mapName += class 'packageName'."environments" mapElementName \Object FactoryHelper {
        void populate(Environment "client", Integer "zoneX", Integer "zoneY", Float "locationX", Float "locationY"){
        }
      } 
      Class mapElementClass = Environments->\mapName->\mapElementName;
      Environments->\mapName->*.prependToBody(|"helpers".add(new mapElementClass());|);
      ~Integer yIndex = 0;
      Map<Integer, Map<Integer, String>> knownPaths = new HashMap<Integer, Map<Integer, String>>();
      element : atom : line {
        ~Integer xIndex = 0;
        atom : quark : tile_symbols {
          Integer xValue = xIndex;
          Integer yValue = yIndex;
          String subTileName = 'quark'+'xValue'+'yValue';
          String tileJustName = 'quark';
          if pathSymbol.containsKey('quark') {
            mapElementClass.getMethod("populate").appendToBody({
              Path 'subTileName' = new Tiles->'tileSymbol.get(tileJustName)'("zoneX","zoneY","locationX" \+ 'xValue',"locationY" \+ 'yValue' ,"client");
              "client".addTile('subTileName');
			  "client"."paths".add('subTileName');
			});
			if true &&! knownPaths.containsKey(xValue) {
			  knownPaths.put(xValue, new HashMap<Integer, String>());
			}
			knownPaths.get(xValue).put(yValue,subTileName);
			if knownPaths.get(xValue).containsKey(yValue - 1 ) {
			  mapElementClass.getMethod("populate").appendToBody({
                'subTileName'.setUp('knownPaths.get(xValue).get(yValue - 1)');
			  });
			}
			if knownPaths.containsKey(xValue - 1) && knownPaths.get(xValue - 1).containsKey(yValue) {
			  mapElementClass.getMethod("populate").appendToBody({
                'subTileName'.setLeft('knownPaths.get(xValue - 1).get(yValue)');
			  });
			}
          }
          else {
            mapElementClass.getMethod("populate").appendToBody({
              Tile 'subTileName' = new Tiles->'tileSymbol.get(tileJustName)'("zoneX","zoneY","locationX" \+ 'xValue',"locationY" \+ 'yValue' ,"client");            
              "client".addTile('subTileName');
            });
          }
          xIndex \+= 1; 
        }
        yIndex \+= 1;
      }
    }
    Environments->\mapName->*.prependToBody({
        if name == null {
          name = ''mapName'';
        }
      });
  }
}
class 'packageName'."environments" Environments {
  @Environment create(String "environmentName"){
    return null;
  }
}
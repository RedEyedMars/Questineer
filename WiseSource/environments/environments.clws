import tiles.clws

class 'packageName'."environments" Environment \Object Loaddable Tickable {
  String name = null;
  ~Map<Integer, Map<Integer,Area>> areas = new HashMap<Integer,Map<Integer,Area>>();
  ~List<Tile\>Generator> generators = new ArrayList<Tile\>Generator>();
  ~Map<Tile\>Id, List<Tile>> tiles = new HashMap<Tile\>Id, List<Tile>>();
  @Float areaRadius = 10f;
  @Integer areaMaxX = 100;
  @Integer areaMaxY = 100;
  @Float getWidth(){
    return Environment.areaRadius * Environment.areaMaxX;
  }
  @Float getHeight(){
    return Environment.areaRadius * Environment.areaMaxX;
  }
  Float getGenerationRate(){
    return 500000f;
  }
  Area getAreaSafely(Integer x, Integer y){
    if areas.containsKey(x) == false {
      areas.put(x, new HashMap<Integer,Area>());
    }
    if areas.get(x).containsKey(y) == false {
      areas.get(x).put(y, new Area(x,y,this));
    }
    return areas.get(x).get(y);
  }
  Area getAreaSafely(Environment->Position position){
    if areas.containsKey(position.getZoneX()) == false {
      areas.put(position.getZoneX(), new HashMap<Integer,Area>());
    }
    if areas.get(position.getZoneX()).containsKey(position.getZoneY()) == false {
      areas.get(position.getZoneX()).put(position.getZoneY(), new Area(position.getZoneX(), position.getZoneY(), this));
    }
    return areas.get(position.getZoneX()).get(position.getZoneY());
  }
  Area getArea(Environment->Position position){
    return areas.get(position.getZoneX()).get(position.getZoneY());
  }
  \Tile->List getTilesWithin(Environment->Position position, Float range, Tile->Id tileId){
    Tile->List result = new Tile->List();
    \getArea(position).collectTilesWithin(position,range,tileId, result, new HashSet<Area>());
    return result;
  }
  void addEntity(Entity newEntity){
    newEntity.getLocation().setParent(this);
    newEntity.getLocation().update();
  }
  
  Node getClosestNode(Environment->Position position){
    return \getArea(position).getClosestNode(position);
  }
  Tile getTile(Tile->Id findId){
    if tiles.containsKey(findId) == false || tiles.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(tiles.get(findId));
    }
  }
  void addTile(Tile newTile){
    if tiles.containsKey(newTile.getId()) == false {
      tiles.put(newTile.getId(), new ArrayList<Tile>());
    }
    tiles.get(newTile.getId()).add(newTile);
    \getArea(newTile).add(newTile);
  }
  void addGenerator(Tile->Generator generator){
    generators.add(generator);
  }
  Entity getClosestEntity(Environment->Position position, \EntityCriteria criteria){
    return \getArea(position).getClosestEntity(position,criteria);
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float within){
    return \getArea(position).\getEntitiesWithin(position,within);
  }
  class 'packageName'."environments" Position {
    Float x = -10000f;
    Float y = -10000f;
    Environment parent = null;
    
    Float getX(){
      return x;
    }
    Float getY(){
      return y;
    }
    Integer getZoneX(){
      return "(int)(x/areaRadius)";
    }
    Integer getZoneY(){
      return "(int)(y/areaRadius)";
    }
    void setParent(Environment newParent){
      parent = newParent;
    }
    Double getDistanceTo(Position otherPosition){
      Float xDirection = otherPosition.getX() - \getX() ;
      Float yDirection = otherPosition.getX() - \getY();
      return \Math.sqrt(xDirection \* xDirection \+ yDirection \* yDirection);
    }
    Double getDirectionTo(Position otherPosition){
      Float xDirection = otherPosition.getX() - \getX() ;
      Float yDirection = otherPosition.getX() - \getY();
      if xDirection == 0 {
        if yDirection > 0 {
          return \Math.PI / 2.0;
        }
        else if yDirection < 0 {
          return \Math.PI * 3.0 / 2.0;
        }
        else {
          return 0.0;
        }
      }
      else {
        return \Math.atan2(yDirection,xDirection);
      }
    }
    
    Boolean isWithin(Environment->Position otherPosition, Float width, Float height){
      Float dX = otherPosition.getX() \- x;
      Float dY = otherPosition.getY() \- y;
      return dX >= 0 && dX <= width && dY >= 0 && dY <= height;
    }
    Boolean isWithin(Environment->Position otherPosition, Float range, Double angleLeft, Double angleRight){
      Float xDirection = \getX() - otherPosition.getX() ;
      Float yDirection = \getY() - otherPosition.getY();
      Double radius = \Math.sqrt(\Math.pow(xDirection,2.0)+\Math.pow(yDirection,2.0));
      if xDirection == 0 {
        if yDirection < 0 {
          return radius <= range && angleLeft >= \Math.PI * 3.0 / 2.0 && angleRight <= \Math.PI * 3.0 / 2.0;
        } 
        else if yDirection > 0 {
          return radius <= range && angleLeft >= \Math.PI / 2.0 && angleRight <= \Math.PI / 2.0;
        }
        else {
          return true;
        }
      }
      else {
        Double angle = \Math.atan2(yDirection , xDirection);
        return radius <= range && angleLeft >= angle && angleRight <= angle;
      }
    }
  }
  class 'packageName'."environments" Location Environment->Position{
    Entity host = null;
    ~Float radius = 0.25f;
    ~Float facing = 0f;
    ~Area area = null;
    Boolean isWithin(Environment->Location otherLocation, Float range, Double angleLeft, Double angleRight){
      Float tFacing = otherLocation.getFacing();
      return \super.isWithin(otherLocation, range, angleLeft \+ tFacing, angleRight \+ tFacing);
    }
    Boolean isWithin(Environment->Position otherPosition){
      return \super.isWithin(otherPosition, radius, \Math.PI * 2.0, 0.0);
    }
    Entity->List getEntitiesWithin(Float within){
      return area.getEntitiesWithin(this,within);
    }
    Entity->List getEntitiesWithin(Float within, \EntityCriteria targetCriteria){
      return area.getEntitiesWithin(this,within,targetCriteria);
    }
    Entity->List getEntitiesWithin(Float within, Double angleLeft, Double angleRight){
      return area.getEntitiesWithin(this,within, angleLeft, angleRight);
    }
    Entity getClosestEntity(\EntityCriteria criteria){
      return area.getClosestEntity(this,criteria);
    }
    Node getClosestNode(){
      return area.getClosestNode(this);
    }
    Tile getTile(){
      return area.getTile(this);
    }
    Tile->List getTilesWithin(Float range, Tile->Id id){
      Tile->List result = new Tile->List();
      area.collectTilesWithin(this,range,id,result, new HashSet<Area>());
      return result;
    }
    Tile getClosestTile(Tile->Id id){
      return area.getClosestTile(this,id);
    }
    Node getUnexploredNode(){
      return area.getUnexploredNode();
    }
    
    void step(Float speed, Environment->Position toward){
      Double direction = \getDirectionTo(toward);
      facing = "(float)(double)direction";
      \move(\Math.cos(direction) * speed, \Math.sin(direction) * speed); 
    }
    void move(Float xDirection, Float yDirection){
      x \+= xDirection;
      y \+= yDirection;
      \update();
    }
    void move(Double xDirection, Double yDirection){
      x \+= "(float)(double)xDirection";
      y \+= "(float)(double)yDirection";
      \update();
    }
    void moveTo(Float xDirection, Float yDirection){
      x = xDirection;
      y = yDirection;
      Area oldArea = area;
      Area newArea = parent.getArea(this);
      if oldArea!=null && oldArea!= newArea {
        oldArea.remove(host);
        newArea.add(host);
        area = newArea;
      }
      else if oldArea == null {
        newArea.add(host);
        area = newArea;
      }
    }
    void moveTo(Environment->Position otherPosition){
      x = otherPosition.x;
      y = otherPosition.y;
      parent = otherPosition.getParent();
      \update();
    }
    void update(){
	  Area oldArea = area;
      Area newArea = parent.getArea(this);
      if oldArea!=null && oldArea != newArea {
        oldArea.remove(host);
        newArea.add(host);
        area = newArea;
      }
      else if oldArea == null {
        newArea.add(host);
        area = newArea;
      }
    }
  }
  interface 'packageName'."environments" FactoryHelper {
    void populate(Environment client, Float x, Float y){}
  }
  interface 'packageName'."environments" Factory {
    Environment create(){}
  }
  void load(){
    for Integer i < areaMaxX {
      areas.put(i, new HashMap<Integer,Area>());
      for Integer j < areaMaxY {
      	areas.get(i).put(j, new Area(i,j,this));
      }
    }
    for Integer i < areaMaxX {
      for Integer j < areaMaxY {
      	Area client = areas.get(i).get(j);
      	client.add(\getAreaSafely(i \+ 1,j     ));
      	client.add(\getAreaSafely(i \+ 1,j \+ 1));
      	client.add(\getAreaSafely(i     ,j \+ 1));
      	client.add(\getAreaSafely(i \- 1,j \+ 1));
      	client.add(\getAreaSafely(i \- 1,j     ));
      	client.add(\getAreaSafely(i \- 1,j \- 1));
      	client.add(\getAreaSafely(i     ,j \- 1));
      	client.add(\getAreaSafely(i \+ 1,j \- 1));
      }
    }
    for Integer i < areaMaxX {
      for Integer j < areaMaxY {
      	areas.get(i).get(j).load();
      }
    }
    
  }
  ~Integer ticks = 0;
  void tick(Double millisSinceLastFrame){
    if ticks < 25000 {
      for Tile->Generator generator: "defaultGenerators" {
        generator.generate(this);
      }
      ticks \+= 1;
    }
    for Integer i < areaMaxX {
      for Integer j < areaMaxY {
      	areas.get(i).get(j).tick(millisSinceLastFrame);
      }
    }
  }
> void setup(ParseContext data){
    Class factoryHelper = Environment->FactoryHelper;
    Environment += ~List<factoryHelper> helpers = new ArrayList<factoryHelper>()
    Class generatorHelper = Tile->Generator;
    Environment += ~List<generatorHelper> defaultGenerators = new ArrayList<generatorHelper>()
    \createList(Tile);
    \createList(Node);
  }
> void declaration(IToken declarationToken){
    String mapName = 'declarationToken->"map_header"->"mapName"';
    
    Environments += class 'packageName'."environments" mapName Environment {
      void load(){
        super.load();
      }
    }
    Environments->\mapName += class 'packageName'."environments" Factory \Object Environment->Factory {
        Environment create(){
          return new Environments->'mapName'();
        }
      }
    Environments->*"create".prependToBody(|
      if "environmentName".equals(''mapName'') {
        return new Environments->'mapName'();
      }|);
    List<String> underneathTiles = new ArrayList<String>();
    List<String> nodeTiles = new ArrayList<String>();
    List<String> backgroundTiles = new ArrayList<String>();
    
    Tiles += class mapName // {}
    declarationToken : element : map_header {
      element : atom : IMPORT_TILE {
        atom : quark : tile_declaration {
          String tileName = Tiles.declaration(quark, mapName,underneathTiles,backgroundTiles,nodeTiles);
          if tileName!=null {
            Environments->\mapName->*"load".appendToBody({
              "defaultGenerators".add(new Tiles->'mapName'->'tileName'->Generator());
            });
            if nodeTiles.contains(tileName){
              Environments->\mapName->*"load".appendToBody({
                "defaultGenerators".add(new Tiles->'mapName'->'tileName'->\Crawler());
              });
            }
          }
        }
      }
    }
    Environments->\mapName->*.prependToBody({
        if name == null {
          name = ''mapName'';
        }
      });
  }
}
class 'packageName'."environments" Area Environment->Position {
    ~Float "width" = Environment."areaRadius";
    ~Float "height" = Environment."areaRadius";
    ~List<Tile> tiles = new ArrayList<Tile>();
    ~List<Node> nodes = new ArrayList<Node>();
    ~List<Entity> entities = new Entity->List();
    ~List<Area> neighbours = new ArrayList<Area>();
    ~List<Environment\>Position> corners = new ArrayList<Environment\>Position>();
> void setup(ParseContext data){
  }
  class TopLeftCorner / Environment->Position / {
    Area parentArea = null;
    Float getX(){
      return parentArea.getX();
    }
    Float getY(){
      return parentArea.getY()+parentArea.getHeight();
    }
  }
  class TopRightCorner / Environment->Position / {
    Area parentArea = null;
    Float getX(){
      return parentArea.getX()+parentArea.getWidth();
    }
    Float getY(){
      return parentArea.getY() \+ parentArea.getHeight();
    }
  }
  class BottomLeftCorner / Environment->Position / {
    Area parentArea = null;
    Float getX(){
      return parentArea.getX();
    }
    Float getY(){
      return parentArea.getY();
    }
  }
  class BottomRightCorner / Environment->Position / {
    Area parentArea = null;
    Float getX(){
      return parentArea.getX()+parentArea.getWidth();
    }
    Float getY(){
      return parentArea.getY();
    }
  }
  Area *(Integer zoneX, Integer zoneY, Environment parentEnvironment){
    this(zoneX \* Environment.areaRadius, zoneY \* Environment.areaRadius, parentEnvironment);
  }
  void load(){
    corners.add(new TopLeftCorner(this));
    corners.add(new TopRightCorner(this));
    corners.add(new BottomLeftCorner(this));
    corners.add(new BottomRightCorner(this));
    
    for Tile tile: tiles {
      tile.load();
    }
    for Node node: nodes {
      node.load();
    }
    for Entity entity: entities {
      entity.load();
    }
  }
  void tick(Double millisSinceLastFrame){
    for Tile tile: tiles {
      tile.tick(millisSinceLastFrame);
    }
    for Entity entity: entities {
      entity.tick(millisSinceLastFrame);
    }
  }
  Boolean add(Entity entity){
    return entities.add(entity);
  }
  Boolean add(Area neighbour){
    return neighbours.add(neighbour);
  }
  Boolean add(Tile newTile){
    newTile.setArea(this);
    return tiles.add(newTile);
  }
  Boolean remove(Entity entity){
    return entities.remove(entity);
  }
  Boolean remove(Area neighbour){
    return neighbours.remove(neighbour);
  }
  Boolean remove(Tile newTile){
    newTile.setArea(null);
    return tiles.remove(newTile);
  }
  Node getUnexploredNode(){
    if nodes.isEmpty() == false {
      return nodes.get(0).getUnexploredNode();
    }
    else {
      Set<Area> collected = new HashSet<Area>();
      for Integer spreadIndex < Environment.areaMaxX {
        for Area neighbour: neighbours {
          Node unexploredNode = neighbour.collectUnexploredNode(spreadIndex,collected);
          if unexploredNode != null {
            return unexploredNode;
          }
        }
      }
      return null;
    }
  }
  Node collectUnexploredNode(Integer spreadIndex, Set<Area> visited){
    if spreadIndex == 0 {
      if visited.add(this) && nodes.isEmpty() == false {
        return nodes.get(0).getUnexploredNode();
      }
      return null;
    }
    else {
      for Area neighbour: neighbours {
        Node unexploredNode = neighbour.collectUnexploredNode(spreadIndex \- 1,visited);
        if unexploredNode != null {
          return unexploredNode;
        }
      }
      return null;
    }
  }
  Entity getEntity(Environment->Position position){
    for Entity entity:entities {
      if entity.getLocation().isWithin(position) {
        return entity;
      }
    }
    return null;
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range){
    Entity->List result = new Entity->List();
    \collectEntitiesWithin(position,range,new \EntityCriteria->\Free(),result,new HashSet<Area>());
    return result;
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range, Double angleLeft, Double angleRight){
    Entity->List result = new Entity->List();
    \collectEntitiesWithin(position,range,new \EntityCriteria->\AngleTo(position,angleLeft,angleRight),result,new HashSet<Area>());
    return result;
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range, \EntityCriteria criteria){
    Entity->List result = new Entity->List();
    \collectEntitiesWithin(position,range,criteria,result,new HashSet<Area>());
    return result;
  }
  void collectEntitiesWithin(Environment->Position position, Float range, \EntityCriteria criteria, Entity->List result, Set<Area> alreadyChecked){
    if \shortestDistanceTo(position) >= range | alreadyChecked.add(this) == false{
      return void;
    }
    for Entity entity :entities {
      if criteria.satisfies(entity) && position.getDistanceTo(entity.getLocation()) < range {
        result.add(entity);
      }
    }    
    for Area neighbour: neighbours {
      neighbour.collectEntitiesWithin(position,range,criteria,result,alreadyChecked);
    }
    return void;
  }
  Tile getTile(Environment->Position position){
    for Tile tile:tiles {
      if tile.isWithin(position) {
        return tile;
      }
    }
    return null;
  }
  Entity getClosestEntity(Environment->Position position, \EntityCriteria criteria){
    Entity->List candidates = new Entity->List();
    Set<Area> collected = new HashSet<Area>();
    Integer spreadIndex = 0;
    while spreadIndex <= Environment.areaMaxX {
      \collectEntities(spreadIndex,candidates, criteria, collected);
      if candidates.isEmpty() == false {
        return \getClosestEntity(candidates, position);
      }
      spreadIndex \+= 1;
    }
    return null;
  }
  Entity getClosestEntity(Entity->List candidates, Environment->Position position){
    Double distance = Double.MAX_VALUE;
    Entity closestEntity= null;
    for Entity candidate : candidates {
      if candidate.getLocation().getDistanceTo(position) < distance {
        closestEntity = candidate;
        distance = candidate.getLocation().getDistanceTo(position); 
      }
    }
    return closestEntity;
  } 
  void collectEntities(Integer spreadIndex, Entity->List candidates, \EntityCriteria criteria, Set<Area> collected){
    if collected.add(this) {
      if spreadIndex == 0 {
        for Entity candidate: entities {
          if criteria.satisfies(candidate) {
            candidates.add(candidate);
          }
        }
        candidates.addAll(entities);
      }
      else {
        for Area neighbour : neighbours {
          neighbour.collectEntities(spreadIndex \- 1, candidates, criteria, collected);
        }
      }
    }
  }
  Node getClosestNode(Environment->Position position){
    List<Node> candidates = new ArrayList<Node>();
    Set<Area> collected = new HashSet<Area>();
    Integer spreadIndex = 0;
    while spreadIndex <= Environment.areaMaxX {
      \collectNodes(spreadIndex,candidates,collected);
      if candidates.isEmpty() == false {
        return \getClosestNode(candidates, position);
      }
      spreadIndex \+= 1;
    }
    return null;
  }
  Node getClosestNode(List<Node> candidates, Environment->Position position){
    Double distance = Double.MAX_VALUE;
    Node closestNode = null;
    for Node candidate : candidates {
      if candidate.getDistanceTo(position) < distance {
        closestNode = candidate;
        distance = candidate.getDistanceTo(position); 
      }
    }
    return closestNode;
  } 
  void collectNodes(Integer spreadIndex, List<Node> candidates, Set<Area> collected){
    if collected.add(this) {
      if spreadIndex == 0 {
        candidates.addAll(nodes);
      }
      else {
        for Area neighbour : neighbours {
          neighbour.collectNodes(spreadIndex \- 1, candidates, collected);
        }
      }
    }
  }
  Tile getClosestTile(Environment->Position position, Tile->Id tileId){
    List<Tile> candidates = new ArrayList<Tile>();
    Set<Area> collected = new HashSet<Area>();
    Integer spreadIndex = 0;
    while spreadIndex <= Environment.areaMaxX {
      \collectTiles(spreadIndex,candidates,tileId,collected);
      if candidates.isEmpty() == false {
        return \getClosestTile(candidates, position);
      }
      spreadIndex \+= 1;
    }
    return null;
  }
  Tile getClosestTile(List<Tile> candidates, Environment->Position position){
    Double distance = Double.MAX_VALUE;
    Tile closestTile = null;
    for Tile candidate : candidates {
      if candidate.getDistanceTo(position) < distance {
        closestTile = candidate;
        distance = candidate.getDistanceTo(position); 
      }
    }
    return closestTile;
  }
  void collectTiles(Integer spreadIndex, List<Tile> candidates, Tile->Id tileId, Set<Area> collected){
    if collected.add(this) {
      if spreadIndex == 0 {
        for Tile tile:tiles {
          if tile.getId() == tileId {
            candidates.add(tile);
          }
        }
      }
      else {
        for Area neighbour : neighbours {
          neighbour.collectTiles(spreadIndex \- 1, candidates, tileId, collected);
        }
      }
    }
  }
  void collectTilesWithin(Environment->Position position, Float range, Tile->Id tileId, List<Tile> result, Set<Area> alreadyChecked){
    if \shortestDistanceTo(position) >= range | alreadyChecked.add(this) == false {
      return void;
    }
    for Tile tile:tiles {
      if tile.getId() == tileId && position.getDistanceTo(tile) <= range {
        result.add(tile);
      }
    }
    for Area neighbour: neighbours {
      neighbour.collectTilesWithin(position,range,tileId,result,alreadyChecked);
    }
  }
  Double shortestDistanceTo(Environment->Position otherPosition){
    Double topLeft = corners.get(0).getDistanceTo(otherPosition);
    Double topRight = corners.get(1).getDistanceTo(otherPosition);
    Double bottomLeft = corners.get(2).getDistanceTo(otherPosition);
    Double bottomRight = corners.get(3).getDistanceTo(otherPosition);
    if topLeft < topRight {
      if topLeft < bottomLeft {
        if topLeft < bottomRight {
          return topLeft;
        }
        else {
           return bottomRight;
        }
      }
      else {
        if bottomLeft < bottomRight {
          return bottomLeft;
        }
        else {
          return bottomRight;
        }
      }
    }
    else {
      if topRight < bottomLeft {
        if topRight < bottomRight {
          return topRight;
        }
        else {
          return bottomRight;
        }
      }
      else {
        if bottomLeft < bottomRight {
          return bottomLeft;
        }
        else {
          return bottomRight;
        }
      }
    }
  }
  Boolean isWithin(Environment->Position otherPosition){
    return \super.isWithin(otherPosition, "width"/4f \+ "height"/4f, \Math.PI * 2.0, 0.0);
  }
}
class 'packageName'."environments"."misc" DirectionsHandler {
  ~Map<Integer, Map<Integer, Set<Double>>> directions = new HashMap<Integer, Map<Integer, Set<Double>>>();
  Boolean hasOpenDirection(Environment->Position position){
    if directions.containsKey("(int)(position.getX()/5f)") == false {
      return true;
    }
    else if directions.get("(int)(position.getX()/5f)").containsKey("(int)(position.getY()/5f)") == false {
      return true;
    }
    return \hasAnyDirection("(int)(position.getX()/5f)", "(int)(position.getY()/5f)");
  }
  Boolean hasAnyDirection(Integer xZone, Integer yZone){
    return true;
  }
  Double getOpenDirection(Node newNode){
    
    Integer xZone = "(int)(newNode.getX()/5f)";
    Integer yZone = "(int)(newNode.getY()/5f)";
    if directions.containsKey(xZone) == false {
      directions.put(xZone, new HashMap<Integer, Set<Double>>());
    }
    if directions.get(xZone).containsKey(yZone) == false {
      directions.get(xZone).put(yZone, new HashSet<Double>());
      Double direction = \getRandomDirection(newNode);
      \closeDirection(xZone,yZone,direction);
      return direction;
    }
    return \getSafeDirection(xZone,yZone,newNode);
  }
  Double getRandomDirection(Node newNode){
    return null;
  }
  Double getSafeDirection(Integer xZone, Integer yZone, Node newNode){
    return null;
  }
  void closeDirection(Integer xZone, Integer yZone, Double direction){
  }
  Set<Double> getOpenDirections(Integer xZone, Integer yZone){
    if directions.containsKey(xZone) == false {
      directions.put(xZone, new HashMap<Integer, Set<Double>>());
    }
    if directions.get(xZone).containsKey(yZone) == false {
      directions.get(xZone).put(yZone, new HashSet<Double>());
    }
    return directions.get(xZone).get(yZone);
  }
  
  
> Set<Integer> directionHandlersMade = new HashSet<Integer>(); 
> void addDirectionHandler(Class inputTileClass, IToken branchToken){
    if branchToken->"sides" == null { 
      if directionHandlersMade.add(8) {
        \setupDirectionHandler(8);
      }
      inputTileClass += @DirectionsHandler directionsHandler = new DirectionsHandler->\Sided8()
    }
    else {
      Integer sides = Integer.parseInt('branchToken->"sides"');
      if directionHandlersMade.add(sides) {
        \setupDirectionHandler(sides);
      }
      String className = "Sided" \+ 'sides';
      inputTileClass += @DirectionsHandler directionsHandler = new DirectionsHandler->'className'()
    }
  }
> void setupDirectionHandler(Integer sides){
    String className = "Sided" \+ sides;
    Integer halfSides = sides/2;
    DirectionsHandler += class className / DirectionsHandler / {
      Double getRandomDirection(Node newNode){
        if newNode.getHome() == null || Math.random() < 0.5 {
          return "Math.PI*((int)("+'sides'+"*Math.random()))/"+'halfSides'+".0";
        }
        else {
          return newNode.getDirectionOfHome(); 
        }
      }
      Double getSafeDirection(Integer xZone, Integer yZone, Node newNode){
        List<Double> possibleDirections = new ArrayList<Double>('sides');
      }
      void closeDirection(Integer xZone, Integer yZone, Double direction){
      }
      Boolean hasAnyDirection(Integer xZone, Integer yZone){
        return directions.get(xZone).get(yZone).size() < 'sides';
      }
    }
    Body homeBody = new Body ();
    for Integer i < sides {
      DirectionsHandler->'className'->*"getSafeDirection".appendToBody({
        "possibleDirections".add(Math.PI*'i'/'halfSides');
      });
      homeBody.add(|"possibleDirections".add("newNode".getDirectionOfHome());|);
      Body closeBody = new Body ();
      Integer xZoneValue = \getXZone(i,sides);
      Integer yZoneValue = \getYZone(i,sides);
      for Integer j < sides {
        if i >= halfSides && j == i\-halfSides{
          j \+= 1;
        }
        ~Integer inverseJ = j\+halfSides;
        if inverseJ >= sides {
          inverseJ \-= sides;
        }
        Integer xZoneRelative = xZoneValue \+ \getXZone(inverseJ,sides);
        Integer yZoneRelative = yZoneValue \+ \getYZone(inverseJ,sides);
        Integer inverseJValue = inverseJ;
        if xZoneRelative > 0 {
          if yZoneRelative > 0 {
            closeBody.add(|\getOpenDirections("xZone"\+'xZoneRelative',"yZone"\+'yZoneRelative').add(Math.PI*'j'/'halfSides');|);
          }
          else if yZoneRelative < 0 {
            Integer yZoneRelativeReal = -1*yZoneRelative;
            closeBody.add(|\getOpenDirections("xZone"\+'xZoneRelative',"yZone"\-'yZoneRelativeReal').add(Math.PI*'j'/'halfSides');|);
          }
          else {
            closeBody.add(|\getOpenDirections("xZone"\+'xZoneRelative',"yZone").add(Math.PI*'j'/'halfSides');|);
          }
        }
        else if xZoneRelative < 0 {
          Integer xZoneRelativeReal = -1*xZoneRelative;
          if yZoneRelative > 0 {
            closeBody.add(|\getOpenDirections("xZone"\-'xZoneRelativeReal',"yZone"\+'yZoneRelative').add(Math.PI*'j'/'halfSides');|);
          }
          else if yZoneRelative < 0{
            Integer yZoneRelativeReal = -1*yZoneRelative;
            closeBody.add(|\getOpenDirections("xZone"\-'xZoneRelativeReal',"yZone"\-'yZoneRelativeReal').add(Math.PI*'j'/'halfSides');|);
          }
          else {
            closeBody.add(|\getOpenDirections("xZone"\-'xZoneRelativeReal',"yZone").add(Math.PI*'j'/'halfSides');|);
          }
        }
        else {
          if yZoneRelative > 0 {
            closeBody.add(|\getOpenDirections("xZone","yZone"\+'yZoneRelative').add(Math.PI*'j'/'halfSides');|);
          }
          else if yZoneRelative < 0{
            Integer yZoneRelativeReal = -1*yZoneRelative;
            closeBody.add(|\getOpenDirections("xZone","yZone"\-'yZoneRelativeReal').add(Math.PI*'j'/'halfSides');|);
          }
          else {
            closeBody.add(|\getOpenDirections("xZone","yZone").add(Math.PI*'j'/'halfSides');|);
          }
        }
        if i < halfSides && j\+1 == i\+halfSides {
          j \+= 1;
        }
      }
      DirectionsHandler->'className'->*"closeDirection".appendToBody({
        if "direction" == Math.PI*'i'/'halfSides' `closeBody`
      });
    }
    DirectionsHandler->'className'->*"getSafeDirection".appendToBody({
      if "newNode".getDirectionOfHome()!=null `homeBody`
      });
    DirectionsHandler->'className'->*"getSafeDirection".appendToBody({
      "possibleDirections".removeAll(directions.get("xZone").get("yZone"));
      Double direction = Range.select("possibleDirections");
      \closeDirection("xZone", "yZone", direction);
      return direction;
    });
  }
>  Integer getXZone(Integer subValue, Integer value){
    Double result = Math.cos(2.0*Math.PI*subValue/value);
    if result > 0.01 { return 1; }
    else if result < -0.01 { return -1; }
    else { return 0; }
  }
>  Integer getYZone(Integer subValue, Integer value){
    Double result = Math.sin(2.0*Math.PI*subValue/value);
    if result > 0.01 { return 1; }
    else if result < -0.01 { return -1; }
    else { return 0; }
  }
}
class 'packageName'."environments" Environments {
  @Environment create(String "environmentName"){
    return null;
  }
}
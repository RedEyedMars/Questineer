
class 'packageName'."environments" Areas {
}
class 'packageName'."environments" Area Environment->Position {
  > String tickEventArray = "Area.Event.Tick.Listener[]";
  > String tickEventArrayDeclaration = "new Area.Event.Tick.Listener[256]";
  > String tickEventArrayGetTick = "tickEvents[currentTickPosition++]";
  > String tickEventArrayGetPut = "tickEvents[putIndex]";
  > String tickEventArrayLength = "256";
  class Id // {
  }
  Area->Id getId(){
    return null;
  }
  Environment environment = null;
  ~ArrayList<Tile> tiles = new ArrayList<Tile>();
  ~Map<Integer, Map<Integer, Tiles\>Floor>> layout = new HashMap<Integer, Map<Integer, Tiles\>Floor>>();
  ~ArrayList<Tiles\>EntryPoint> entryPoints = new ArrayList<Tiles\>EntryPoint>();
  ~Map<Tile\>Id, ArrayList<Tile>> tileMap = new HashMap<Tile\>Id, ArrayList<Tile>>();
  ~Map<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>> floorMap = new HashMap<Tiles\>Floor\>Id, ArrayList<Tiles\>Floor>>();
  ~Map<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>> terrainMap = new HashMap<Tiles\>Terrain\>Id, ArrayList<Tiles\>Terrain>>();
  ~Entity->List entities = new Entity->List();
  ~Integer width = 0;
  ~Integer height = 0;
  ~Integer currentTickPosition = 0;
  
  ~'tickEventArray' tickEvents = 'tickEventArrayDeclaration'; 
  
  class Event // {
    interface Tick // {
      void tick(Double millisSinceLastFrame){
      }
      class Listener / ArrayList<Area\>Event\>Tick> / {
        void tick(Double millisSinceLastFrame){
          for Area->Event->Tick ticker: \this {
            ticker.tick(millisSinceLastFrame);
          }
          \clear();
        }
      }
    }
  }
  class Generator // {
    Area generate(){
      return null;
    }
  }
  class Generators // {
  }
  class Comparators // {
    class Distance // {
      class Ascending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area1) - origin.getDistanceTo(area2))";
        }
      }
      class Descending // Comparator<Area> {
        Environment->Position origin = null;
        \int compare(Area area1, Area area2){
          return "(int)(float)(origin.getDistanceTo(area2) - origin.getDistanceTo(area1))";
        }
      }
    }
  }
> void setup(ParseContext data){
  }
> Double declaration(IToken declarationToken, String mapName, List<String> floorTiles, Boolean isFirst, Double previousChance){
    String areaClassName = ^declarationToken->"areaName";
    String areaName = areaClassName.toLowerCase();
    Double chance = Double.parseDouble('declarationToken->"chance"')/100.0\+previousChance;
    Area->Generators->'mapName' += class areaClassName / Area->Generator / {
       Environment parent = null;
       Area generate(){
         Area newArea = new Area();
         parent.add(newArea);
       }
       Tiles->Floor generateFloor(Integer x, Integer y){
         Tiles->Floor result = null;
       }
       Area->TerrainChoice generateTerrainChoice(){
         Tiles->Floor->Factory floorFactory = null;
         Tiles->Terrain->Factory terrainFactory = null;
       }
       Tiles->EntryPoint generateEntryPoint(Integer x, Integer y){
         Tiles->EntryPoint result = null;
       }
     }
    Areas->'mapName'->Generator += ~Area->Generators->\mapName->\areaClassName 'areaName' = null
    Areas->'mapName'->Generator->*.appendToBody(|'areaName' = new Area->Generators->\mapName->\areaClassName("parent");|);
    if isFirst {
      Areas->'mapName'->Generator->*"generate".appendToBody(|
        if "chance" <= 'chance' {
          return 'areaName'.generate();
        }|);
    }
    else {
      Areas->'mapName'->Generator->*"generate".appendToBody(|
        else if "change" <= 'chance' {
          return 'areaName'.generate();
        }|);
    }
    ~String entryPointTileName = null;
    ~Integer lowEntryBound = 0;
    ~Integer upperEntryBound = -1;
    declarationToken : element : area_element {
      element : atom : entryPointGeneration {
        lowEntryBound = Integer.parseInt('atom->"range"->"lowerBound"')\+1;
        upperEntryBound = Integer.parseInt('atom->"range"->"upperBound"')\+1;
        entryPointTileName = 'atom->"tile_names"';
      }
    }
    if upperEntryBound == -1 {
      upperEntryBound = upperEntryBound \+ 1;
    }
    Body terrainChanceBody = new Body ();
    ~Double terrainChanceBuilder = 0.0;
    terrainChanceBody.add(|Float terrainChance = Range.getRandomFloat();|);
    declarationToken : element : area_element {
      element : atom : terrainGeneration {
        atom : quark : probability {
          Double terrainChanceValue = Double.parseDouble('quark->"percent"')\+terrainChanceBuilder;
          terrainChanceBody.add(|if "terrainChance" <= 'terrainChanceValue' {
              "numberOfTerrainPoints" = 'quark->"amount"';
            }|);
          terrainChanceBuilder = terrainChanceValue;
        }
        
        ~Integer choiceCount = 0;
        atom : quark : patch_element {
          choiceCount \+= 1;
        }
        
        Body terrainSwitchBody = new Body ();
        Integer choiceCountValue = choiceCount;
        Area->Generators->'mapName'->'areaClassName'->*"generateTerrainChoice".appendToBody(| switch Range.getRandom(0,'choiceCountValue') `terrainSwitchBody` |);
        ~Integer choiceIndex = 0;
        atom : quark : patch_element {
          Integer choiceIndexValue = choiceIndex;
          terrainSwitchBody.add(|
            case 'choiceIndexValue' {
              "floorFactory" = Tiles->'mapName'->'quark->"tile_names"'->\FloorFactory();
              "terrainFactory" = Tiles->'mapName'->'quark->"tile_names"'->Factory();
              "break";
            }|);
          choiceIndex \+= 1;
        }
      }
    }
    \readBlueprint('declarationToken->"AREA_BLUEPRINT"',mapName, areaClassName,lowEntryBound,upperEntryBound, entryPointTileName, terrainChanceBody );
    Body floorSwitchBody = new Body ();
    Integer numberOfFloorTiles = floorTiles.size();
    Area->Generators->'mapName'->'areaClassName'->*"generateFloor".appendToBody(|switch Range.getRandom(0,'numberOfFloorTiles') `floorSwitchBody`|);
    ~Integer floorIndex = 0;
    for String floorName: floorTiles {
      Integer floorIndexValue = floorIndex;
      floorSwitchBody.add(|case 'floorIndexValue' { "result" = new Tiles->'mapName'->'floorName'("x","y","parent"); "break"; }|);
      floorIndex \+= 1;
    }
    Area->Generators->'mapName'->'areaClassName'->*"generate".appendToBody(| return "newArea"; |);
    Area->Generators->'mapName'->'areaClassName'->*"generateTerrainChoice".appendToBody(|return new TerrainChoice("floorFactory","terrainFactory");|);
    Area->Generators->'mapName'->'areaClassName'->*"generateFloor".appendToBody(|return "result";|);
    Area->Generators->'mapName'->'areaClassName'->*"generateEntryPoint".appendToBody(|return "result";|);
    return chance;
  }
> void readBlueprint(String fileName, String mapName, String areaClassName, Integer lowEntryBound, Integer upperEntryBound, String entryPointTileName, Body terrainChanceBody ){
	ByteBuffer pixelBuffer = null;
	~BufferedImage bufferedImage = null;
	try {
	  bufferedImage = ImageIO.read(new File("../Resource/environments/maps/blueprints/"+fileName));
	}
	print catch * {}
	Integer width = bufferedImage.getWidth();
	Integer height = bufferedImage.getHeight();
	int[] pixels = new int[width*height];
	PixelGrabber pixelGrabber = new PixelGrabber(bufferedImage,0,0,width,height,pixels,0,width);
	try {
	  pixelGrabber.grabPixels();
	}
	catch * {
	  System.err.println("Pixel Grabbing interrupted!");
	  return void;
	}
	byte[] bytes = new byte[width*height*4];
	Map<Integer,Map<Integer, Region>> regions = new HashMap<Integer, Map<Integer, Region>>();
	for Integer i < width {
	  regions.put(i, new HashMap<Integer, Region>());
	  for Integer j < height {
		regions.get(i).put(j,new Region(j,width\-i, pixels[i*32+j]));
	  }
	}
	for Integer x < width\-1{
	  for Integer y < height\-1{
	    if regions.get(x).get(y).isCompatible(regions.get(x+1).get(y)) {
		  regions.get(x).get(y).add(regions.get(x+1).get(y));
		  regions.get(x+1).put(y, regions.get(x).get(y));
	    }
	    if regions.get(x).get(y).isCompatible(regions.get(x).get(y+1)) {
 		  regions.get(x).get(y).add(regions.get(x).get(y+1));
	      regions.get(x).put(y+1, regions.get(x).get(y));
        }
	  }
	}
	if regions.get(width\-2).get(height\-1).isCompatible(regions.get(width\-1).get(height\-1)) {
	  regions.get(width\-2).get(height\-1).add(regions.get(width\-1).get(height\-1));
	  regions.get(width\-1).put(height\-1, regions.get(width\-2).get(height\-1));
    }
	if regions.get(width\-1).get(height\-2).isCompatible(regions.get(width\-1).get(height\-1)) {
	  regions.get(width\-1).get(height\-2).add(regions.get(width\-1).get(height\-1));
	  regions.get(width\-1).put(height\-1, regions.get(width\-1).get(height\-2));
	}
	Set<Region> regionSet = new HashSet<Region>();
    for Integer x < width {
	  for Integer y < height {
		if(regions.get(x).get(y).getPixel()!=Region.PIXEL_ZERO&&regions.get(x).get(y).getPixel()!= -1){
		  regionSet.add(regions.get(x).get(y));
		}
	  }
	}
	for Region region: regionSet {
	  List<List<RegionPoint>> zones = region.getZones();
	  List<RegionZone> points = region.getPoints(zones);
	  ~int zoneIndex = 0;
      Body switchBody = new Body ();
      Integer numberOfZones = points.size();
	  Area->Generators->'mapName'->'areaClassName'->*"generate".appendToBody(|
	    switch Range.getRandom(0,'numberOfZones') `switchBody`|);
       
	  for RegionZone zone: points {
		Integer startX = zone.getLowerBoundX();
		Integer startY = zone.getLowerBoundY();
		Integer zoneIndexValue = zoneIndex;
		~Integer entryPointIndex = 0;
		~Integer floorIndex = 0;
		Body caseBody = new Body ();
        Body entryWhileBody = new Body ();
        Body terrainWhileBody = new Body ();
		switchBody.add(|case 'zoneIndexValue' { "generateZone"+'zoneIndexValue'("newArea"); "break"; }|);
		caseBody.add(|
	      Integer numberOfEntryPoints = Range.getRandom('lowEntryBound','upperEntryBound');
	      Set<Integer> chosenEntryPoints = new HashSet<Integer>();
	      while chosenEntryPoints.size() < numberOfEntryPoints `entryWhileBody` 
	      Integer numberOfTerrainPoints = 0; |);
	    caseBody.add(terrainChanceBody);
	    caseBody.add(|
	      Map<Integer, TerrainChoice > chosenTerrainPoints = new HashMap<Integer, TerrainChoice>();
	      while chosenTerrainPoints.size() < numberOfTerrainPoints `terrainWhileBody` |);
		for RegionPoint point: zone {
		  if point != null {
		    Integer floorIndexValue = floorIndex;
		    floorIndex \+= 1;
		    Integer pointX = point.getX()\-startX;
		    Integer pointY = point.getY()\-startY;
		    if zone.getUps().containsKey(point.getX()) {
		      for RegionEdge edge: zone.getUps().get(point.getX()) {
		        if point.getY() >= edge.getStart() && point.getY() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX\-1, pointY, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    else if zone.getDowns().containsKey(point.getX()) {
		      for RegionEdge edge: zone.getDowns().get(point.getX()) {
		        if point.getY() >= edge.getStart() && point.getY() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX\+1, pointY, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    if zone.getRights().containsKey(point.getY()) {
		      for RegionEdge edge: zone.getRights().get(point.getY()) {
		        if point.getX() >= edge.getStart() && point.getX() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX, pointY\+1, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
		    else if zone.getLefts().containsKey(point.getY()) {
		      for RegionEdge edge: zone.getLefts().get(point.getY()) {
		        if point.getX() >= edge.getStart() && point.getX() <= edge.getEnd() {
		          caseBody.add(\addAreaEntryPoint(pointX, pointY\-1, mapName, entryPointTileName, entryPointIndex));
		          entryPointIndex \+= 1;
		        }
		      }
		    }
	        caseBody.add(|
	          if "chosenTerrainPoints".containsKey('floorIndexValue') {
	            Tiles->Floor newFloorTile = "chosenTerrainPoints".get('floorIndexValue').getFloorFactory().create('pointX','pointY',"parent");
	            newFloorTile.setTerrain("chosenTerrainPoints".get('floorIndexValue').getTerrainFactory().create(newFloorTile));
	            "newArea".add(newFloorTile);
	          }
	          else {
	            "newArea".add(\generateFloor('pointX','pointY'));
	          }|);
	      }
		}
		Area->Generators->'mapName'->'areaClassName' += void "generateZone"+'zoneIndexValue'(Area newArea){}
		Area->Generators->'mapName'->'areaClassName'->*"generateZone"+'zoneIndexValue'.appendToBody(caseBody);
		
		Integer entryPointIndexValue = entryPointIndex;
		entryWhileBody.add(|"chosenEntryPoints".add(Range.getRandom(0,'entryPointIndexValue'));|);
		Integer floorIndexValue = floorIndex;
		terrainWhileBody.add(|"chosenTerrainPoints".put(Range.getRandom(0,'floorIndexValue'), \generateTerrainChoice());|);
        zoneIndex \+= 1;
	  }
	}
  }
> Statement addAreaEntryPoint(Integer pointX,Integer pointY, String mapName, String entryPointTileName,Integer entryPointIndex) {
    return |if "chosenEntryPoints".contains('entryPointIndex') {
        "newArea".add(new EntryPoints->'mapName'->'entryPointTileName'('pointX','pointY',"parent"));
      }|;
  }
>  byte getPixelA(int p){
    return (byte)((p >> 24) & 0xFF);
  }
>  byte getPixelR(int p){
    return (byte)((p >> 16) & 0xFF);
  }
>  byte getPixelG(int p){
    return (byte)((p >> 8) & 0xFF);
  }
>  byte getPixelB(int p){
    return (byte)((p >> 0) & 0xFF);
  }
  void display(){
    for Tiles->Floor->Id floorId : floorMap.keySet() {
      for Tiles\>Floor tile : floorMap.get(floorId) {
        tile.display();
      }
    }
    for Tiles\>EntryPoint tile : entryPoints {
      tile.display();
    }
  }
  Tiles->Floor getFloorTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tiles->Floor getTile(Integer x, Integer y){
    if layout.containsKey(x) {
      return layout.get(x).get(y);
    }
    else {
      return null;
    }
  }
  Tile getTile(Tile->Id findId){
    if tileMap.containsKey(findId) == false || tileMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(tileMap.get(findId));
    }
  }
  Tile getTile(Tiles->Floor->Id findId){
    if floorMap.containsKey(findId) == false || floorMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(floorMap.get(findId));
    }
  }
  Tile getTile(Tiles->Terrain->Id findId){
    if terrainMap.containsKey(findId) == false || terrainMap.get(findId).isEmpty() {
      return null;
    }
    else {
      return Range.select(terrainMap.get(findId));
    }
  }
  void load(){
    for Integer currentTickPosition < 'tickEventArrayLength' {
      'tickEventArrayGetTick' = new Area->Event->Tick->Listener();
    }
    for Tile tile: tiles {
      tile.load();
    }
  }
  void tick(Double millisSinceLastFrame){
    for Tile tile: tiles {
      tile.tick(millisSinceLastFrame);
    }
    'tickEventArrayGetTick'.tick(millisSinceLastFrame);
    if currentTickPosition >= 'tickEventArrayLength' {
      currentTickPosition = 0;
    }
  }
  void addEvent(Integer offset, Area->Event->Tick event) {
    Integer putIndex = currentTickPosition\+offset;
    if putIndex >= 'tickEventArrayLength' {
      putIndex \-= 'tickEventArrayLength';
    }
    'tickEventArrayGetPut'.add(event);
  }
  Boolean add(Entity entity){
    return entities.add(entity);
  }
  Boolean add(Tile newTile){
    newTile.setArea(this);
    if newTile.getX() \+ newTile.getWidth() > width {
      width = newTile.getX() \+ newTile.getWidth();
    }
    if newTile.getY() \+ newTile.getHeight() > height {
      height = newTile.getY() \+ newTile.getHeight();
    }
    if tileMap.containsKey(newTile.getId()) == false {
      tileMap.put(newTile.getId(), new ArrayList<Tile>());
    }
    tileMap.get(newTile.getId()).add(newTile);
    if "newTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.add("((Tiles.EntryPoint)newTile)");
    }
    else if "newTile.getId() instanceof Tiles.Floor.Id" {
      if floorMap.containsKey(newTile.getId()) == false {
        floorMap.put("(Tiles.Floor.Id)newTile.getId()",new ArrayList<Tiles\>Floor>());
      }
      floorMap.get("(Tiles.Floor.Id)newTile.getId()").add("(Tiles.Floor)newTile");
      if layout.containsKey(newTile.getX()) == false {
        layout.put(newTile.getX(), new HashMap<Integer,Tiles\>Floor>());
      }
      layout.get(newTile.getX()).put(newTile.getY(),"(Tiles.Floor)newTile");
    }
    else if "newTile.getId() instanceof Tiles.Terrain.Id" {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile.getId()",new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add("(Tiles.Terrain)newTile");
    }
    if parent != null {
      parent.add(newTile);
    }
    return tiles.add(newTile);
  }
  void changeFloorLocation(Integer oldX, Integer oldY, Integer newX, Integer newY){
    if layout.containsKey(newX) == false {
      layout.put(newX,new HashMap<Integer, Tiles\>Floor>());
    }
    layout.get(newX).put(newY, layout.get(oldX).remove(oldY));
  }
  void changeTerrain(Tiles\>Terrain oldTile, Tiles\>Terrain newTile){
    if oldTile != null {
      if terrainMap.containsKey(oldTile.getId()) {
        terrainMap.get("(Tiles.Terrain.Id)oldTile".getId()).remove(oldTile);
      }
    }
    if newTile != null {
      if terrainMap.containsKey(newTile.getId()) == false {
        terrainMap.put("(Tiles.Terrain.Id)newTile".getId(), new ArrayList<Tiles\>Terrain>());
      }
      terrainMap.get(newTile.getId()).add(newTile);
    }
  }
  Boolean remove(Entity entity){
    return entities.remove(entity);
  }
  Boolean remove(Tile oldTile){
    oldTile.setArea(null);
    tileMap.get(oldTile.getId()).remove(oldTile);
    if "oldTile.getId() instanceof Tiles.EntryPoint.Id" {
      entryPoints.remove(oldTile);
    }
    else if "oldTile.getId() instanceof Tiles.Floor.Id" {
      floorMap.get(oldTile.getId()).remove("(Tiles.Floor)oldTile");
      if layout.containsKey(oldTile.getX()) {
        layout.get(oldTile.getX()).remove(oldTile.getY());
      }
    }
    else if "oldTile.getId() instanceof Tiles.Terrain.Id" {
      terrainMap.get(oldTile.getId()).remove("(Tiles.Terrain)oldTile");
    }
    return tiles.remove(oldTile);
  }
  Tile getUnexploredPoint(Entity explorer){
    if entryPoints.isEmpty() == false {
      return null;
    }
    else {
      for Tiles\>EntryPoint tile: entryPoints {
        if explorer.hasExplored(tile.getSister().getArea()) == false {
          return tile;
        }
      }
      return null;
    }
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range){
    Entity->List result = new Entity->List();
    for Entity entity: entities {
      if entity.getLocation().getDistanceTo(position) <= range {
        result.add(entity);
      }
    }
    return result;
  }
  Entity->List getEntitiesWithin(Environment->Position position, Float range, \EntityCriteria criteria){
    Entity->List result = new Entity->List();
    for Entity entity: entities {
      if entity.getLocation().getDistanceTo(position) <= range && criteria.satisfies(entity) {
        result.add(entity);
      }
    }
    return result;
  }
  Entity getClosestEntity(Environment->Position position, \EntityCriteria criteria){
    Entity candidate = null;
    Double distance = Double.MAX_VALUE;
    for Entity entity: entities {
      Double candidateDistance = entity.getLocation().getDistanceTo(position);
      if candidateDistance < distance && criteria.satisfies(entity) {
        candidate = entity;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestTile(Environment->Position position, Tile->Id tileId){
    if tileMap.containsKey(tileId) == false {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: tileMap.get(tileId) {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestTile(Environment->Position position, Tiles->Terrain->Id terrainId){
    if terrainMap.containsKey(terrainId) == false {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: terrainMap.get(terrainId) {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Tile getClosestEntryPoint(Environment->Position position){
    if entryPoints.isEmpty() {
      return null;
    }
    Tile candidate = null;
    Double distance = Double.MAX_VALUE;
    for Tile tile: entryPoints {
      Double candidateDistance = tile.getDistanceTo(position);
      if candidateDistance < distance  {
        candidate = tile;
        distance = candidateDistance;
      }
    }
    return candidate;
  }
  Boolean isWithin(Environment->Position otherPosition){
    return otherPosition.getX() >= 0 && otherPosition.getX() < "width" && otherPosition.getY() >= 0 && otherPosition.getY() < "height";
  }
  
  class TerrainChoice // {
    Tiles->Floor->Factory floorFactory = null;
    Tiles->Terrain->Factory terrainFactory = null;
  }
}
> class RegionPoint // {
    ~Integer x = 0;
	~Integer y = 0;
	~Integer pixel = 0;
	RegionPoint *(int ix, int iy, int ip){
	  x = ix;
	  y = iy;
	  pixel = ip;
	}
  }
> class RegionZone // Iterable<RegionPoint> {
	~Map<Integer, Map<Integer, RegionPoint>> map = new HashMap<Integer, Map<Integer,RegionPoint>>();
	~Map<Integer, List<RegionEdge>> ups = new HashMap<Integer, List<RegionEdge>>();
	~Map<Integer, List<RegionEdge>> downs = new HashMap<Integer, List<RegionEdge>>();
	~Map<Integer, List<RegionEdge>> rights = new HashMap<Integer, List<RegionEdge>>();
	~Map<Integer, List<RegionEdge>> lefts = new HashMap<Integer, List<RegionEdge>>();
    ~Integer lowerBoundX = Integer.MAX_VALUE;
    ~Integer lowerBoundY = Integer.MAX_VALUE;
    ~Integer upperBoundX = 0;
    ~Integer upperBoundY = 0;
    ~RegionPoint previousEdgePoint = null;
    void add(RegionPoint newPoint){
      if newPoint.getX() < lowerBoundX {
        lowerBoundX = newPoint.getX();
      }
      if newPoint.getY() < lowerBoundY {
        lowerBoundY = newPoint.getY();
      }
      if newPoint.getX() > upperBoundX {
        upperBoundX = newPoint.getX();
      }
      if newPoint.getY() > upperBoundY {
        upperBoundY = newPoint.getY();
      }
      if map.containsKey(newPoint.getX()) == false{
        map.put(newPoint.getX(),new HashMap<Integer, RegionPoint>());
      }
      map.get(newPoint.getX()).put(newPoint.getY(),newPoint);
    }
    void addEdgePoint(RegionPoint edge){
      if previousEdgePoint != null {
        if edge.getX() > previousEdgePoint.getX() {
          if rights.containsKey(previousEdgePoint.getY()) == false {
            rights.put(previousEdgePoint.getY(), new ArrayList<RegionEdge>());
          }
          rights.get(previousEdgePoint.getY()).add(new RegionEdge(previousEdgePoint.getX(),edge.getX()));
        }
        else if edge.getX() < previousEdgePoint.getX() {
          if lefts.containsKey(edge.getY()) == false {
            lefts.put(edge.getY(), new ArrayList<RegionEdge>());
          }
          lefts.get(edge.getY()).add(new RegionEdge(edge.getX(),previousEdgePoint.getX()));
        }
        else if edge.getY() > previousEdgePoint.getY() {
          if ups.containsKey(previousEdgePoint.getX()) == false {
            ups.put(previousEdgePoint.getX(), new ArrayList<RegionEdge>());
          }
          ups.get(previousEdgePoint.getX()).add(new RegionEdge(previousEdgePoint.getY(),edge.getY()));
        }
        else if edge.getY() < previousEdgePoint.getY() {
          if downs.containsKey(edge.getX()) == false {
            downs.put(edge.getX(), new ArrayList<RegionEdge>());
          }
          downs.get(edge.getX()).add(new RegionEdge(edge.getY(),previousEdgePoint.getY() ));
        }
      }
      previousEdgePoint = edge;
    }
    Iterator<RegionPoint> iterator(){
      return new RegionZoneIterator(this);
    }
  }
> class RegionEdge // {
    ~Integer startEdge = 0;
    ~Integer endEdge = 0;
    RegionEdge *(Integer initialStart, Integer initialEnd){
      startEdge = initialStart;
      endEdge = initialEnd;
    }
    Integer getStart(){
      return startEdge;
    }
    Integer getEnd(){
      return endEdge;
    }
  }
< Iterable : \java.\lang;
< Iterator : \java.\util;
> class RegionZoneIterator // Iterator<RegionPoint>  {
    ~RegionZone toIterate = null;
    ~Integer x = 0;
    ~Integer y = 0;
    ~Map<Integer, Map<Integer, RegionPoint>> map = null;
    RegionZoneIterator *(RegionZone iIterable){
      toIterate = iIterable;
      x = toIterate.getLowerBoundX();
      y = toIterate.getLowerBoundY();
      map = toIterate.getMap();
    }
    boolean hasNext(){
      return x <= toIterate.getUpperBoundX() && y <= toIterate.getUpperBoundY();
    }
    void advanceIndex(){
      if y == toIterate.getUpperBoundY() {
        y = toIterate.getLowerBoundY();
        x \+= 1;
      }
      else {
        y \+= 1;
      }
    }
    RegionPoint next(){
      if map.containsKey(x) {
        if map.get(x).containsKey(y) {
          RegionPoint point = map.get(x).get(y);
          \advanceIndex();
          return point;
        }
        else {
          \advanceIndex();
          return null;
        }
      }
      else {
        \advanceIndex();
        return null;
      }
    }
    
    void remove(){
    }
  }
> class Region // {
	@int PIXEL_ZERO = -16777216;
	@int PIXEL_GREEN = -11731200;
	@int PIXEL_RED = -65536;
	@int PIXEL_CYAN = -16711681;
	@int PIXEL_PURPLE = -65316;
	@int PIXEL_YELLOW = -10240;
    ~Integer x = 0;
	~Integer y = 0;
	~Integer pixel = 0;
	Map<Integer, Set<RegionPoint>> pixelMap = new HashMap<Integer, Set<RegionPoint>>();
	Map<Integer, Set<RegionPoint>> horizontals = new HashMap<Integer,Set<RegionPoint>>();
	Region *(int ix, int iy, int ipixel){
	  x = ix;
	  y = iy;
	  pixel = ipixel;
	  pixelMap.put(pixel, new HashSet<RegionPoint>());
	  pixelMap.get(pixel).add(new RegionPoint(x,y,pixel));
	  horizontals.put(y, new HashSet<RegionPoint>());
	  horizontals.get(y).add(new RegionPoint(x,y,pixel));
	}
	void add(Region otherRegion){
	  for Integer p : otherRegion.pixelMap.keySet() {
	    if pixelMap.containsKey(p) == false {
	      pixelMap.put(p, new HashSet<RegionPoint>());
	    }
	    pixelMap.get(p).addAll(otherRegion.pixelMap.get(p));
	  }
	  for Integer y : otherRegion.horizontals.keySet() {
		 if horizontals.containsKey(y) == false {
		   horizontals.put(y, new HashSet<RegionPoint>());
		 }
		 horizontals.get(y).addAll(otherRegion.horizontals.get(y));
	  }
	}
	List<RegionZone> getPoints(List<List<RegionPoint>> zones){
		List<RegionZone> points = new ArrayList<RegionZone>();
		for List<RegionPoint> zone: zones {
		  RegionZone zonePoints = new RegionZone();
		  points.add(zonePoints);
		  ~Integer i = 1;
		  while i<zone.size()-1 {
			if zone.get(i).getPixel()==PIXEL_CYAN && zone.get(i+1).getPixel()==PIXEL_RED {
				int baseX = zone.get(i).getX();
				int endX = zone.get(i+1).getX();
				~int y = zone.get(i).getY();
				while y>=zone.get(i-1).getY() {
				  for RegionPoint point: horizontals.get(y) {
				    if point.getX() >= baseX && point.getX() <= endX {
				    	zonePoints.add(point);
				    }
				  }
				  y \-= 1;
				}
			}
		    i \+= 1;
		  }
		  for RegionPoint point: zone {
		    zonePoints.addEdgePoint(point);
		  }
		}
		return points;
	}
	List<List<RegionPoint>> getZones(){
	  List<List<RegionPoint>> results = new ArrayList<List<RegionPoint>>();
	  if pixelMap.containsKey(PIXEL_YELLOW) {
	    for RegionPoint yellowPoint : pixelMap.get(PIXEL_YELLOW) {
	      List<RegionPoint> zone = new ArrayList<RegionPoint>();
	      zone.add(yellowPoint);
	      \makeZone(results,zone,\getCounterPoints(yellowPoint), yellowPoint);
	    }
	  }
	  return results;
	}
	void makeZone(List<List<RegionPoint>> zones, List<RegionPoint> zone, List<RegionPoint> counters, RegionPoint startPoint){
	  for RegionPoint point: counters {
	    if point.getPixel() == PIXEL_YELLOW {
	      if point == startPoint {
	        zones.add(zone);
	      }
	    }
	    else {
	      List<RegionPoint> newZone = new ArrayList<RegionPoint>();
	      newZone.addAll(zone);
	      newZone.add(point);
	      \makeZone(zones,newZone,\getCounterPoints(point),startPoint);
	    }
	  }
	}
	List<RegionPoint> getCounterPoints(RegionPoint point){
	  List<RegionPoint> result = new ArrayList<RegionPoint>();
	  if point.getPixel() == PIXEL_YELLOW || point.getPixel() == PIXEL_RED || point.getPixel() == PIXEL_GREEN {
	    if pixelMap.containsKey(PIXEL_CYAN) {
	      for RegionPoint otherPoint: pixelMap.get(PIXEL_CYAN)  {
	        if point.getX() == otherPoint.getX() {
	          result.add(otherPoint);
	        }
	      }
	    }
	  }
	  else if point.getPixel() == PIXEL_CYAN {
	    if pixelMap.containsKey(PIXEL_YELLOW) {
	      for RegionPoint otherPoint: pixelMap.get(PIXEL_YELLOW) {
	        if point.getY() == otherPoint.getY() {
	          result.add(otherPoint);
	        }
	      }
	    }
	    if pixelMap.containsKey(PIXEL_RED) {
	      for RegionPoint otherPoint: pixelMap.get(PIXEL_RED) {
	        if point.getY() == otherPoint.getY() {
	          result.add(otherPoint);
	        }
	      }
	    }
	  }
	  return result;
	}
	Boolean isBlack(){
	  return pixel == PIXEL_ZERO;
	}
	Boolean isWhite(){
	  return pixel == -1;
	}
	Boolean isCompatible(Region other){
	  if pixel == PIXEL_ZERO {
	    if other.pixel == PIXEL_ZERO {
		  return true;
		}
		else {
		  return false;
		}
	  }
	  else if pixel == -1 {
		if other.pixel == -1 {
		  return true;
		}
		else {
		  return false;
		}
	  }
	  else {
		if other.pixel == PIXEL_ZERO {
		  return false;
		}
		else if other.pixel == -1 {
		  return false;
		}
		else {
		  return true;
		}
	  }
	}
  }
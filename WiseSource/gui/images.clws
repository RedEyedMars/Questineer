
> void setupGui() {
	Gui += @StringBuilder _log = new StringBuilder()
	Gui += @void log(String toLog) {
		_log.append(toLog);
		_log.append(''"\\n"'');
	}
	Gui += ~Integer finishedKey = Keyboard.KEY_ESCAPE
	Gui += String window_title = ''"OpenGL Window"''
	Gui += ~Boolean VSyncEnabled = true
	Gui += ~Boolean useCurrentDisplay = false
	Gui += ~Boolean fullScreen = false
	Gui += ~Boolean showMessages = true
	Gui += ~Integer displayWidth = "1024"
	Gui += Integer displayHeight = "786"
	Gui += Integer displayColorBits = "-1"
	Gui += Integer displayFrequency = "-1"
	Gui += Integer depthBufferBits = "24"
	Gui += DisplayMode originalDisplayMode = null
	Gui += DisplayMode displayMode = null
	Gui->*.appendToBody({
	  \load();
	  \run();
	});
	Gui += void initializeDisplay() {
	  "originalDisplayMode" = Display.getDisplayMode();
	  Gui.log(''"GLApp.initDisplay(): Current display mode is "'' \+ "originalDisplayMode" );
	  if "displayHeight" == -1 {
		"displayHeight" = "originalDisplayMode".getHeight();
	  }
	  if "displayWidth" == -1 {
		"displayWidth" = "originalDisplayMode".getWidth();
	  }
	  if "displayColorBits" == -1 {
		"displayColorBits" = "originalDisplayMode".getBitsPerPixel();
	  }
	  if "displayFrequency" == -1 {
		"displayFrequency" = "originalDisplayMode".getFrequency();
	  }
	  try {
		if useCurrentDisplay {
		  "displayMode" = "originalDisplayMode";
		}
		else {
		  "displayMode" = \getDisplayMode(displayWidth,displayHeight,displayColorBits,displayFrequency);
		  if "displayMode" == null{
			"displayMode" = \getDisplayMode(1024,768,32,60);
			if "displayMode" == null {
			  "displayMode" = \getDisplayMode(1024,768,16,60);
			  if "displayMode" == null {
				"displayMode" = \getDisplayMode("originalDisplayMode".getWidth(),"originalDisplayMode".getHeight(),"originalDisplayMode".getBitsPerPixel(),"originalDisplayMode".getFrequency());
				if "displayMode" == null {
				  \System.err.println(''"Gui Load Display Cant find a compatible Display Mode!!!"'');
				}
			  }
			}
		  }
		}
		Gui.log(''"initializeDisplay: Setting display mode to "'' \+ "displayMode" \+ ''" with pixel depth = "'' \+ "depthBufferBits" );
		Display.setDisplayMode("displayMode");
		"displayMode" = "displayMode";
		"displayWidth" = "displayMode".getWidth();
		"displayHeight"= "displayMode".getHeight();
		"displayColorBits" = "displayMode".getBitsPerPixel();
		"displayFrequency" ="displayMode".getFrequency();
	  }
	  print catch * {
		\System.err.println(''"initializeDisplay: Failed to create display: "'');
		\System.exit(1);
	  }
	  try {
		Display.create(new PixelFormat(0,depthBufferBits,8));
		Display.setTitle(window_title);
		Display.setFullscreen(fullScreen);
		Display.setVSyncEnabled(VSyncEnabled);
	  }
	  print catch *{
		\System.err.println(''"initializeDisplay: Failed to create OpenGL window"'');
		\System.exit(1);
	  }
	}
	String displayModeArrayType = "DisplayMode[]"; 
	Gui += DisplayMode getDisplayMode(Integer width,Integer height,Integer colourBits,Integer frequency) {
	  try {
		'displayModeArrayType' allDisplayModes = Display.getAvailableDisplayModes();
		DisplayMode tempDisplayMode = null;
		for Integer i < allDisplayModes.length {
		  tempDisplayMode = "allDisplayModes[i]";
		  if tempDisplayMode.getWidth() == width && tempDisplayMode.getHeight() == height && tempDisplayMode.getBitsPerPixel() == colourBits && tempDisplayMode.getFrequency() == frequency {
			return tempDisplayMode;
		  }
		}
	  }
	  print catch *{
		\System.err.println(''"getDisplayMode Failed"'');
	  }
	  return null;
	}
	Gui += void run() {
	  try {
		while "isRunning" {
		  if Display.isVisible() == false {
			Thread.sleep("200L");
		  }
		  else if Display.isCloseRequested(){
			"isRunning" = false;
		  }
		  else {
			Thread.sleep(1);
		  }
		  "inputHandler".handle();
		  "game".update();
		  "renderer".render();
		  Display.update();
		}
	  }
	  print catch Interrupted {}
	  "inputHandler".end();
	  #"game".update();#
	  "renderer".end();
	}
  }

class 'packageName'."gui" InputHandler Thread{
  @Integer UNSTARTED = -1;
  @Integer WAITING_FOR_EVENTS = 0;
  @Integer PROCESSING_EVENTS = 1;
  ~Integer status = UNSTARTED;
  ~List<InputHandler\>Event> events = new ArrayList<InputHandler\>Event>();
  ~Integer cursorX = 0;
  ~Integer cursorY = 0;
  ~Boolean firstMove = true;
  ~Boolean continuousKeyboard = false;
  ~Boolean hideNativeCursor = false;
  ~Boolean disableNativeCursor = false;
  @void addMouseListener(InputHandler->Events->MouseEvent->Listener toAdd) {
	synchronized InputHandler->Events->MouseEvent.listeners {
	  InputHandler->Events->MouseEvent.listeners.add(toAdd);
	}
  }
  @void removeMouseListener(InputHandler->Events->MouseEvent->Listener toRemove) {
	synchronized InputHandler->Events->MouseEvent.listeners {
	  InputHandler->Events->MouseEvent.listeners.remove(toRemove);
	}
  }
  @void addMouseWheelListener(InputHandler->Events->MouseWheelEvent->Listener toAdd) {
	synchronized InputHandler->Events->MouseWheelEvent.listeners {
	  InputHandler->Events->MouseWheelEvent.listeners.add(toAdd);
	}
  }
  @void removeWheelMouseListener(InputHandler->Events->MouseWheelEvent->Listener toRemove) {
	synchronized InputHandler->Events->MouseWheelEvent.listeners {
	  InputHandler->Events->MouseWheelEvent.listeners.remove(toRemove);
	}
  }
  @void addKeyboardListener(InputHandler->Events->KeyboardEvent->Listener toAdd) {
	synchronized InputHandler->Events->KeyboardEvent.listeners{
	  InputHandler->Events->KeyboardEvent.listeners.add(toAdd);
	}
  }
  @void removeKeyboardListener(InputHandler->Events->KeyboardEvent->Listener toRemove) {
	synchronized InputHandler->Events->KeyboardEvent.listeners {
	  InputHandler->Events->KeyboardEvent.listeners.remove(toRemove);
	}
  }
  void run() {
	try {
	  while Gui.isRunning{
		status=WAITING_FOR_EVENTS;
		synchronized events{
		  while events.isEmpty(){
			events.wait();
		  }
		}
		status=PROCESSING_EVENTS;
		while events.isEmpty() == false {
		  events.remove(0).handle();
		}
	  }
	}
	print catch Interrupted {
	}
  }
  void load(DisplayMode displayMode) {
	try {
	  Keyboard.create();
	  if "disableNativeCursor" {
		"disableNativeCursor"(true);
		cursorX = `"(int) displayMode.getWidth() / 2"`;
		cursorY = `"(int) displayMode.getHeight() / 2"`;
	  }
	  if "hideNativeCursor" {
		"hideNativeCursor"(true);
	  }
	}
	print catch * {
	  \System.err.println(''"InputHandler.load: "''\+\e0);
	}
	\start();
  }
  void handle() {
	Integer mouseDX = Mouse.getDX();
	Integer mouseDY = Mouse.getDY();
	Integer mouseDW = Mouse.getDWheel();
	synchronized events {
	  if mouseDX != 0 || mouseDY!=0 || mouseDW != 0 {
		cursorX = Mouse.getX();
		cursorY = Mouse.getY();
		events.add(new InputHandler->Events->MouseEvent->Move(cursorX,cursorY));
	  }
	  if mouseDW!=0 {
		events.add(new InputHandler->Events->MouseWheelEvent(mouseDW));
	  }
	  while Mouse.next(){
		if Mouse.getEventButtonState() {
		  events.add(new InputHandler->Events->MouseEvent->Press(Mouse.getEventButton(),cursorX,cursorY));
		}
		else {
		  events.add(new InputHandler->Events->MouseEvent->Release(Mouse.getEventButton(),cursorX,cursorY));
		}
	  }
	  if Mouse.isButtonDown(0) {
		events.add(new InputHandler->Events->MouseEvent->Drag(0,cursorX,cursorY));
	  }
	  if Mouse.isButtonDown(1) {
		events.add(new InputHandler->Events->MouseEvent->Drag(1,cursorX,cursorY));
	  }
	  if Keyboard.next() {
		if Keyboard.getEventKeyState(){
		  events.add(new InputHandler->Events->KeyboardEvent->Press(Keyboard.getEventKey(),Keyboard.getEventCharacter()));
		}
		else {
		  events.add(new InputHandler->Events->KeyboardEvent->Release(Keyboard.getEventKey()));
		}
		while Keyboard.next(){
		  if Keyboard.getEventKeyState(){
			events.add(new InputHandler->Events->KeyboardEvent->Press(Keyboard.getEventKey(),Keyboard.getEventCharacter()));
		  }
		  else {
			events.add(new InputHandler->Events->KeyboardEvent->Release(Keyboard.getEventKey()));
		  }
		}
	  }
	  else if continuousKeyboard&&Keyboard.getEventKeyState(){
		events.add(new InputHandler->Events->KeyboardEvent->Press(Keyboard.getEventKey(),Keyboard.getEventCharacter()));
	  }
	  if status == WAITING_FOR_EVENTS{
		events.notifyAll();
	  }
	}
  }
  void end(){
    if status == WAITING_FOR_EVENTS {
      synchronized events {
        events.notifyAll();
      }
    }
  }
  void disableNativeCursor(Boolean newNativeCursorValue) {
	"disableNativeCursor" = newNativeCursorValue;
	Mouse.setGrabbed(newNativeCursorValue);
  }
  void hideNativeCursor(Boolean hide) {
	"hideNativeCursor" = hide;
	Integer canHide = `"Cursor.getCapabilities() & Cursor.CURSOR_ONE_BIT_TRANSPARENCY"`;
	if canHide==0 {
	  \System.err.println(''"Renderer hideHardwareCursor(): No hardwared cursor support!"'');
	  return void;
	}
	try {
	  if hide {
		Cursor cursor = null;
		Integer cursorImageCount = 1;
		Integer cursorWidth = Cursor.getMaxCursorSize();
		Integer cursorHeight = cursorWidth;
		IntBuffer cursorImages = null;
		IntBuffer cursorDelays = null;
		cursorImages=ByteBuffer.allocateDirect(cursorWidth*cursorHeight*cursorImageCount*4).order(ByteOrder.nativeOrder()).asIntBuffer();
		for Integer i < cursorWidth {
		  for Integer j < cursorHeight {
			cursorImages.put("0x00000000");
		  }
		}
		cursorImages.flip();
		cursor = new Cursor(
		  Cursor.getMaxCursorSize(),
		  Cursor.getMaxCursorSize(),
		  Cursor.getMaxCursorSize()/2,
		  Cursor.getMaxCursorSize()/2,
		  cursorImageCount,cursorImages,cursorDelays);
		Mouse.setNativeCursor(cursor);
	  }
	  else {
		Mouse.setNativeCursor(null);
	  }
	}
	print catch *{
	  \System.err.println(''"Renderer hideHardwareCursor(): error"'');
	}
  }
  class Events // {
	class MouseWheelEvent / InputHandler->Event / {
	  @List<InputHandler\>Events\>MouseWheelEvent\>Listener> listeners = new ArrayList<InputHandler\>Events\>MouseWheelEvent\>Listener>();
	  Integer amount = 0;
	  void handle() {
		synchronized InputHandler->Events->MouseWheelEvent.listeners {
		  for InputHandler->Events->MouseWheelEvent->Listener listener : InputHandler->Events->MouseWheelEvent.listeners {
			listener.listen(this);
		  }
		}
	  }
	  interface Listener //{
		void listen(InputHandler->Events->MouseWheelEvent event){}
	  }
	}
	class MouseEvent / InputHandler->Event / {
	  @List<InputHandler\>Events\>MouseEvent\>Listener> listeners = new ArrayList<InputHandler\>Events\>MouseEvent\>Listener>();
	  Integer cursorX = 0;
	  Integer cursorY = 0;
	  ~Boolean isLeftButton = false;
	  ~Boolean isRightButton = false;
	  Boolean isDrag() {
		return false;
	  }
	  Boolean isMove() {
		return false;
	  }
	  Boolean isPress() {
		return false;
	  }
	  Boolean isRelease() {
		return false;
	  }
	  interface Listener//{
		void listen(InputHandler->Events->MouseEvent->Drag event){}
		void listen(InputHandler->Events->MouseEvent->Press event){}
		void listen(InputHandler->Events->MouseEvent->Release event){}
		void listen(InputHandler->Events->MouseEvent->Move event){}
	  }
	  class Move /InputHandler->Events->MouseEvent/{
		Move *(Integer cursorX,Integer cursorY) {
		  \super(cursorX,cursorY);
		}
		Boolean isMove() {
		  return true;
		}
		void handle() {
		  synchronized InputHandler->Events->MouseEvent.listeners {
			for InputHandler->Events->MouseEvent->Listener listener: InputHandler->Events->MouseEvent.listeners {
			  listener.listen(this);
			}
		  }
		}
	  }
	  class Drag / InputHandler->Events->MouseEvent/ {
		Drag *(Integer button,Integer cursorX,Integer cursorY) {
		  \super(cursorX,cursorY);
		  \setIsLeftButton(button==0);
		  \setIsRightButton(button==1);
		}
		Boolean isDrag() {
		  return true;
		}
		void handle() {
		  synchronized InputHandler->Events->MouseEvent.listeners {
			for InputHandler->Events->MouseEvent->Listener listener: InputHandler->Events->MouseEvent.listeners {
			  listener.listen(this);
			}
		  }
		}
	  }
	  class Press / InputHandler->Events->MouseEvent /{
		Press *(Integer button,Integer cursorX,Integer cursorY) {
		  \super(cursorX,cursorY);
		  \setIsLeftButton(button==0);
		  \setIsRightButton(button==1);
		}
		Boolean isPress() {
		  return true;
		}
		void handle() {
		  synchronized InputHandler->Events->MouseEvent.listeners{
			for InputHandler->Events->MouseEvent->Listener listener: InputHandler->Events->MouseEvent.listeners {
			  listener.listen(this);
			}
		  }
		}
	  }
	  class Release / InputHandler->Events->MouseEvent /{
		Release *(Integer button,Integer cursorX,Integer cursorY) {
		  \super(cursorX,cursorY);
		  \setIsLeftButton(button==0);
		  \setIsRightButton(button==1);
		}
		Boolean isRelease() {
		  return true;
		}
		void handle() {
		  synchronized InputHandler->Events->MouseEvent.listeners {
			for InputHandler->Events->MouseEvent->Listener listener: InputHandler->Events->MouseEvent.listeners {
			  listener.listen(this);
			}
		  }
		}
	  }
	}
	class KeyboardEvent / InputHandler->Event / {
	  @List<InputHandler\>Events\>KeyboardEvent\>Listener> listeners = new ArrayList<InputHandler\>Events\>KeyboardEvent\>Listener>();
	  Integer keyInt = 0;
	  \Character keyChar = 0;
	  Boolean isPress() {
		return false;
	  }
	  Boolean isRelease() {
		return false;
	  }
	  interface Listener //{
		void listen(InputHandler->Events->KeyboardEvent->Press event){}
		void listen(InputHandler->Events->KeyboardEvent->Release event){}
	  }
	  class Press / InputHandler->Events->KeyboardEvent /{
		Press *(Integer keyInt,\Character keyChar) {
		  \super(keyInt,keyChar);
		}
		Boolean isPress() {
		  return true;
		}
		void handle() {
		  synchronized InputHandler->Events->KeyboardEvent.listeners{
			for InputHandler->Events->KeyboardEvent->Listener listener: InputHandler->Events->KeyboardEvent.listeners {
			  listener.listen(this);
			}
		  }
		}
	  }
	  class Release / InputHandler->Events->KeyboardEvent /{
		Release *(Integer keyInt) {
		  \super(keyInt,"(char)0");
		}
		Boolean isRelease() {
		  return true;
		}
		void handle() {
		  synchronized InputHandler->Events->KeyboardEvent.listeners {
			for InputHandler->Events->KeyboardEvent->Listener listener : InputHandler->Events->KeyboardEvent.listeners{
			  listener.listen(this);
			}
		  }
		}
	  }
	}
  }
  class Event // {
    void handle() {
	}
  }
}

import renderer.clws

import images.clws


< BufferedImage : \java.\awt.\image;
< ImageIO : \javax.\imageio;
< ByteOrder : \java.\nio;
< ByteBuffer : \java.\nio;
< FloatBuffer : \java.\nio;
< IntBuffer : \java.\nio;
< GL11        : \org.\lwjgl.\opengl;
< GL12        : \org.\lwjgl.\opengl;
< GLU        : \org.\lwjgl.\util.\glu;
< PixelGrabber : \java.\awt.\image;
< DisplayMode : \org.\lwjgl.\opengl;
< Display : \org.\lwjgl.\opengl;
< Keyboard : \org.\lwjgl.\input ;
< Mouse : \org.\lwjgl.\input ;
< Cursor : \org.\lwjgl.\input ;
< Sys : \org.\lwjgl ;
< PixelFormat : \org.\lwjgl.\opengl;


> Integer INT_SIZE = 4;

enum  'packageName'."gui"."images" ImageStates {
  void DEFAULT;
  void ASCEND;
}
class 'packageName'."gui"."images" Images {}
class 'packageName'."gui"."images" Colours {}
class 'packageName'."gui"."images" Drawables {}
class 'packageName'."gui"."images" ImageLoader {
> Map<Class , Parameters > animationCreationParameters = new HashMap< Class , Parameters >();
> Map<Class , Parameters > animationCreationArguments = new HashMap< Class , Parameters >();
  FloatBuffer placeHolder = null;
  void load(){
  }
> void declaration(IToken input, Class enclosingClass){
    String animationTypeName = ^input->"animationTypeName";
    if enclosingClass == Gui->Image->AnimationType {
      enclosingClass += ~class animationTypeName // Gui->Renderable{
        void animate(){ }
        void render(){
          \animationRender();
        }
        Integer getTexture(){
          return \getImageTexture();
        }
      }
    }
    else {
      enclosingClass += ~class animationTypeName // Gui->Renderable{
        void animate(){ }
        void render(){
          \animationRender();
        }
        Integer getTexture(){
          return \getImageTexture();
        }
      }
    }
    Parameters parameters = new Parameters ();
    Parameters arguments = new Parameters ();
    input : variable : animation_type_variable_declaration {
      variable : element : animation_variable_value {
        arguments.add(|'variable->"variableName"'|);
        element : value : INTEGER {
          enclosingClass->'animationTypeName' += Integer 'variable->"variableName"' = 'value'
          parameters.add(Integer 'variable->"variableName"' = 'value';);
        }
        element : value : FLOAT {
          enclosingClass->'animationTypeName' += Float 'variable->"variableName"' = 'value'+"f"
          parameters.add(Integer 'variable->"variableName"' = 'value';);
        }
        element : value : quote {
          enclosingClass->'animationTypeName' += String 'variable->"variableName"' = ''value''
          parameters.add(Integer 'variable->"variableName"' = 'value';);
        }
      }
    }
    animationCreationParameters.put(enclosingClass->'animationTypeName' , parameters);
    animationCreationArguments.put(enclosingClass->'animationTypeName' , arguments);
    ~Class creationClass = enclosingClass->'animationTypeName';
    ~String creationName = "";
    Parameters previousParameters = new Parameters ();
    Parameters previousArguments = new Parameters ();
    ~String previousCreationName = null;
    while creationClass.getEnclosingClass() != Gui->Image->AnimationType {
      creationName = 'creationClass.getName()'\+ creationName;
      String createMethodName = "create"\+'creationName';
      Class upperClass = creationClass.getEnclosingClass();
      Parameters realParameters = new Parameters ();
      realParameters.addAll(animationCreationParameters.get(creationClass));
      realParameters.addAll(previousParameters);
      Statement creation = new Statement ();
      creation.add(|new creationClass(`animationCreationArguments.get(creationClass)`)|);
      if previousCreationName != null {
        creation.set(".");
        String currentPreviousCreationName = previousCreationName;
        Parameters currentPreviousArguements = new Parameters();
        currentPreviousArguements.addAll(previousArguments);
        creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
      }
      previousCreationName = createMethodName;
      upperClass += enclosingClass->'animationTypeName' 'createMethodName' `realParameters` {
        return `creation`;
      }
      previousParameters.addAll(animationCreationParameters.get(creationClass));
      previousArguments.addAll(animationCreationArguments.get(creationClass));
      creationClass = upperClass;
    }
    creationName = 'creationClass.getName()'\+ creationName;
    String createMethodName = "create"\+'creationName';
    Parameters realParameters = new Parameters ();
    realParameters.addAll(animationCreationParameters.get(creationClass));
    realParameters.addAll(previousParameters);
    Statement creation = new Statement ();
    creation.add(|new creationClass(`animationCreationArguments.get(creationClass)`)|);
    if previousCreationName != null {
      creation.set(".");
      String currentPreviousCreationName = previousCreationName;
      Parameters currentPreviousArguements = new Parameters();
      currentPreviousArguements.addAll(previousArguments);
      creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
    }
    Gui->Image->AnimationType += enclosingClass->'animationTypeName' 'createMethodName' `realParameters` {
      return `creation`;
    }
    Parameters imageAnimationParameters = new Parameters ();
    imageAnimationParameters.add( Integer animationX = 0; );
    imageAnimationParameters.add( Integer animationY = 0; );
    Parameters imageAnimationArguments = new Parameters();
    imageAnimationArguments.add( |"animationX"| );
    imageAnimationArguments.add( |"animationY"| );
    String currentPreviousCreationName = "create"\+creationName;
    Parameters currentPreviousArguements = new Parameters ();
    currentPreviousArguements.addAll(animationCreationArguments.get(creationClass));
    if previousCreationName != null {
      imageAnimationParameters.addAll(animationCreationParameters.get(creationClass));
      imageAnimationParameters.addAll(previousParameters);
      currentPreviousArguements.addAll(previousArguments);
      Gui->Image += enclosingClass->'animationTypeName' 'createMethodName' `imageAnimationParameters` {
        Gui->Image->AnimationType base = new Gui->Image->AnimationType(`imageAnimationArguments`);
        return base.'currentPreviousCreationName'(`currentPreviousArguements`);
      }
    }
    else {
      imageAnimationParameters.addAll(animationCreationParameters.get(creationClass));
      Gui->Image += enclosingClass->'animationTypeName' 'createMethodName' `imageAnimationParameters` {
        Gui->Image->AnimationType base = new Gui->Image->AnimationType(`imageAnimationArguments`);
        return base.'currentPreviousCreationName'(`currentPreviousArguements`);
      }
    }
    input : element : animation_type_element {
      element : atom : animation_type_declaration {
        ImageLoader.declaration(atom,enclosingClass->'animationTypeName');
      }
      element : atom : statement {
        Statement statement = new Statement ();
        statement.add(|'atom->"variableName"'|);
        statement.set('atom->"anit_operator"');
        atom : quark : value {
          statement.add(|'quark'|);
        }
        : anit_arithmetic_operator {
          statement.set('quark'.trim());
        }
        
        if atom->"animation_type_boolean" != null {
          Statement header = new Statement ();
          atom : quark : animation_type_boolean {
            Statement headerElement = new Statement();
            headerElement.add(|'quark->"leftName"'|);
            headerElement.set('quark->"anit_boolean_operator"');
            quark : energy : value {
              energy : quanta : INTEGER {
                headerElement.add(|'quanta'|);
              }
              : FLOAT {
                headerElement.add(|'quanta'+"f"|);
              }
              : NAME {
                headerElement.add(|'quanta'|);
              }
              : frameName {
                String methodName = "get" \+ ^quanta;
                headerElement.add(|"frames".'methodName'()|);
              }
              
            }
            : anit_arithmetic_operator {
              headerElement.set('energy'.trim());
            }
            header.add(headerElement);
          }
          : anit_continuation_operator {
            if 'quark'.contains("&") {
              header.set("&&");
            }
            else if 'quark'.contains("|") {
              header.set("||");
            }
          }
          enclosingClass->'animationTypeName'->*"animate".appendToBody({if `header` {`statement`;}});
        }
        else {
          enclosingClass->'animationTypeName'->*"animate".appendToBody({`statement`;});
        }
      }
    }
  }
> Set<String> declaredImageLoaders = new HashSet<String>();
> void declareImageLoader(String imageName, String imageFileName, Integer imageWidth, Integer imageHeight){
    String imageLoaderName = imageName\+"DataLoader";
    String imageLoaderClassName = "ImageData"\+'imageWidth'\+"x"\+'imageHeight'\+"Loader";
    ImageLoader->*"load".prependToBody({
      'imageLoaderName'.start();
    });
    ImageLoader->*"load".prependToBody({'imageLoaderClassName' 'imageLoaderName' = new 'imageLoaderClassName'(''imageFileName'');});
    ImageLoader->*"load".appendToBody({
      'imageLoaderName'.attachTextures(Images->'imageName',null);
    });
    if declaredImageLoaders.add(imageLoaderClassName) == false {
      return void;
    }
    Integer totalSize = imageWidth * imageHeight;
    Integer totalByteSize = imageWidth * imageHeight * 4;
    ImageLoader += class imageLoaderClassName / Thread / {
      String fileName = null;
      ~ByteBuffer pixelBuffer = null;
      ~ByteBuffer flippedPixelBuffer = null;
      ~Boolean failed = false;
      void run(){
        BufferedImage bufferedImage = null;
    	try { bufferedImage = ImageIO.read(new File(fileName));	}
    	print catch * { failed = true;  return void;	}
        'pintArrayType' pixels = "new int["+'totalSize'+"]";
        PixelGrabber pixelGrabber = new PixelGrabber(bufferedImage, 0, 0, 'imageWidth', 'imageHeight', pixels, 0, 'imageWidth');
        try { pixelGrabber.grabPixels(); }
        catch * { \System.err.println(''"Pixel Grabbing interrupted!"''); failed = true; return void; }
        #if (flipVertically) {
            jpixels = flipPixels(jpixels, imgw, imgh);
        }#
        'byteArrayType' bytes = "new byte["+'totalByteSize'+"]";
        'byteArrayType' flippedBytes = "new byte["+'totalByteSize'+"]";
        \int p = 0;
        \int r = 0;
        \int g = 0;
        \int b = 0;
        \int a = 0;
        int i = 0;
        int j = 0;
        int k = 0;
        for int y < 'imageHeight' {
          for int x < 'imageWidth' {
            i = (256 * y) \+ x;
            j = i * 4;
            k = 4*(256*(y\+1)-x-1) ;
            p = pixels[i]; 
            a = (p >> 24) & 0xFF; r = (p >> 16) & 0xFF;  g = (p >> 8) & 0xFF; b = (p >> 0) & 0xFF;
            bytes[j\+0] = (byte)r;  bytes[j\+1] = (byte)g;  bytes[j\+2] = (byte)b; bytes[j\+3] = (byte)a;
            flippedBytes[k\+0] = (byte)r;  
            flippedBytes[k\+1] = (byte)g; 
            flippedBytes[k\+2] = (byte)b; 
            flippedBytes[k\+3] = (byte)a;
          }
        }
        pixelBuffer = ByteBuffer.allocateDirect('totalByteSize').order(ByteOrder.nativeOrder());
        pixelBuffer.put(bytes).flip();
        flippedPixelBuffer = ByteBuffer.allocateDirect('totalByteSize').order(ByteOrder.nativeOrder());
        flippedPixelBuffer.put(flippedBytes).flip();
      }
      void attachTextures(Gui->Image imageObject, Gui->Image flippedImageObject){
        try {
          \super.join();
        }
        print catch Interrupted {}
        if failed == true {
    	  imageObject.setTexture(0);
          return void;
		}
    	
    	imageObject.setTexture(\getTextureFromPixelBuffer(pixelBuffer));
    	if flippedImageObject != null {
    	  flippedImageObject.setTexture(\getTextureFromPixelBuffer(pixelBuffer));  
    	}
      }
      @int getTextureFromPixelBuffer(ByteBuffer pixels){
        
        \int texture = 0;
        IntBuffer textureHandle = ByteBuffer.allocateDirect('INT_SIZE').order(ByteOrder.nativeOrder()).asIntBuffer();
        GL11.glGenTextures(textureHandle);
        texture = textureHandle.get(0);
        GL11.glPushAttrib(GL11.GL_TEXTURE_BIT);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
        GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
        GL11.glTexImage2D(GL11.GL_TEXTURE_2D,
          0, 						
          GL11.GL_RGBA8,			
          'imageWidth', 'imageHeight', 					
          0,						
          GL11.GL_RGBA, 			
          GL11.GL_UNSIGNED_BYTE,	
          pixels);
        GL11.glPopAttrib();
		GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
    	Integer result = GLU.gluBuild2DMipmaps(GL11.GL_TEXTURE_2D, GL11.GL_RGBA8,
    		'imageWidth', 'imageHeight',
    		GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, pixels);
    	if result != 0 {
    	  \System.err.println(''"GLApp.makeTextureMipMap(): Error occured while building mip map, result="'' \+ result \+ ''" error="'' \+ GLU.gluErrorString(result) );
    	}
    	GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
    	GL11.glTexEnvf(GL11.GL_TEXTURE_ENV, GL11.GL_TEXTURE_ENV_MODE, GL11.GL_MODULATE);
    	return texture;
      }
    }
  }
}

> String floatArrayType = "Float[]";
> String intArrayType = "Integer[]";
> String pintArrayType = "int[]";
> String byteArrayType = "byte[]";
> String floatBufferArray = "FloatBuffer[][]";
class 'packageName'."gui" Gui {
  FloatBuffer placeHolder = null;
  @Boolean isRunning = true;
  ImageLoader imageLoader = null;
  InputHandler inputHandler = null;
  @Game game = null;
  @Renderer renderer = null;
  void load(){
    \initializeDisplay();
    inputHandler = new InputHandler();
    inputHandler.load(\displayMode);
    imageLoader = new ImageLoader();
    imageLoader.load();
    renderer = new Renderer();
    renderer.load(\displayMode);
    game = new Game();
    game.load();
  }
  interface Renderable // {
    Integer getTexture(){}
    void render(){}
    void animate(){}
  }
  interface Statable // {
    Gui->Image->States asStates(){}
    Gui->Drawable asStates(Gui->Drawable drawable){}
  }

  class Image // Renderable {
    String imageFileName = null;
    Gui->Image->Dimensions pixels = null;
    Gui->Image->Dimensions frames = null;
    ~Integer texture = -1;
    ~'floatBufferArray' textureBuffer = null;
    Integer getImageTexture(){
      return texture;
    }
    void animate(){}
    void render(){
      GL11.glTexCoordPointer(2, 0, "textureBuffer[0][0]");
    }
    class Dimensions // {
      Integer width = -1;
      Integer height = -1;
    }
    Gui->Image->Crop getCrop(Integer frameX, Integer frameY){
      return new Gui->Image->Crop(frameX, frameY);
    }
    ~class Crop // Renderable {
      Integer frameX = 0;
      Integer frameY = 0;
      void animate(){}
      void render(){
        GL11.glTexCoordPointer(2, 0, "textureBuffer[frameX][frameY]");
      }
      void setFrameX(Integer newX){ frameX = newX; }
      void setFrameY(Integer newY){ frameY = newY; }
      Integer getTexture(){
        return \getImageTexture();
      }
    }
    class States // Renderable Statable {
      ~Gui->Renderable current = null;
      ~ImageStates state = ImageStates.DEFAULT;
      ~ImageStates parentState = ImageStates.DEFAULT;
      void animate(){
        current.animate();
      }      
      void render(){
        current.render();
      }
      Integer getTexture(){
        return current.getTexture();
      }
      void changeState(ImageStates newState){
      }
      Gui->Image->States asStates(){
        return this;
      }
      Gui->Drawable asStates(Gui->Drawable drawable){
        return drawable.image(this);
      }
    }
    ~class AnimationType / / Renderable {
      Integer x = 0;
      Integer y = 0;
      void animate(){ }      
      void render(){
        GL11.glTexCoordPointer(2, 0, "textureBuffer[x][y]");
      }
      void animationRender(){
        GL11.glTexCoordPointer(2, 0, "textureBuffer[x][y]");
      }
      Integer getTexture(){
        return \getImageTexture();
      }
      void setFrameX(Integer newX){ x = newX; }
      void setFrameY(Integer newY){ y = newY; }
      void tick(Double millisSinceLastFrame){
        \animate();
        \setFrameX(x);
        \setFrameY(y);
      }
    }
>   Map<String,Set<String>> declaredTextureBuffers = new HashMap<String,Set<String>>();
>   Map<String,Set<String>> animationStateFirstSet = new HashMap<String,Set<String>>();
>   Set<String> animationStatesByImage = new HashSet<String>();
>   Set<String> animationStates = new HashSet<String>();
>   Map<String, Body > animationStateAscendBodies = new HashMap<String, Body >();
>   Map<String, Body > animationStateChangeSwitches = new HashMap<String, Body >();
>   Map<String,Map<String, Body >> animationStateChangeBodies = new HashMap<String,Map<String, Body >>();
>   Map<String,Map<String, Statement >> firstOrDefaultFlipMethods = new HashMap<String,Map<String, Statement >>();
>   Map<String,Map<String, Statement >> firstOrDefaultStateVariables = new HashMap<String,Map<String, Statement >>();
>   void declaration(IToken input){
      try {
        String imageName = 'input->"imageName"';
        String imageClassName = ^input->"imageName";
        String imageFileName = "../Resource/gui/images/"\+'input->"image_file_name"'\+"."\+'input->"image_type"';
        BufferedImage bimg = ImageIO.read(new File(imageFileName));
        Integer pWidth = bimg.getWidth();
        Integer pHeight = bimg.getHeight();
        Images += @Images->'imageClassName' 'imageName' = new Images->'imageClassName'()
        Images += class imageClassName / Gui->Image / Gui->Statable {
        }
        Images->'imageClassName'->*.appendToBody({
          imageFileName = ''imageFileName'';
          pixels = new Gui->Image->Dimensions('pWidth','pHeight');
          frames = new Gui->Image->Dimensions('input->"frameWidth"','input->"frameHeight"');
        });
        if declaredTextureBuffers.containsKey('input->"frameWidth"')==false || declaredTextureBuffers.get('input->"frameWidth"').contains('input->"frameHeight"')==false {
          \declareTextureBuffer('input->"frameWidth"','input->"frameHeight"');
        }
        String textureBufferMethodLoaderClassName = "TextureBuffer"\+'input->"frameWidth"'\+"x"\+'input->"frameHeight"'\+"Loader";
        ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
          Images->'imageName'.setTextureBuffer(textureBuffer);
        });
        String imageLoaderClassName = "ImageData"\+'pWidth'\+"x"\+'pHeight'\+"Loader";
        ImageLoader.declareImageLoader(imageName,imageFileName,pWidth,pHeight);
        Images->'imageClassName' += class States / Gui->Image->States / {
          void changeState(ImageStates newState){
          }
        }
        Images->'imageClassName' += Images->'imageClassName'->States asStates() { return new Images->'imageClassName'->States(); }
        Images->'imageClassName' += Gui->Drawable asStates(Gui->Drawable drawable) { return drawable.image(new Images->'imageClassName'->States()); }
        Images->'imageClassName'->States += Images->'imageClassName'->States asStates() {
          Images->'imageClassName'->States result = new Images->'imageClassName'->States();
          result.setCurrent(current);
          result.setState("state");
          result.setParentState("parentState"); 
          return result;
        }
        Images->'imageClassName'->States += Gui->Drawable asStates(Gui->Drawable drawable) {
          Images->'imageClassName'->States result = new Images->'imageClassName'->States();
          result.setCurrent(current);
          result.setState("state");
          result.setParentState("parentState"); 
          return drawable.image(result);
        }
        
        Images->'imageClassName' += Gui->Drawable asDrawable(Gui->Drawable drawable) { return drawable.image(this); }
        ~Boolean isFirst = true;
        
        if input->"animation_state" == null {
          Images->'imageClassName'->States += Gui->Renderable "defaultState" = \Images.'imageName' 
          Images->'imageClassName'->States->*.appendToBody({\setCurrent("defaultState");});
        }
        animationStateFirstSet.put(imageClassName,new HashSet<String>());
        animationStateChangeBodies.put(imageClassName, new HashMap<String, Body >());
        firstOrDefaultFlipMethods.put(imageClassName, new HashMap<String, Statement >());
        firstOrDefaultStateVariables.put(imageClassName, new HashMap<String, Statement >());
        firstOrDefaultFlipMethods.get(imageClassName).put("", new Statement ());
        firstOrDefaultStateVariables.get(imageClassName).put("", new Statement ());
        Body stateAscendBody = new Body ();
        animationStateAscendBodies.put(imageClassName,stateAscendBody);
        Body stateSwitchBody = new Body ();
        animationStateChangeSwitches.put(imageClassName,stateSwitchBody);
        Body defaultStateBody = new Body ();
        animationStateChangeBodies.get(imageClassName).put("",defaultStateBody);
        Images->'imageClassName'->States->*"changeState".appendToBody({
          if "newState" == ImageStates."ASCEND" {
            switch "newState" `stateAscendBody`
            return void;
          }
          switch "parentState" `stateSwitchBody`
          });
        animationStateChangeSwitches.get(imageClassName).add(|
              case "DEFAULT" {
                switch "newState" `defaultStateBody`
                return void;
              }|);
        input : atom : animation_state {
          \getAnimationStateDeclaration(atom,imageName,imageClassName,"");
        }
        
      }
      print catch  IO {}
    }
>   void getAnimationStateDeclaration(IToken declaration, String imageName, String imageClassName, String parentStateName){
      declaration : atom
        : parentState {
          String currentStateName;
          if parentStateName.equals(""){
            currentStateName = 'atom->"animationId"';
          }
          else {
            currentStateName = 'atom->"animationId"'\+"_"\+parentStateName;
          }
          Body currentSwitchBody = new Body ();
          animationStateChangeBodies.get(imageClassName).put(currentStateName,currentSwitchBody);
          animationStateChangeSwitches.get(imageClassName).add(|
              case 'currentStateName' {
                switch "newState" `currentSwitchBody`
                return void;
              }
            |);
          Statement firstOrDefaultVariable = new Statement ();
          firstOrDefaultStateVariables.get(imageClassName).put(currentStateName,firstOrDefaultVariable);
          Statement firstOrDefaultMethod = new Statement ();
          firstOrDefaultFlipMethods.get(imageClassName).put(currentStateName,firstOrDefaultMethod);
          \declareFlipMethod(animationStatesByImage.add(imageClassName), imageClassName, 'atom->"animationId"', currentStateName, parentStateName, firstOrDefaultStateVariables.get(imageClassName).get(currentStateName));
          
          atom : quark : animation_state {
            \getAnimationStateDeclaration(quark,imageName,imageClassName,currentStateName);
          }
          if animationStates.add(currentStateName) {
            ImageStates += void 'currentStateName'
          }
          if animationStates.add('atom->"animationId"') {
            ImageStates += void 'atom->"animationId"'
          }
        }
        : finalState {
          ~Boolean isFirst = animationStatesByImage.add(imageClassName);
          ~List< Parameters > arguments = new ArrayList< Parameters >();
          arguments.add( new Parameters () );
          Parameters multipleArguments = new Parameters ();
          Parameters xArgumentLayer = new Parameters();
          List< Parameters > yArgumentLayers = new ArrayList< Parameters >();
          ~Integer yArgumentLayerSize = 0;
          ~Integer valueIndex = 0;
          atom : element : animation_variable_value {
            element : value : range {
              List< Parameters > oldArguments = arguments;
              arguments = new ArrayList<Parameters >();
              Integer lowerBound = Integer.parseInt('value->"lowerBound"');
              Integer upperBound = Integer.parseInt('value->"upperBound"');
              for Parameters args: oldArguments {
                if valueIndex == 1 {
                  yArgumentLayerSize = upperBound\-lowerBound \+ 1;
                }
                for Integer i <= upperBound\-lowerBound {
                  Parameters newArg = new Parameters ();
                  newArg.addAll(args);
                  Integer index = i+lowerBound;
                  newArg.add(|'index'|);
                  arguments.add(newArg);
                  if valueIndex == 0 {
                    Parameters yArgumentLayer = new Parameters ();
                    yArgumentLayers.add(yArgumentLayer);
                    xArgumentLayer.add(|"new Gui.Renderable[]{"+`yArgumentLayer`+"}"|);
                  }
                }
              }
            }
            element : value : INTEGER {
              for Parameters args: arguments {
                args.add(|'value'|);
              }
              if valueIndex == 0 {
                Parameters yArgumentLayer = new Parameters ();
                yArgumentLayers.add(yArgumentLayer);
                xArgumentLayer.add(|"new Gui.Renderable[]{"+`yArgumentLayer`+"}"|);
              }
              else if valueIndex == 1 {
                yArgumentLayerSize = 1 ;
              }
            }
            element : value : FLOAT {
              for Parameters args: arguments {
                args.add(|'value'|);
              }
            }
            element : value : quote {
              for Parameters args: arguments {
                args.add(|'' 'value' ''|);
              }
            }
            valueIndex \+= 1;
          }
          multipleArguments.add(|"new Gui.Renderable[][]{"+`xArgumentLayer`+"}"|);
          String creationMethod = "create"\+'atom->"animationTypeName"';
          
          String currentStateName;
          if parentStateName.equals("") {
            currentStateName = 'atom->"animationId"';
          }
          else {
            currentStateName = parentStateName \+ "_"\+'atom->"animationId"';
          }
          if arguments.size() == 1{
            if animationStates.add('atom->"animationId"') {
              ImageStates += void 'atom->"animationId"'
            }
            if animationStates.add(currentStateName) {
              ImageStates += void 'currentStateName'
            }
          }
          else {
            for Integer i < arguments.size() {
              if animationStates.add('atom->"animationId"'\+"_"\+i) {
                ImageStates += void 'atom->"animationId"'+"_"+'i'
              }
              if animationStates.add(currentStateName\+"_"\+i) {
                ImageStates += void 'currentStateName'+"_"+'i'
              }
            }
          }
          if arguments.size() == 1{
            Images->'imageClassName'->States += Gui->Renderable 'currentStateName'+"State" = \Images.'imageName'.'creationMethod'(`arguments.get(0)`)
            if animationStateFirstSet.get(imageClassName).add(parentStateName) {
              firstOrDefaultFlipMethods.get(imageClassName).get(parentStateName).add(|'currentStateName'();|);
              firstOrDefaultStateVariables.get(imageClassName).get(parentStateName).add(|'currentStateName'+"State"|);
            }
            \declareFlipMethod(isFirst, imageClassName, 'atom->"animationId"', currentStateName, parentStateName, |'currentStateName'+"State"|);
          }
          else {
            ~Integer realIndex = 0;
            for Parameters args: arguments {
              Integer indexValue = realIndex;
              if animationStateFirstSet.get(imageClassName).add(parentStateName) {
                firstOrDefaultFlipMethods.get(imageClassName).get(parentStateName).add(|'currentStateName'+"_"+'realIndex'();|);
                firstOrDefaultStateVariables.get(imageClassName).get(parentStateName).add(|'currentStateName'+"State_"\+'indexValue'|);
              }
              Images->'imageClassName'->States += Gui->Renderable 'currentStateName'+"State_"+'indexValue' = \Images.'imageName'.'creationMethod'(`args`)
              yArgumentLayers.get(realIndex / yArgumentLayerSize).add(|'currentStateName'+"State_"+'indexValue'|); 
              \declareFlipMethod(isFirst, imageClassName, 'atom->"animationId"'\+"_"\+realIndex, currentStateName\+"_"\+realIndex, parentStateName, |'currentStateName'+"State_"+'indexValue'|);
              realIndex \+= 1;
              isFirst = false;
            }
          }
          isFirst = false;
        }
    }
>   void declareFlipMethod(Boolean isFirst, String imageClassName, String singleStateName, String currentStateName, String parentStateName, Statement currentStateVariable){
      Statement firstOrDefaultMethod =   firstOrDefaultFlipMethods.get(imageClassName).get(currentStateName);
      if parentStateName.equals("") {
        Images->'imageClassName'->States += void 'currentStateName'(){
          \setCurrent(`currentStateVariable`);
          "state" = ImageStates->'currentStateName';
          "parentState" = ImageStates."DEFAULT";
        }
        animationStateAscendBodies.get(imageClassName).add(|
          case 'currentStateName' {
            `firstOrDefaultMethod`;
            return void;}|);
      }
      else {
        Images->'imageClassName'->States += void 'currentStateName'(){
            \setCurrent(`currentStateVariable`);
            "state" = ImageStates->'currentStateName';
            "parentState" = ImageStates->'parentStateName';
          }
        animationStateAscendBodies.get(imageClassName).add(|
          case 'currentStateName' {
            'parentStateName'();
            return void;}|);
      }
      if isFirst {
        Images->'imageClassName'->States->*.appendToBody({'currentStateName'();}); 
      }
      animationStateChangeBodies.get(imageClassName).get(parentStateName).add(|
        case 'singleStateName' {
          'currentStateName'();
          return void;}|);
          
    }
>   void declareTextureBuffer(String frameWidth, String frameHeight){
      Float width = Float.parseFloat(frameWidth);
      Float height = Float.parseFloat(frameHeight);
      Integer widthI = Integer.parseInt(frameWidth);
      Integer heightI = Integer.parseInt(frameHeight);
	  Float xFactor = 0.00f/width;
	  Float yFactor = 0.00f/height;
      String textureBufferMethodLoaderClassName = "TextureBuffer"\+'frameWidth'\+"x"\+'frameHeight'\+"Loader";
      String textureBufferMethodLoaderName = "loadTextureBuffer"\+'frameWidth'\+"x"\+'frameHeight'+"Loader";
      String textureBufferName = "textureBuffer"\+'frameWidth'\+"x"\+'frameHeight';
	  if declaredTextureBuffers.isEmpty() {
	    ImageLoader += Map<Integer,Map<Integer,'floatBufferArray'>> textureBuffers = new HashMap<Integer,Map<Integer,'floatBufferArray'>>()
      }
      ImageLoader->*"load".prependToBody({
	    'textureBufferMethodLoaderName'.start();
      });
      ImageLoader->*"load".appendToBody({
        try {
	      'textureBufferMethodLoaderName'.join();
	    }
	    print catch Interrupted {} 
      });
      ImageLoader += Thread 'textureBufferMethodLoaderName' = new ImageLoader->'textureBufferMethodLoaderClassName'()
      ImageLoader += ~class textureBufferMethodLoaderClassName / Thread / {
        void run(){
	      'floatBufferArray' textureBuffer = "new FloatBuffer["+'frameWidth'+"]["+'frameHeight'+"]";
	      ByteBuffer "byteBuffer" = null;
        }
      }
      for Integer x < widthI {
	    for Integer y < heightI {
		  String currentTextureBuffer = "textureBuffer["\+'x'\+"]["\+'y'\+"]";
		  StringBuilder floatArrayValues = new StringBuilder();
		  floatArrayValues.append("new float[]{");
		  floatArrayValues.append(x\/width\+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+1\/height\-yFactor);
		  floatArrayValues.append("f,");
	      floatArrayValues.append(x\/width\+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+1\/width-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+1\/height\-yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+1\/width\-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+yFactor);
		  floatArrayValues.append("f}"); 
		  ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
		    "byteBuffer" = ByteBuffer.allocateDirect(2*4*4);
            "byteBuffer".order(ByteOrder.nativeOrder());
		    'currentTextureBuffer' = \byteBuffer.asFloatBuffer();
		    'currentTextureBuffer'.put('floatArrayValues');
            'currentTextureBuffer'.position(0);
          });
  	    }
      }
      if declaredTextureBuffers.containsKey(frameWidth)==false {
        declaredTextureBuffers.put(frameWidth, new HashSet<String>());
        #ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
          synchronized "textureBuffers" {
            "textureBuffers".put('widthI', new HashMap<Integer,'floatBufferArray'>);
          }
        });#
      }
      declaredTextureBuffers.get(frameWidth).add(frameHeight);
	  #ImageLoader->'textureBufferMethodLoaderClassName'->*"run".appendToBody({
        synchronized "textureBuffers" {
	      "textureBuffers".get('widthI').put('heightI', "textureBuffer");
	    }
      });#
    }
  }
  class Colour // {
    Float getRedF(){ return null; }
    Float getGreenF(){ return null; }
    Float getBlueF(){ return null; }
    Integer getRedI(){ return null; }
    Integer getGreenI(){ return null; }
    Integer getBlueI(){ return null; }
    $'floatArrayType' asFloatArray(){return null;}
    $'intArrayType' asIntegerArray(){return null;}
    Integer getTexture(){
      return 0;
    }
    void render(){}
    void endRender(){}
>   void declaration(IToken input){
      String colourName = ^input->"colourName";
      Colours += class colourName / Gui->Colour / {
      }
      input : element : asInt {
        Integer redInt = Integer.parseInt('element->"red"');
        Integer greenInt = Integer.parseInt('element->"green"');
        Integer blueInt = Integer.parseInt('element->"blue"');
        Float redFloat = Float.parseFloat('element->"red"')/256f;
        Float greenFloat = Float.parseFloat('element->"green"')/256f;
        Float blueFloat = Float.parseFloat('element->"blue"')/256f;
        
        Colours->'colourName' += 'floatArrayType' asFloatArray(){return "new Float[]{"+'redFloat'+"f,"+'greenFloat'+"f,"+'blueFloat'+"f}";}
        Colours->'colourName' += 'intArrayType' asIntArray() {return "new Integer[]{"+'redInt'+","+'greenInt'+","+'blueInt'+"}"; }
        
        Colours->'colourName' += Integer getRedI(){return 'redInt';}
        Colours->'colourName' += Integer getGreenI() {return 'greenInt';}
        Colours->'colourName' += Integer getBlueI(){return 'blueInt';}
        Colours->'colourName' += Float getRedF() {return 'redFloat'+"f";}
        Colours->'colourName' += Float getGreenF() {return 'greenFloat'+"f";}
        Colours->'colourName' += Float getBlueF(){return 'blueFloat'+"f";}
        Colours->'colourName' += void render(){
          GL11.glDisable(GL11.GL_TEXTURE_2D);
		  GL11.glDisable(GL11.GL_LIGHTING);
		  GL11.glColor3f('redFloat'+"f", 'greenFloat'+"f", 'blueFloat'+"f");
		  GL11.glBegin(GL11.GL_TRIANGLE_STRIPS);
		}
		Colours->'colourName' += void endRender(){
		  GL11.glEnd();
		  GL11.glEnable(GL11.GL_TEXTURE_2D);
		  GL11.glEnable(GL11.GL_LIGHTING);
		}
      }
      : asFloat {
        Float redFloat = Float.parseFloat('element->"red"');
        Float greenFloat = Float.parseFloat('element->"green"');
        Float blueFloat = Float.parseFloat('element->"blue"');
        
        Float redIntValue = redFloat*256f;
        Float greenIntValue = greenFloat*256f;
        Float blueIntValue = blueFloat*256f;
        Integer redInt = redIntValue.intValue();
        Integer greenInt = greenIntValue.intValue();
        Integer blueInt = blueIntValue.intValue();
        
        Colours->'colourName' += 'floatArrayType' asFloatArray(){return "new Float[]{"+'redFloat'+"f,"+'greenFloat'+"f,"+'blueFloat'+"f}";}
        Colours->'colourName' += 'intArrayType' asIntArray() {return "new Integer[]{"+'redInt'+","+'greenInt'+","+'blueInt'+"}"; }
        
        Colours->'colourName' += Integer getRedI(){return 'redInt';}
        Colours->'colourName' += Integer getGreenI() {return 'greenInt';}
        Colours->'colourName' += Integer getBlueI(){return 'blueInt';}
        Colours->'colourName' += Float getRedF() {return 'redFloat'+"f";}
        Colours->'colourName' += Float getGreenF() {return 'greenFloat'+"f";}
        Colours->'colourName' += Float getBlueF(){return 'blueFloat'+"f";}
      }
    }
  }
  class Drawable // {
    ~FloatBuffer vertexBuffer = null;
    ~List<Gui\>Drawable\>ChangeListener> changeListeners = null;
    ~Float visualX = 0f;
    ~Float visualY = 0f;
    ~Float visualWidth = 1f;
    ~Float visualHeight = 1f;
    ~Float visualRotationPointX = 0f;
    ~Float visualRotationPointY = 0f;
    ~Float visualAngle = 0f;
    ~Float angle = 0f;
    
    ~Renderer->Layer displayLayer = null;
    void display(){
      if displayLayer == null {
        displayLayer = Renderer.botLayer;
        displayLayer.add(this);
      }
    }
    void display(Renderer->Layer layer){
      if displayLayer == null {
        displayLayer = layer;
        displayLayer.add(this);
      }
      else if displayLayer != layer {
        displayLayer.remove(this);
        displayLayer = layer;
        displayLayer.add(this);
      }
    }
    void render(){
      
		GL11.glPushMatrix();
		GL11.glTranslatef(visualX, visualY, 0.0f);
		if visualAngle != 0f{
			GL11.glTranslatef(visualRotationPointX, visualRotationPointY, 0.0f);
			GL11.glRotatef(visualAngle, 0, 0, 1);	
			GL11.glTranslatef(-1f*visualRotationPointX, -1f*visualRotationPointY, 0.0f);
		}
		GL11.glScalef(visualWidth, visualHeight, 1f);
		GL11.glVertexPointer(3, 0, vertexBuffer);
    }
    void animate(){
    }
    void load(){
    }
    Integer getTexture(){
      return 0;
    }
    Gui->Drawable image(Gui->Renderable image){
      return null;
    }
    Gui->Drawable colour(Gui->Colour colour){
      return null;
    }
    void add(Gui\>Drawable\>ChangeListener changeListener){
      if changeListeners == null {
        changeListeners = new ArrayList<Gui\>Drawable\>ChangeListener>();
      }
      changeListeners.add(changeListener);
    }
    class ChangeListener // {
      void setVisualX(Float newX){
      }
      void setVisualY(Float newY){
      }
      void setVisualWidth(Float newWidth){
      }
      void setVisualHeight(Float newHeight){
      }
      void setAngle(Float newAngle){
      }
    }
>   void setup(){
      Gui->Drawable->*"setVisualX".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualX("newVisualX");
          }
        }
      });
      Gui->Drawable->*"setVisualY".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualY("newVisualY");
          }
        }
      });
      Gui->Drawable->*"setVisualWidth".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualWidth("newVisualWidth");
          }
        }
      });
      Gui->Drawable->*"setVisualHeight".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setVisualHeight("newVisualHeight");
          }
        }
      });
      Gui->Drawable->*"setAngle".appendToBody({
        if changeListeners != null {
          for Gui->Drawable->ChangeListener changeListener : changeListeners {
            changeListener.setAngle("newAngle");
          }
        }
      });
      Gui->Drawable->*"setAngle".prependToBody({
        "visualAngle" = "(float)(newAngle" * 180.0 / "Math.PI)"; 
      });
    }
>   void declaration(IToken input){
      String drawableName = 'input->"drawableName"';
      String drawableClassName = ^input->"drawableName";
      Drawables += class drawableClassName / Gui->Drawable / {
        void load(){
        }
        Drawables->'drawableClassName' image(Gui->Renderable image){
          Drawables->'drawableClassName' newImage = new Drawables->'drawableClassName'->Image(image);
          newImage.setVertexBuffer("vertexBuffer");
          return newImage;
        }
        Drawables->'drawableClassName' colour(Gui->Colour colour){
          Drawables->'drawableClassName' newColour = new Drawables->'drawableClassName'->Colour(colour);
          newColour.setVertexBuffer("vertexBuffer");
          return newColour;
        }
      }
      Drawables += @Drawables->'drawableClassName' 'drawableName' = new Drawables->'drawableClassName'()  
      ImageLoader->*"load".prependToBody({ \Drawables.'drawableName'.load(); });
      
      StringBuilder vertexArray = new StringBuilder();
      ~Float gridWidth = -1f;
      ~Float gridHeight = -1f;
      ~Boolean buildingWidth = true;
      input : element : drawable_grid_element {
        if element->"endLine" != null {
          gridHeight \+= 1f;
          buildingWidth = false;
        }
        else if buildingWidth {
          gridWidth \+= 1f;
        }
      }
      ~Float gridX = 0f;
      ~Float gridY = 0f;
      ~Float gridAHeight = gridHeight - 1;
      ~Integer numberOfElements = 0;
      Map<Integer,Float> gridXMap = new HashMap<Integer,Float>();
      Map<Integer,Float> gridYMap = new HashMap<Integer,Float>();
      input : element : drawable_grid_element {
        if element->"point" != null {
          element : atom : point {
            gridXMap.put(Integer.parseInt('atom'), gridX / gridWidth );
            gridYMap.put(Integer.parseInt('atom'), 1f \- gridY / gridAHeight );
          }
          numberOfElements \+= 1;
        }
        if element->"endLine" != null {
          gridY \+= 1f;
          gridX = 0f;
        }
        else {
          gridX \+= 1f;
        }
      }
      vertexArray.append("float[] vertices = new float[]{");
      ~String comma = "";
      for Integer i < numberOfElements {
        vertexArray.append(comma);
        vertexArray.append(gridXMap.get(i\+1));
        vertexArray.append("f,");
        vertexArray.append(gridYMap.get(i\+1));
        vertexArray.append("f,0f");
        comma = ",";
      }
      vertexArray.append("}");
      Integer sizeOfByteBuffer = numberOfElements * 4 * 3;
      Drawables->'drawableClassName'->*"load".appendToBody({
        'vertexArray';
		ByteBuffer byteBuffer = ByteBuffer.allocateDirect('sizeOfByteBuffer');
		byteBuffer.order(ByteOrder.nativeOrder());
		"vertexBuffer" = byteBuffer.asFloatBuffer();
		"vertexBuffer".clear();
		"vertexBuffer".put("vertices");
		"vertexBuffer".position(0);
      });
      Integer numberOfElementsValue = numberOfElements;
      Drawables->'drawableClassName' += class Image / 'drawableClassName' / {
        Gui->Renderable image = null;
        void render(){
          image.render();
          \super.render();
          GL11.glDrawArrays(GL11.GL_TRIANGLE_STRIP, 0, 'numberOfElementsValue');
		  GL11.glPopMatrix();
        }
        void animate(){
          image.animate();
        }
        Integer getTexture(){
          return image.getTexture();
        }
      }
      Drawables->'drawableClassName' += class Colour / 'drawableClassName' / {
        Gui->Colour colour = null;
        void render(){
          colour.render();
        }
        Integer getTexture(){
          return colour.getTexture();
        }
      }
      Drawables->'drawableClassName'->Colour->*"render".appendToBody({
        colour.endRender();
      });
    }
>   void multipleDeclaration(IToken input){
      String multipleName = 'input->"multipleName"';
      String multipleClassName = ^multipleName;
      Drawables += class multipleClassName / Gui->Drawable / {
        void load(){
        }
        void render(){
        }
        void animate(){
        }
        Drawables->'multipleClassName' image(Gui->Renderable image){
        }
      }
      Drawables += @Drawables->'multipleClassName' 'multipleName' = new Drawables->'multipleClassName'() 
      Drawables->'multipleClassName' += class Image / 'multipleClassName' / {
        Integer imageTexture = -1;
        void render(){
        }
        void animate(){
        }
        Integer getTexture(){
          return imageTexture;
        }
      }
      ~Integer imageIndex = 1;
      Parameters imageParameters = new Parameters ();
      imageParameters.add(|"image".getTexture()|);
      input : element : drawable_multiple_element {
        String imageName = "image"\+imageIndex;
        String drawableName = 'element->"drawableName"';
        if element->"newStateName" != null {
          Drawables->'multipleClassName'->*"image".appendToBody({
            Gui->Image->States 'imageName' = "((Gui.Statable)image).asStates()";
          });
          element : atom : newStateName {
            Drawables->'multipleClassName'->*"image".appendToBody({
              'imageName'.changeState( "Gui.Image.States."+'atom' );
            });
          }
          imageParameters.add(|\Drawables.'drawableName'.image('imageName')|);
        }
        else {
          imageParameters.add(|\Drawables.'drawableName'.image("image")|);
        }
        String changeListenerClassName = ^imageName \+ "ChangeListener";
        Drawables->'multipleClassName'->Image += ~class changeListenerClassName / Gui->Drawable->ChangeListener / { 
          void setVisualX(Float newX){
          }
          void setVisualY(Float newY){
          }
          void setVisualWidth(Float newWidth){
          }
          void setVisualHeight(Float newHeight){
          }
          void setAngle(Float newAngle){
          }
        }
        \addChangeListener(element->"angle",Drawables->'multipleClassName'->Image,imageName,NORMAL, "setAngle");
        \addChangeListener(element->"position",Drawables->'multipleClassName'->Image,imageName,"setVisualX","setVisualY");
        \addChangeListener(element->"dimensions",Drawables->'multipleClassName'->Image,imageName,"setVisualWidth","setVisualHeight");
        if element->"rotation" != null {
          \addChangeListener(element->"rotation",Drawables->'multipleClassName'->Image,imageName,"setVisualRotationPointX","setVisualRotationPointY");
        }
        
        Drawables->'multipleClassName'->Image += Gui->Drawable 'imageName' = null
        Drawables->'multipleClassName'->Image->*"render".appendToBody({'imageName'.render();});
        Drawables->'multipleClassName'->Image->*"animate".appendToBody({'imageName'.animate();});
        
        Drawables->'multipleClassName'->Image->*.appendToBody({\add(new Drawables->'multipleClassName'->Image->'changeListenerClassName'());});
        imageIndex \+= 1;
      }
      Drawables->'multipleClassName'->Image->*.appendToBody({
        if changeListeners != null {
        for Gui->Drawable->ChangeListener changeListener : changeListeners {
		  "changeListener".setVisualX(0f);
		  "changeListener".setVisualY(0f);
		  "changeListener".setVisualWidth(1f);
		  "changeListener".setVisualHeight(1f);
		  "changeListener".setAngle(0f);
		}
		}
      });
      Drawables->'multipleClassName'->*"image".appendToBody({
        return new Drawables->'multipleClassName'->Image(`imageParameters`);
      });
    }
>   Integer LEFT_SUPPLEMENTARY = 1;
>   Integer RIGHT_SUPPLEMENTARY = 2;
>   Integer NORMAL = 3;
>   Statement getMultipleValue(IToken input, Integer status){
      ~Statement result = null;
      if input->"DRAWABLE_ANGLE" != null {
        if status == LEFT_SUPPLEMENTARY {
          return |\Math.cos(\getAngle())|;
        }
        else if status == RIGHT_SUPPLEMENTARY {
          return |\Math.sin(\getAngle())|;
        }
        else if status == NORMAL {
          return |\getAngle()|;
        }
      }
      else if input->"DRAWABLE_X" != null {
        return |\getVisualX()|;
      }
      else if input->"DRAWABLE_Y" != null {
        return |\getVisualY()|;
      }
      else if input->"DRAWABLE_WIDTH" != null {
        return |\getVisualWidth()|;
      }
      else if input->"DRAWABLE_HEIGHT" != null {
        return |\getVisualHeight()|;
      }
      else if input->"FLOAT" != null {
        return |'input->"FLOAT"'+"f"|;
      }
      else if input->"INTEGER" != null {
        return |'input->"INTEGER"'|;
      }
      \System.err.println("Drawable.getMultipleValue() could not parse:");
      input.print();
      return null;
    }
        
>   void addChangeListener(IToken input, Class masterClass, String drawableToChange, String leftParameterSetMethod, String rightParameterSetMethod){
      \addChangeListener(input->"leftParameter",masterClass,drawableToChange, LEFT_SUPPLEMENTARY, leftParameterSetMethod);
      \addChangeListener(input->"rightParameter",masterClass,drawableToChange, RIGHT_SUPPLEMENTARY, rightParameterSetMethod);
    }
>   void addChangeListener(IToken input, Class masterClass, String drawableToChange, Integer status, String setMethod){
      String changeListenerClassName = ^drawableToChange \+ "ChangeListener";
      Statement statement = new Statement ();
      Set<String> toChangeMethods = new HashSet<String>();
      input : element : drawable_multiple_value {
        statement.add(\getMultipleValue(element,status));
        if element->"DRAWABLE_WIDTH" != null {
          toChangeMethods.add("setVisualWidth");
        }
        else if element->"DRAWABLE_HEIGHT" != null {
          toChangeMethods.add("setVisualHeight");
        }
        else if element->"DRAWABLE_X" != null {
          toChangeMethods.add("setVisualX");
        }
        else if element->"DRAWABLE_Y" != null {
          toChangeMethods.add("setVisualY");
        }
        else if element->"DRAWABLE_ANGLE" != null {
          toChangeMethods.add("setAngle");
        }
      }
      : drawable_arthmetic_operator {
        statement.set('element');
      }
      input : element : supplementary {
        element : atom : drawable_multiple_value {
          statement.add(\getMultipleValue(atom,status));
          if atom->"DRAWABLE_WIDTH" != null {
            toChangeMethods.add("setVisualWidth");
          }
          else if atom->"DRAWABLE_HEIGHT" != null {
            toChangeMethods.add("setVisualHeight");
          }
          else if atom->"DRAWABLE_X" != null {
            toChangeMethods.add("setVisualX");
          }
          else if atom->"DRAWABLE_Y" != null {
            toChangeMethods.add("setVisualY");
          }
          else if atom->"DRAWABLE_ANGLE" != null {
            toChangeMethods.add("setAngle");
          }
        }
        : drawable_arthmetic_operator {
          statement.set('atom');
        }
      }
      for String changeMethod : toChangeMethods {
        masterClass->'changeListenerClassName'->*'changeMethod'.appendToBody({
          'drawableToChange'.'setMethod'("(float)("+`statement`+")");
        });
      }
    }
  }
> void setup(){
    Gui->Drawable.setup();
  }
> void importAny(IToken import_any){
	import_any : import_colours : IMPORT_COLOUR {
      import_colours : element : colour_declaration {
		Gui->Colour.declaration(element);
	  }
	}
	import_any : import_animation_types : IMPORT_ANIMATION_TYPE {
	  import_animation_types : element : animation_type_declaration {
		ImageLoader.declaration(element,Gui->Image->AnimationType);
	  }
	}
	import_any : import_images : IMPORT_IMAGE {
	  import_images : element : image_declaration {
		Gui->Image.declaration(element);
	  }
	}
	import_any : import_draws : IMPORT_DRAWABLE {
	  import_draws : element : drawable_declaration {
		Gui->Drawable.declaration(element);
	  }
	  import_draws : element : multiple_drawable_declaration {
		Gui->Drawable.multipleDeclaration(element);
	  }
	}
	import_any : import_layers : IMPORT_LAYER {
	  import_layers : element : layer_declaration {
		Renderer.addLayer('element->"layerName"');
	  }
	}
  }
}
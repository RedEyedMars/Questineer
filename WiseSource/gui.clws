import headers.clws
import gui/renderer.clws

> void assignListElementNames(ParseContext context, IToken root){
  }
> String getDirectory(String fileName, String knownDirectory){
	return "../Resource/";
  }
> void setup(ParseContext data){
  }
> void generate(ParseContext data){
	\setup("../Questineer/src");
	IToken root = data.getRoot();
	root : imports : import_any {
		Gui.importAny(imports);
	}
	\output(data);
  }
 
< BufferedImage : \java.\awt.\image;
< ImageIO : \javax.\imageio;
< ByteBuffer : \java.\nio;
< ByteOrder : \java.\nio;
< FloatBuffer : \java.\nio;
< GL11        : \org.\lwjgl.\opengl;
< GLU        : \org.\lwjgl.\util.\glu;
class 'packageName'."gui"."images" ImageLoader {
> Map<Class , Parameters > animationCreationParameters = new HashMap< Class , Parameters >();
> Map<Class , Parameters > animationCreationArguments = new HashMap< Class , Parameters >();
  FloatBuffer placeHolder = null;
  void load(){
    \loadTextureBuffers();
  }
  void loadTextureBuffers(){}
>   void declaration(IToken input, Class enclosingClass){
      String animationTypeName = ^input->"animationTypeName";
      if enclosingClass == Gui->Image->Crop->AnimationType {
        enclosingClass += ~class animationTypeName / Gui->Image->Crop->AnimationType/{
          void animate(){ }
        }
      }
      else {
        enclosingClass += ~class animationTypeName /Gui->Image->Crop->AnimationType/{
          void animate(){ }
        }
      }
      Parameters parameters = new Parameters ();
      Parameters arguments = new Parameters ();
      input : variable : animation_type_variable_declaration {
        variable : element : value {
          arguments.add(|'variable->"variableName"'|);
          element : value : INTEGER {
            enclosingClass->'animationTypeName' += Integer 'variable->"variableName"' = 'value'
            parameters.add(Integer 'variable->"variableName"' = 'value';);
          }
          variable : value : FLOAT {
            enclosingClass->'animationTypeName' += Float 'variable->"variableName"' = 'value'+"f"
            parameters.add(Integer 'variable->"variableName"' = 'value';);
          }
          variable : value : quote {
            enclosingClass->'animationTypeName' += String 'variable->"variableName"' = ''value''
            parameters.add(Integer 'variable->"variableName"' = 'value';);
          }
        }
      }
      animationCreationParameters.put(enclosingClass->'animationTypeName' , parameters);
      animationCreationArguments.put(enclosingClass->'animationTypeName' , arguments);
      ~Class creationClass = enclosingClass->'animationTypeName';
      ~String creationName = "";
      Parameters previousParameters = new Parameters ();
      Parameters previousArguments = new Parameters ();
      ~String previousCreationName = null;
      while creationClass.getEnclosingClass() != Gui->Image->Crop->AnimationType {
        creationName = 'creationClass.getName()'\+ creationName;
        String createMethodName = "create"\+'creationName';
        Class upperClass = creationClass.getEnclosingClass();
        Parameters realParameters = new Parameters ();
        realParameters.addAll(animationCreationParameters.get(creationClass));
        realParameters.addAll(previousParameters);
        Statement creation = new Statement ();
        creation.add(|new creationClass(`animationCreationArguments.get(creationClass)`)|);
        if previousCreationName != null {
          creation.set(".");
          String currentPreviousCreationName = previousCreationName;
          Parameters currentPreviousArguements = new Parameters();
          currentPreviousArguements.addAll(previousArguments);
          creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
        }
        previousCreationName = createMethodName;
        upperClass += enclosingClass->'animationTypeName' 'createMethodName' `realParameters` {
          return `creation`;
        }
        previousParameters.addAll(animationCreationParameters.get(creationClass));
        previousArguments.addAll(animationCreationArguments.get(creationClass));
        creationClass = upperClass;
      }
      creationName = 'creationClass.getName()'\+ creationName;
      String createMethodName = "create"\+'creationName';
      Parameters realParameters = new Parameters ();
      realParameters.addAll(animationCreationParameters.get(creationClass));
      realParameters.addAll(previousParameters);
      Statement creation = new Statement ();
      creation.add(|new creationClass(`animationCreationArguments.get(creationClass)`)|);
      if previousCreationName != null {
        creation.set(".");
        String currentPreviousCreationName = previousCreationName;
        Parameters currentPreviousArguements = new Parameters();
        currentPreviousArguements.addAll(previousArguments);
        creation.add(|'currentPreviousCreationName'(`currentPreviousArguements`)|);
      }
      Gui->Image->Crop->AnimationType += enclosingClass->'animationTypeName' 'createMethodName' `realParameters` {
        return `creation`;
      }
      input : element : animation_type_element {
        element : atom : animation_type_declaration {
          ImageLoader.declaration(atom,enclosingClass->'animationTypeName');
        }
        element : atom : statement {
          Statement statement = new Statement ();
          statement.add(|'atom->"variableName"'|);
          statement.set('atom->"operator"');
          statement.add(|'atom->"value"'|);
          if atom->"animation_type_boolean" != null {
            Statement header = new Statement ();
            atom : quark : animation_type_boolean {
              Statement headerElement = new Statement();
              headerElement.add(|'quark->"leftName"'|);
              headerElement.set('quark->"boolean_operator"');
              quark : energy : value {
                energy : quanta : INTEGER {
                  headerElement.add(|'quanta'|);
                }
                : FLOAT {
                  headerElement.add(|'quanta'+"f"|);
                }
                : NAME {
                  headerElement.add(|'quanta'|);
                }
                : frameName {
                  String methodName = "get" \+ ^quanta;
                  headerElement.add(|"frames".'methodName'()|);
                }
              }
              header.add(headerElement);
            }
            : continuation_operator {
              if 'quark' == "&" {
                header.set("&&");
              }
              else if 'quark' == "|" {
                header.set("||");
              }
            }
            enclosingClass->'animationTypeName'->*"animate".appendToBody({if `header` {`statement`;}});
          }
          else {
            enclosingClass->'animationTypeName'->*"animate".appendToBody({`statement`;});
          }
        }
      }
    }
}
class 'packageName'."gui" Gui {
> String floatArrayType = "Float[]";
> String intArrayType = "Integer[]";
> String floatBufferArray = "FloatBuffer[][]";
  FloatBuffer placeHolder = null;
  class Image // {
    String imageFileName = null;
    Gui->Image->Dimensions pixels = null;
    Gui->Image->Dimensions frames = null;
    ~Integer texture = -1;
    ~'floatBufferArray' textureBuffer = null;
    void render(){
      GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
	  GL11.glTexCoordPointer(2, 0, "textureBuffer[0][0]");
    }
    class Dimensions // {
      Integer width = -1;
      Integer height = -1;
    }
    Gui->Image->Crop getCrop(Integer frameX, Integer frameY){
      return new Crop(frameX, frameY);
    }
    ~class Crop // {
      Integer frameX = 0;
      Integer frameY = 0;
      void render(){
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
	    GL11.glTexCoordPointer(2, 0, "textureBuffer[frameX][frameY]");
      }
      void setFrameX(Integer newX){ frameX = newX; }
      void setFrameY(Integer newY){ frameY = newY; }
      ~class AnimationType / / {
    	Integer x = 0;
    	Integer y = 0;
    	void animate(){ }
    	void tick(Double millisSinceLastFrame){
      	  \animate();
          \setFrameX(x);
          \setFrameY(y);
        }
      }
    }
>   Map<String,Set<String>> declaredTextureBuffers = new HashMap<String,Set<String>>();
>   void declaration(IToken input){
	  try {
        String imageName = 'input->"imageName"';
        String imageFileName = "../Resource/gui/images/"\+'input->"image_file_name"'\+"."\+'input->"image_type"';
        BufferedImage bimg = ImageIO.read(new File(imageFileName));
        Integer pWidth = bimg.getWidth();
        Integer pHeight = bimg.getHeight();
        Gui->Images += @Gui->Image 'imageName' = new Gui->Image(''imageFileName'',new Gui->Image->Dimensions('pWidth','pHeight'),new Gui->Image->Dimensions('input->"frameWidth"','input->"frameHeight"'))
        if declaredTextureBuffers.containsKey('input->"frameWidth"')==false || declaredTextureBuffers.get('input->"frameWidth"').contains('input->"frameHeight"')==false {
          \declareTextureBuffer('input->"frameWidth"','input->"frameHeight"');
        }
        
	    ImageLoader->*"loadTextureBuffers".appendToBody({
          Gui->Images->'imageName'.setTextureBuffer("textureBuffer"+'input->"frameWidth"'+"x"+'input->"frameHeight"');
        });
      }
      print catch  IO {}
    }
>   void declareTextureBuffer(String frameWidth, String frameHeight){
      Float width = Float.parseFloat(frameWidth);
      Float height = Float.parseFloat(frameHeight);
      Integer widthI = Integer.parseInt(frameWidth);
      Integer heightI = Integer.parseInt(frameHeight);
	  Float xFactor = 0.02f/width;
	  Float yFactor = 0.02f/height;
      String textureBufferMethodName = "loadTextureBuffer"\+'frameWidth'\+"x"\+'frameHeight';
      String textureBufferName = "textureBuffer"\+'frameWidth'\+"x"\+'frameHeight';
	  if declaredTextureBuffers.isEmpty() {
	    ImageLoader += Map<Integer,Map<Integer,'floatBufferArray'>> textureBuffers = new HashMap<Integer,Map<Integer,'floatBufferArray'>>()
	    ImageLoader->*"loadTextureBuffers".appendToBody({
	      'floatBufferArray' 'textureBufferName' = 'textureBufferMethodName'();
		});
      }
      ImageLoader += 'floatBufferArray' 'textureBufferMethodName'(){
		'floatBufferArray' textureBuffer = "new FloatBuffer["+'frameWidth'+"]["+'frameHeight'+"]";
		ByteBuffer "byteBuffer" = null;
	  }
      for Integer x < widthI {
		for Integer y < heightI {
		  String currentTextureBuffer = "textureBuffer["\+'x'\+"]["\+'y'\+"]";
		  StringBuilder floatArrayValues = new StringBuilder();
		  floatArrayValues.append("new float[]{");
		  floatArrayValues.append(x\/width\+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+1\/height\-yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+1\/width-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+1\/height\-yFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(x\/width\+1\/width\-xFactor);
		  floatArrayValues.append("f,");
		  floatArrayValues.append(y\/height\+yFactor);
		  floatArrayValues.append("f}"); 
		  ImageLoader->*'textureBufferMethodName'.appendToBody({
		    "byteBuffer" = ByteBuffer.allocateDirect(2*4*4);
		    "byteBuffer".order(ByteOrder.nativeOrder());
		    'currentTextureBuffer' = \byteBuffer.asFloatBuffer();
		    'currentTextureBuffer'.put('floatArrayValues');
		    'currentTextureBuffer'.position(0);
		  });
 		}
      }
      if declaredTextureBuffers.containsKey(frameWidth)==false {
        declaredTextureBuffers.put(frameWidth, new HashSet<String>());
        ImageLoader->*'textureBufferMethodName'.appendToBody({
          "textureBuffers".put('widthI', new HashMap<Integer,'floatBufferArray'>);
        });
      }
      declaredTextureBuffers.get(frameWidth).add(frameHeight);
	  ImageLoader->*'textureBufferMethodName'.appendToBody({
		"textureBuffers".get('widthI').put('heightI', "textureBuffer");
		return "textureBuffer";
      });
      
      
    }
  }
  class Images //{}
  
  class Colours // {
  }
  class Colour // {
    Float getRedF(){ return null; }
    Float getGreenF(){ return null; }
    Float getBlueF(){ return null; }
    Integer getRedI(){ return null; }
    Integer getGreenI(){ return null; }
    Integer getBlueI(){ return null; }
    $'floatArrayType' asFloatArray(){return null;}
    $'intArrayType' asIntegerArray(){return null;}
>   void declaration(IToken input){
      String colourName = ^input->"colourName";
      Gui->Colours += class colourName / Gui->Colour / {
      }
      input : element : asInt {
        Integer redInt = Integer.parseInt('element->"red"');
        Integer greenInt = Integer.parseInt('element->"green"');
        Integer blueInt = Integer.parseInt('element->"blue"');
        Float redFloat = Float.parseFloat('element->"red"')/256f;
        Float greenFloat = Float.parseFloat('element->"green"')/256f;
        Float blueFloat = Float.parseFloat('element->"blue"')/256f;
        
        Gui->Colours->'colourName' += 'floatArrayType' asFloatArray(){return "new Float[]{"+'redFloat'+"f,"+'greenFloat'+"f,"+'blueFloat'+"f}";}
        Gui->Colours->'colourName' += 'intArrayType' asIntArray() {return "new Integer[]{"+'redInt'+","+'greenInt'+","+'blueInt'+"}"; }
        
        Gui->Colours->'colourName' += Integer getRedI(){return 'redInt';}
        Gui->Colours->'colourName' += Integer getGreenI() {return 'greenInt';}
        Gui->Colours->'colourName' += Integer getBlueI(){return 'blueInt';}
        Gui->Colours->'colourName' += Float getRedF() {return 'redFloat'+"f";}
        Gui->Colours->'colourName' += Float getGreenF() {return 'greenFloat'+"f";}
        Gui->Colours->'colourName' += Float getBlueF(){return 'blueFloat'+"f";}
      }
      : asFloat {
        Float redFloat = Float.parseFloat('element->"red"');
        Float greenFloat = Float.parseFloat('element->"green"');
        Float blueFloat = Float.parseFloat('element->"blue"');
        
        Float redIntValue = redFloat*256f;
        Float greenIntValue = greenFloat*256f;
        Float blueIntValue = blueFloat*256f;
        Integer redInt = redIntValue.intValue();
        Integer greenInt = greenIntValue.intValue();
        Integer blueInt = blueIntValue.intValue();
        
        Gui->Colours->'colourName' += 'floatArrayType' asFloatArray(){return "new Float[]{"+'redFloat'+"f,"+'greenFloat'+"f,"+'blueFloat'+"f}";}
        Gui->Colours->'colourName' += 'intArrayType' asIntArray() {return "new Integer[]{"+'redInt'+","+'greenInt'+","+'blueInt'+"}"; }
        
        Gui->Colours->'colourName' += Integer getRedI(){return 'redInt';}
        Gui->Colours->'colourName' += Integer getGreenI() {return 'greenInt';}
        Gui->Colours->'colourName' += Integer getBlueI(){return 'blueInt';}
        Gui->Colours->'colourName' += Float getRedF() {return 'redFloat'+"f";}
        Gui->Colours->'colourName' += Float getGreenF() {return 'greenFloat'+"f";}
        Gui->Colours->'colourName' += Float getBlueF(){return 'blueFloat'+"f";}
      }
    }
  }
  class Drawable // {
    void draw(){
    }
>   void declaration(IToken input){
      String drawableName = ^input->"drawableName";
      Gui->Drawable += class drawableName / Drawable / {
      }
      Gui->Drawable->'drawableName' += class Image / 'drawableName' / {
        Gui->Image->Crop image = \Gui.\Images.'input->"imageName"'.getCrop(0,0);
        void render(){
          image.render();
        }
      }
      Gui->Drawable->'drawableName' += class Colour / 'drawableName' / {
        Colour colour;
      }
    }
  }
  @Boolean isRunning = true;
> void importAny(IToken import_any){
	import_any : import_colours : IMPORT_COLOUR {
      import_colours : element : colour_declaration {
		Colour.declaration(element);
	  }
	}
	import_any : import_animation_types : IMPORT_ANIMATION_TYPE {
	  import_animation_types : element : animation_type_declaration {
		ImageLoader.declaration(element,Gui->Image->Crop->AnimationType);
	  }
	}
	import_any : import_images : IMPORT_IMAGE {
	  import_images : element : image_declaration {
		Image.declaration(element);
	  }
	}
  }
}
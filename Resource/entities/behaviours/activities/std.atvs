attacking(Float range) Attack
	Attack target;;
supporting Support
	Keep everyone safe;;
questing Quest
	Go to certain places, do certain things, and reap their rewards;;
	+ Quest currentQuest = null
	succeed if currentQuest!=null & currentQuest->status == Quest=>SUCCESS
	fail if failed | currentQuest!=null & currentQuest->status == Quest=>FAIL
	step {
	  if currentQuest == null {
	    currentQuest = Quest<-(pick())
	    if currentQuest == null {
	      return false
	    }
	  }
	  return currentQuest.use(host,null)
	  
	}
hunt(Criteria.Target criteriaToTarget, Tile.Id huntingGrounds, Float range, Events.Die.Listener deathListener, ActivityCriteria toSucceed) Attack
	Hunt monsters until told otherwise.;;
	+ Area.List toHuntLocations
	+ Area.List huntedLocations
	+ Area      toHunt
	succeed if toSucceed.satisfies(this)
	load {
	  Area.List toAdd = event->host->location.getAreasWithTile(huntingGrounds, range)
	  toAdd.sort(new Area.Comparators.Distance.Ascending(event->host->location))
	  toHuntLocations.addAll(toAdd)
	  if !toHuntLocations.isEmpty() {
	    toHunt = toHuntLocations.remove(0)
	  }
	}
	step {
	  if host->location->area != toHunt {
	    host.start(new Activities.GotoArea(toHunt))
	  }
	  else {
	    Entity.List entitiesToTarget = host->location.getEntitiesWithin(50.0,criteriaToTarget)
	    if !entitiesToTarget.isEmpty() {
	      entitiesToTarget.sort(new Entity.Comparators.Distance.Ascending(host->location))
	      host.start(new Activities.Kill(entitiesToTarget.get(0)))
	    }
	    else {
	      Tiles.MonsterDen tileToKill = toHunt.getMonsterDen(huntingGrounds)
	      if tileToKill != null {
	        host.start(new Activities.KillDen(tileToKill))
	      }
	      else if !toHuntLocations.isEmpty() {
	        huntedLocations.add(toHunt)
  	        toHunt = toHuntLocations.remove(0)
	      }
	      else {
	        Area.List toAdd = host->location.getAreasWithTile(huntingGrounds, range)
	        toAdd.removeAll(huntedLocations)
	        if !toAdd.isEmpty() {
	          toAdd.sort(new Area.Comparators.Distance.Ascending(host->location))
	          toHuntLocations.addAll(toAdd)
	          step(host)
	        }
	        else {
	          failed = true
	          return false
	        }
	      }
	    }
	    else {
	      failed = true
	      return false
	    }
	  }
	  return true
	}
kill(Entity toKill) Attack
	Go kill one particular monster.;;
	+ Activity chaseActivity = null
	succeed if toKill.isDead()
	load {
	  setTargetEntity(toKill)
	  on(new Events.Idle(event->host,this))
	}
	listen {
	}
	idle {
	  Float longestRange = -1.0
	  for Usable usable : getUsables() {
	    Float potentialRange = usable.getRange(event->host)
	    if usable.getTargetCriteria().satisfies(toKill) {
	      if potentialRange > longestRange {
	        longestRange = potentialRange
	      }
	    }
	  }
	  if longestRange >= 0 {
	    chaseActivity = new Activities.ChasingEntity(25,toKill,longestRange)
	    event->host.start(chaseActivity)
	  }
	}
killDen(Tiles.MonsterDen toKill) Attack
	Go kill one particular monster den.;;
	+ Activity chaseActivity = null
	succeed if toKill.isDead()
	load {
	  setTargetDen(toKill)
	  Float longestRange = -1.0
	  for Usable usable : getUsables() {
	    Float potentialRange = usable.getRange(event->host)
	    if usable.getTargetCriteria().satisfies(toKill) {
	      if potentialRange > longestRange {
	        longestRange = potentialRange
	      }
	    }
	  }
	  if longestRange >= 0 {
	    chaseActivity = new Activities.ChasingTile(25,toKill,longestRange)
	    event->host.start(chaseActivity)
	  }
	}

chasingEntity(Integer ticks, Entity toChase, Float successRange)
	Get close to one monster(disregard the path).;;
	succeed if host->location.getDistanceTo(toChase->location) <= successRange
	fail if ticks <= 0
	tick { ticks -= 1 }
	step {
	  host->location.step(host->walkingSpeed,toChase->location)
	  return true
	}
chasingTile(Integer ticks, Tile toChase, Float successRange)
	Get close to one particular tile (disregard the path).;;
	succeed if host->location.getDistanceTo(toChase) <= successRange
	fail if ticks <= 0
	tick { ticks -= 1 }
	step { 
	  host->location.step(host->walkingSpeed,toChase)
	  return true
	}
goto(Tiles.Floor destination)
	Find a particular tile, follow path to get to it.;;
	succeed if host->location.isCloseAsPossibleTo(destination)
	+ Area destinationArea = null
	+ Tiles.Floor.Way way = null
	load {
	  destinationArea = destination->area
	}
	step {
	  if host->location->area != destinationArea {
	    host.start(new Activities.GotoArea(destinationArea))
	  }
	  else {
	    if way == null {
	      way = host->location.getWay(destination)
	    }
	    way.step(host)
	  }
	  return true
	}
gotoArea(Area destination)
	Find a particular tile, follow path to get to it.;;
	succeed if host->location.getArea() == destination
	step {
	  if host->location->area != destination {
	    host.start(new Activities.Goto(host->location->area.getEntryPointToward(destination)))
	  }
	  return true
	}
Exploring(Integer ticks)
	Go to unexplored parts of the map.;;
	+ Tiles.Floor destination = null
	+ Tiles.Floor.Way way = null
	succeed if ticks <=0
	load {
	  destination = event->host->location.getUnexploredPoint()
	  way = event->host->location.getWay(destination)
	}
	idle {
	  destination = event->host->location.getUnexploredPoint()
	  if destination != null {
	    way = event->host->location.getWay(destination)
	  }
	  else {
	    failed = true
	  }
	}
	step {
	  ticks -= 1
	  if destination.hasOccupant(host) {
	    return false
	  }
	  else { 
	    way.step(host)
	    return true
	  }
	}
	listen {
	  if event.getId() == Entity.Event.FailedToMove.TileHasOccupant=>id {
	    
	    Entity.Event.FailedToMove.TileHasOccupant blocked = Entity.Event.FailedToMove.TileHasOccupant<-event
	  }
	}
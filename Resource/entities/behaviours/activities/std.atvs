attacking(Float range) Attack
	Attack target;;
supporting Support
	Keep everyone safe;;
questing Quest
	Go to certain places, do certain things, and reap their rewards;;
	+ Quest currentQuest = null
	succeed if currentQuest!=null & currentQuest->status == Quest=>SUCCESS
	fail if failed | currentQuest!=null & currentQuest->status == Quest=>FAIL
	step {
	  if currentQuest == null {
	    currentQuest = Quest<-(pick())
	    if currentQuest == null {
	      return false
	    }
	  }
	  return currentQuest.use(host,null)
	  
	}
hunt(EntityCriteria criteriaToTarget, Tile.Id huntingGrounds, Float range, Events.Die.Listener deathListener, ActivityCriteria toSucceed) Attack
	Hunt monsters until told otherwise.;;
	+ Area.List toHuntLocations
	+ Area.List huntedLocations
	+ Area      toHunt
	succeed if toSucceed.satisfies(this)
	load {
	  Area.List toAdd = event->host->location.getAreasWithTile(huntingGrounds, range)
	  toAdd.sort(new Area.Comparators.Distance.Ascending(event->host->location))
	  toHuntLocations.addAll(toAdd)
	  if !toHuntLocations.isEmpty() {
	    toHunt = toHuntLocations.remove(0)
	  }
	}
	step {
	  if host->location->area != toHunt {
	    host.add(0,new Activities.GoToArea(toHunt))
	  }
	  else {
	    EntityList entitiesToTarget = host->location.getEntities(criteriaToTarget)
	    Entities.sort(entitiesToTarget,new Entities.Comparators.AscendingDistance(host->location))
	    if !entitiesToTarget.isEmpty() {
	      host.add(0,new Activities.Kill(entitiesToTarget.get(0)))
	    }
	    else {
	      Tile tileToKill = toHunt.getTile(huntingGrounds)
	      if tileToKill != null {
	        host.add(0,new Activities.KillTile(entitiesToTarget.get(0)))
	      }
	      else if !toHuntLocations.isEmpty() {
	        huntedLocations.add(toHunt)
  	        toHunt = toHuntLocations.remove(0)
	      }
	      else {
	        Area.List toAdd = event->host->location.getAreasWithTile(huntingGrounds, range)
	        toAdd.removeAll(huntedLocations)
	        if !toAdd.isEmpty() {
	          toAdd.sort(new Area.Comparators.Distance.Ascending(event->host->location))
	          toHuntLocations.addAll(toAdd)
	          on(event)
	        }
	        else {
	         failed = true
	        }
	      }
	    }
	    else {
	      failed = true
	    }
	  }
	}
kill(Entity toKill) Attack
	Go kill one particular monster.;;
	+ Activity chaseActivity = null
	succeed if toKill.isDead()
	load {
	  setTargetEntity(toKill)
	  on(new Events.Idle(event->host,this))
	}
	listen {
	  if event.getId() == Events.Fail=>id & (Events.Collect<-event)->failed == chaseActivity {
	    failed = true
	  }
	}
	idle {
	  Float longestRange = -1.0
	  for Usable usable : getUsables() {
	    Float potentialRange = usable.getRange(event->host)
	    if usable.getTargetCriteria().satisfies(toKill) {
	      if potentialRange > longestRange {
	        longestRange = potentialRange
	      }
	    }
	  }
	  if longestRange >= 0 {
	    chaseActivity = new Activities.ChasingEntity(25,toKill,longestRange)
	    event->host.start(chaseActivity)
	  }
	}

chasingEntity(Integer ticks, Entity toChase, Float successRange)
	Get close to one monster(disregard the path).;;
	succeed if host->location.getDistanceTo(toChase->location) <= successRange
	fail if ticks <= 0
	tick { ticks -= 1 }
	step {
	  event->host->location.step(event->host->walkingSpeed,toChase->location)
	  return true
	}
chasingTile(Integer ticks, Tile toChase, Float successRange)
	Get close to one particular tile (disregard the path).;;
	succeed if host->location.getDistanceTo(toChase) <= successRange
	fail if ticks <= 0
	tick { ticks -= 1 }
	step { 
	  host->location.step(host->walkingSpeed,toChase)
	  return true
	}
goto(Tile destination)
	Find a particular tile, follow path to get to it.;;
	succeed if host->location.isCloseAsPossibleTo(destination)
	+ Area destinationArea = null
	+ Tile toTile = null
	load {
	  destinationArea = destination->area
	}
	step {
	  if host->location->area != destinationArea {
	    host.add(0, new Activities.GotoArea(destinationArea))
	  }
	  else {
	    host->location.stepToward(event->host->walkingSpeed,destination)
	  }
	  return true
	}
Exploring(Integer ticks)
	Go to unexplored parts of the map.;;
	+ Tile destination = null
	succeed if ticks <=0
	load {
	  destination = event->host->location.getUnexploredPoint()
	}
	idle {
	  destination = event->host->location.getUnexploredPoint()
	}
	step {
	  ticks -= 1
	  if destination.isWithin(event->host->location) {
	    return false
	  }
	  else { 
	    event->host->location.stepToward(event->host->walkingSpeed,destination)
	    return true
	  }
	}